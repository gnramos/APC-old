{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"In\u00edcio","text":"<p>B. B. King</p> <p>A beleza do aprendizado \u00e9 que ningu\u00e9m pode tir\u00e1-lo de voc\u00ea.</p> <p>A tecnologia est\u00e1 cada vez mais presente em nossa sociedade, e um fator determinante neste processo \u00e9 o uso de computadores nas tarefas. Esta ferramenta consegue atuar em contextos t\u00e3o diversos porque \u00e9 feita para executar as instru\u00e7\u00f5es que lhe damos. A resolu\u00e7\u00e3o dos problemas \u00e9 consequ\u00eancia direta de conseguirmos determinar um conjunto adequado de instru\u00e7\u00f5es, tanto no sentido de guiarem o processo computacional para o resultado desejado quanto no de utilizar corretamente a m\u00e1quina dentro de suas limita\u00e7\u00f5es. O objetivo deste livro, portanto, \u00e9 ajudar a desenvolver as capacidades de resolver problemas e de executar suas solu\u00e7\u00f5es em computadores.</p> <p>O conte\u00fado apresentado envolve alguns conceitos e pr\u00e1ticas envolvidos nesta atividade. Ele serve para abrir as portas da Computa\u00e7\u00e3o para iniciantes e, talvez, acrescentar algum aprendizado \u00e0 programadores mais experientes. Nenhum conhecimento pr\u00e9vio \u00e9 necess\u00e1rio, mas facilidade com l\u00f3gica \u00e9 uma grande vantagem. A qualidade do aprendizado est\u00e1 intrinsecamente ligada \u00e0 consolida\u00e7\u00e3o da teoria pela realiza\u00e7\u00e3o das atividades pr\u00e1ticas propostas.</p> Formata\u00e7\u00e3o <p>Este livro usa as seguintes conven\u00e7\u00f5es para destacar algumas informa\u00e7\u00f5es.</p> <p>Defini\u00e7\u00e3o</p> <p>Apresenta a defini\u00e7\u00e3o de um conceito.</p> <p>Dica</p> <p>Apresenta uma informa\u00e7\u00e3o ou sugest\u00e3o relevante no contexto.</p> <p>Aten\u00e7\u00e3o</p> <p>Apresenta um aviso sobre uma situa\u00e7\u00e3o recorrente no contexto.</p> Algoritmo / Programa<pre><code>Apresenta um algoritmo ou programa.\n</code></pre> <p>Al\u00e9m disso, palavras importantes s\u00e3o destacadas e c\u00f3digo fonte \u00e9 apresentado em fonte <code>mono espa\u00e7ada</code>.</p> Por fim... <p>Este texto foi criado usando ferramentas livres como o mkdocs e Wikimedia Commons.</p> <p>Boa leitura!</p>"},{"location":"algoritmos/","title":"Algoritmos","text":"<p>Thomas H. Cormen</p> <p>Antes de existirem computadores, j\u00e1 havia algoritmos. Mas agora que os computadores existem, h\u00e1 ainda mais algoritmos, e os algoritmos s\u00e3o a base da computa\u00e7\u00e3o.</p> <p>Este cap\u00edtulo apresenta o conceito de algoritmo e algumas formas de represent\u00e1-lo. Ao final do texto, espera-se que se tenha um entendimento claro do que envolve este conceito e capacidade de expressar solu\u00e7\u00f5es como algoritmos.</p> <p>Algoritmos s\u00e3o \"m\u00e9todos\" ou instru\u00e7\u00f5es para realizar uma tarefa. Por exemplo, \u00e9 relativamente simples seguir os passos de uma receita para obter um bolo, seguir uma rota para chegar ao destino desejado, ou calcular um valor matem\u00e1tico. Para tanto, basta que se consiga entender e realizar cada etapa descrita.</p> <p>Um algoritmo descreve o processo para se obter um resultado, e espera-se que este resultado seja alcan\u00e7ado independentemente de quem esteja seguindo os passos. Pessoas diferentes seguindo uma mesma receita deveriam produzir o mesmo bolo, chegar ao mesmo local e obter o mesmo valor. Entretanto, seres humanos s\u00e3o muito inteligentes, e conseguem abstrair detalhes e inferir uma s\u00e9rie de informa\u00e7\u00f5es ausentes em sua comunica\u00e7\u00e3o. Considere o algoritmo abaixo, a maioria dos rec\u00e9m ingressos \u00e0 universidade n\u00e3o teria dificuldade em resolv\u00ea-lo com sucesso.</p> M\u00e9dia Aritm\u00e9tica<pre><code>Leia quatro n\u00fameros e calcule a m\u00e9dia aritm\u00e9tica.\n</code></pre> <p>Apesar da aparente simplicidade, ele apresenta diversas poss\u00edveis interpreta\u00e7\u00f5es. \"Leia quatro n\u00fameros\" significa ler todos de uma s\u00f3 vez ou um da cada vez? \"Calcule a m\u00e9dia aritm\u00e9tica\" se refere a de todos os n\u00fameros fornecidos, a de parte deles ou a de outros n\u00fameros n\u00e3o especificados? \u00c9 garantido que a pessoa a realizar a tarefa reconhece o termo \"m\u00e9dia aritm\u00e9tica\"? O que fazer com o resultado calculado?</p> <p>\u00c9 poss\u00edvel, portanto, que algu\u00e9m leia 2357, considere que este valor \u00fanico \u00e9 composto por \"quatro n\u00fameros\" (ignorando que representam apenas um valor), e calcule mentalmente a m\u00e9dia aritm\u00e9tica deles como 4 (j\u00e1 que a parte fracion\u00e1ria \u00e9 \"uma conta mais dif\u00edcil\"). Se voc\u00ea esperava que lhe fosse dito o valor exato de 4.25, ficaria desapontado...</p> <p>Esta varia\u00e7\u00e3o (e outras poss\u00edveis) n\u00e3o parece ser a forma mais \u00f3bvia de se resolver o problema, mas nem por isso est\u00e1 errada considerando a forma como as instru\u00e7\u00f5es foram apresentadas no algoritmo. A ideia por tr\u00e1s do conceito de algoritmo \u00e9 descrever um processo de modo que os mesmos resultados possam ser obtidos independentemente de que executa os passos. \u00c9 f\u00e1cil enxergar isso considerando uma receita de bolo sendo compartilhada: se for bem detalhada, mesmo uma pessoa que nunca cozinhou na vida consegue chegar ao resultado desejado. Portanto, buscamos essa descri\u00e7\u00e3o do processo que permite garantir o resultado e abstrair do contexto \"quem\" (ou \"o que\") realiza o esfor\u00e7o.</p> <p>Dica</p> <p>A principal caracter\u00edstica de um algoritmo \u00e9 sua corretude, ou seja, sua capacidade de realizar corretamente a tarefa conforme a especifica\u00e7\u00e3o.</p> <p>O computador \u00e9 uma ferramenta fant\u00e1stica que faz, muito rapidamente, exatamente o que pedimos - desde que esta solicita\u00e7\u00e3o seja feita de um modo que a m\u00e1quina consiga interpretar de forma inequ\u00edvoca. O objetivo se torna, portanto, definir um algoritmo computacional, ou seja, descrever as instru\u00e7\u00f5es do algoritmo de um modo espec\u00edfico e detalhado o suficiente para que o computador possa interpret\u00e1-las para realizar a tarefa em quest\u00e3o1.</p> <p>Algoritmo Computacional</p> <p>Uma sequ\u00eancia finita de instru\u00e7\u00f5es bem definidas para realizar uma tarefa com um computador.</p> <p>H\u00e1 discuss\u00f5es interessantes sobre a defini\u00e7\u00e3o precisa do conceito de um algoritmo computacional, mas as todas convergem no pontos mais importantes2. A sequ\u00eancia de instru\u00e7\u00f5es deve ser finita porque o objetivo \u00e9 realizar a tarefa, portanto a execu\u00e7\u00e3o deve terminar. As instru\u00e7\u00f5es utilizadas devem ser bem especificadas e com apenas uma interpreta\u00e7\u00e3o poss\u00edvel, de modo que o computador saiba exatamente o que fazer a cada passo. A realiza\u00e7\u00e3o da tarefa tamb\u00e9m pode lidar com entrada de dados e sa\u00edda de dados, ou seja, o algoritmo pode receber informa\u00e7\u00f5es externas necess\u00e1rias para a realiza\u00e7\u00e3o da tarefa e fornecer informa\u00e7\u00f5es resultantes deste processo. Por fim, os passos devem ser apresentados de tal forma que seja poss\u00edvel para o computador entender e executar cada um deles.</p> <p>Existem diversas formas de representar de um algoritmo e n\u00e3o h\u00e1 consenso de qual \u00e9 a melhor delas. Independentemente, o algoritmo deve ser representado da forma mais clara poss\u00edvel para facilitar seu entendimento por quem vai execut\u00e1-lo. Apresentamos a seguir algumas possibilidades.</p>"},{"location":"algoritmos/#descricao-narrativa","title":"Descri\u00e7\u00e3o Narrativa","text":"<p>A forma mais intuitiva de apresentar uma sequ\u00eancia de instru\u00e7\u00f5es, pois usa linguagem natural para faz\u00ea-lo, como no algoritmos de m\u00e9dia aritm\u00e9tica. Apesar de parecer simples por ser a forma que estamos acostumados a usar para comunica\u00e7\u00e3o, \u00e9 extremamente complexa pois considera a enorme capacidade humana de inferir coisas a partir de informa\u00e7\u00e3o incompleta.</p> <p>Essa \"facilidade\" inerente tem um contraponto: as instru\u00e7\u00f5es que usamos n\u00e3o s\u00e3o muito bem definidas e, portanto, o resultado obtido pode ser diferente do esperado dependendo de quem as interpreta. Por exemplo, considere o seguinte algoritmo:</p> Receita de Bolo<pre><code>Bata as claras em neve. Reserve. Bata bem as gemas com a margarina e o a\u00e7\u00facar. Acrescente o leite e farinha aos poucos sem parar de bater. Por \u00faltimo agregue as claras em neve e o fermento. Coloque em forma grande de furo central untada e enfarinhada. Asse em forno m\u00e9dio, pr\u00e9-aquecido, por aproximadamente 40 min. Quando espetar um palito e sair limpo estar\u00e1 assado.\n</code></pre> <p>Para algu\u00e9m que n\u00e3o esteja acostumado a atividades na cozinha, o algoritmo \u00e9 amb\u00edguo e impreciso. Como bater as claras? Por quanto tempo? Reservar o que? Onde? O que \u00e9 \"bater bem\"? Acrescentar o leite a que? Bater o que sem parar? Se n\u00e3o parar como posso fazer as outras coisas? Colocar o que na forma? O que \u00e9 \"enfarinhada\"? Assar a quantos graus? \"Aproximadamente\" s\u00e3o quantos minutos? Espetar o palito onde? O que \u00e9 \"limpo\"? O palito estar\u00e1 assado?</p> <p>Uma descri\u00e7\u00e3o narrativa detalhada o suficiente para evitar qualquer falha na interpreta\u00e7\u00e3o tende a ser bem mais extensa (e menos natural) do que estamos acostumados a utilizar em nossas conversas do dia a dia.</p>"},{"location":"algoritmos/#fluxograma","title":"Fluxograma","text":"<p>Outro jeito bastante intuitivo com o uso de figuras geom\u00e9tricas, como pode ser vista nos diagramas abaixo.</p> <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; EF{Entende&lt;br&gt;fluxogramas?}\n    EF --&gt;|Sim| O[/\u00d3timo!/] --&gt; F([Fim])\n    EF --&gt;|N\u00e3o| VLS{V\u00ea a linha&lt;br&gt;com 'Sim'?}\n    VLS --&gt;|Sim| VLN{E a com&lt;br&gt;'N\u00e3o'?} --&gt;|Sim| O\n    VLS --&gt;|N\u00e3o| ES[\u00c9 a outra&lt;br&gt;linha...]  --&gt; VLS\n    VLN --&gt;|N\u00e3o| MJ[/Mas j\u00e1&lt;br&gt;seguiu v\u00e1rias?!/] --&gt; SS[Siga a seta.] --&gt; VLS</code></pre> <p>Cada forma geom\u00e9trica tem um significado especifico mas, para facilitar, usaremos apenas as a seguir:</p> <ul> <li>Terminal: que indica onde o algoritmo inicia e onde termina.</li> <li>Dado(s): que indica a comunica\u00e7\u00e3o (entrada/sa\u00edda) de dado(s) com o algoritmo.</li> <li>Processo: que indica a execu\u00e7\u00e3o de uma instru\u00e7\u00e3o/tarefa.</li> <li>Decis\u00e3o: que indica a necessidade de se escolher uma (e apenas uma!) das diversas poss\u00edveis a\u00e7\u00f5es subsequentes.</li> <li>Seta: que indica a sequ\u00eancia em que as instru\u00e7\u00f5es ser\u00e3o executadas.</li> </ul> <pre><code>flowchart TD\n    I([Terminal]) --&gt;|seta| P[Processo] &amp; D{Decis\u00e3o} &amp; IO[/Entrada&lt;br&gt;Sa\u00edda/]</code></pre> <p>Geralmente se usa instru\u00e7\u00f5es mais diretas e simples que na descri\u00e7\u00e3o narrativa, tamb\u00e9m em fun\u00e7\u00e3o da limita\u00e7\u00e3o das figuras utilizadas. Isso tem dois efeitos muito interessantes: o uso de fluxograma restringe muito a amplitude do entendimento das instru\u00e7\u00f5es, facilitando a constru\u00e7\u00e3o de instru\u00e7\u00f5es bem definidas para o algoritmo; mas tamb\u00e9m restringe o tipo de instru\u00e7\u00f5es utiliz\u00e1veis, dificultando a constru\u00e7\u00e3o do processo desejado - podem ser necess\u00e1rias mais instru\u00e7\u00f5es para descrever adequadamente um peda\u00e7o mais complexo do comportamento.</p>"},{"location":"algoritmos/#pseudocodigo","title":"Pseudoc\u00f3digo","text":"<p>Outra abordagem bem interessante, pois visa diminuir o esfor\u00e7o de traduzir um algoritmo computacional em instru\u00e7\u00f5es que um computador possa usar. Utiliza termos simples e estruturas de uma linguagem de programa\u00e7\u00e3o, mas com sintaxe e regras menos restritivas. Por exemplo, o algoritmo abaixo em pseudoc\u00f3digo.</p> M\u00e9dia Aritm\u00e9tica<pre><code>In\u00edcio\n    Leia [nota_1]\n    Leia [nota_2]\n    Leia [nota_3]\n    Leia [nota_4]\n    m\u00e9dia  = (nota_1 + nota_2 + nota_3 + nota_4) \u00f7 4\n    Escreva o valor da [m\u00e9dia]\nFim\n</code></pre> <p>Note que o algoritmo da m\u00e9dia em pseudoc\u00f3digo come\u00e7a e termina com duas palavras, <code>In\u00edcio</code> e <code>Fim</code>. Estas, como as palavras <code>Leia</code> e <code>Escreva</code>, pertencem ao que chamamos de vocabul\u00e1rio controlado. O uso deste um conjunto mais restrito de palavras possibilita maior precis\u00e3o e efic\u00e1cia na comunica\u00e7\u00e3o das instru\u00e7\u00f5es.</p> <p>Outro diferencial \u00e9 a considera\u00e7\u00e3o de nomear as informa\u00e7\u00f5es, de modo a poder recuper\u00e1-las em passos subsequentes. Por exemplo, a segunda instru\u00e7\u00e3o obt\u00e9m um valor (comunica\u00e7\u00e3o de um dado) e lhe atribui um nome (<code>nota_1</code>); que \u00e9 recuperado no momento de calcular a soma dos n\u00fameros, na sexta instru\u00e7\u00e3o.</p> <p>Por fim, note tamb\u00e9m que as linhas com as instru\u00e7\u00f5es de cada passo do algoritmo est\u00e3o deslocadas para a direita em rela\u00e7\u00e3o \u00e0s palavras destacadas, ressaltando o conjunto de instru\u00e7\u00f5es dentro do bloco definido por elas. Este deslocamento \u00e9 denominado endenta\u00e7\u00e3o, e facilita a visualiza\u00e7\u00e3o da estrutura do algoritmo.</p> <p>Este detalhamento das instru\u00e7\u00f5es implica que o algoritmo com m\u00e9dia em pseudoc\u00f3digo ficou mais extenso e menos \"natural\" que o mesmo processo descrito no da m\u00e9dia detalhada, mas \u00e9 bem melhor definido e continua sendo de f\u00e1cil entendimento. Al\u00e9m disso, se aproxima mais da forma de representar um algoritmo como uma linguagem de programa\u00e7\u00e3o.</p>"},{"location":"algoritmos/#codigo","title":"C\u00f3digoResumoExerc\u00edcios","text":"<p>A representa\u00e7\u00e3o mais interessante de um algoritmo, pois pode ser diretamente aplicada a um computador. O algoritmo \u00e9 descrito como um programa de computador, ou seja, utilizando o vocabul\u00e1rio controlado e as regras de sintaxe de uma linguagem de programa\u00e7\u00e3o espec\u00edfica para definir cada passo. Neste caso, as instru\u00e7\u00f5es devem ser escritas cautelosamente de acordo com a linguagem, no n\u00edvel de complexidade determinado pelo projeto desta. Abaixo mostramos poss\u00edveis formas de apresentar a m\u00e9dia aritm\u00e9tica de quatro n\u00fameros.</p> PythonCRust M\u00e9dia Aritm\u00e9tica<pre><code>notas = map(float, input().split())\nprint(f'A m\u00e9dia \u00e9 {sum(notas) / len(notas)}')\n</code></pre> M\u00e9dia Aritm\u00e9tica<pre><code>#include &lt;stdio.h&gt;\nint main(void) {\nfloat nota_1, nota_2, nota_3, nota_4;\nscanf(\"%f%f%f%f\", &amp;nota_1, &amp;nota_2, &amp;nota_3, &amp;nota_4);\nprintf(\"A m\u00e9dia \u00e9 %f\\n\", (nota_1 + nota_2 + nota_3 + nota_4) / 4);\nreturn 0;\n}\n</code></pre> M\u00e9dia Aritm\u00e9tica<pre><code>fn main() {\nuse std::io;\nlet mut entrada = String::new();\nio::stdin().read_line(&amp;mut entrada).expect(\"Erro ao ler a entrada\");\nlet notas: Vec&lt;f32&gt; = entrada.split_whitespace()\n.map(|x| x.parse().expect(\"Entrada n\u00e3o \u00e9 um n\u00famero!\"))\n.collect();\nlet media = notas.iter().sum::&lt;f32&gt;() / notas.len() as f32;\nprintln!(\"A m\u00e9dia \u00e9  {:?}\", media);\n}\n</code></pre> <p>Um algoritmo \u00e9 uma sequ\u00eancia de instru\u00e7\u00f5es bem definidas para realiza\u00e7\u00e3o uma tarefa. Algoritmos representados como linguagens de programa\u00e7\u00e3o podem ser fornecidos a computadores para execu\u00e7\u00e3o.</p> Fa\u00e7a um algoritmo em descri\u00e7\u00e3o narrativa para trocar uma l\u00e2mpada queimada de um abajur j\u00e1 tendo outra l\u00e2mpada nova dispon\u00edvel. <p>Trocar L\u00e2mpada<pre><code>    Desligue o abajur da tomada e retire a l\u00e2mpada queimada desenroscando-a em sentido anti-hor\u00e1rio (separe para descartar no local apropriado). Pegue a l\u00e2mpada nova e a coloque no abajur, rosqueando-a no sentido hor\u00e1rio. Ligue o abajur na tomada.\n</code></pre></p> Represente o algoritmo para c\u00e1lculo da m\u00e9dia aritm\u00e9tica de quatro n\u00fameros usando fluxograma. <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; L4[/Leia 4 notas/] --&gt; M[\"\u00b5 = notas \u00f7 4\"] --&gt; A[Apresente \u00b5] --&gt; T([Fim])</code></pre> Monte um fluxograma para um algoritmo que leia os tr\u00eas coeficientes de uma equa\u00e7\u00e3o de segundo grau e diga se as ra\u00edzes s\u00e3o reais ou complexas, e se s\u00e3o iguais. \\(ax^2+bx+c = 0 \\Rightarrow r = \\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\\) <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; L4[/Leia 4 notas/] --&gt; D[\"\u0394 = b\u00b2 - 4ac\"] --&gt; M0{\"\u0394 &lt; 0?\"} --&gt;|Sim| RC[/Ra\u00edzes complexas/] --&gt; F([Fim])\n    M0 --&gt; |N\u00e3o| RR[/Ra\u00edzes reais/] --&gt; D0{\"\u0394 = 0?\"} --&gt;|Sim| VR[/Ra\u00edzes iguais/] --&gt; F\n    D0 --&gt;|N\u00e3o| F</code></pre> Descreva, em pseudoc\u00f3digo, um algoritmo para ler dois n\u00fameros e apresentar o resultado da divis\u00e3o do primeiro pelo segundo. Divis\u00e3o<pre><code>In\u00edcio\n    Escreva \"Digite o numerador: \"\n    Leia [numerador].\n    Escreva \"Digite o denominador: \"\n    Leia o [denominador].\n    divis\u00e3o = numerador \u00f7 denominador\n    Escreva \"O resultado \u00e9 [divis\u00e3o].\"\nFim\n</code></pre> Descreva, em pseudoc\u00f3digo, o algoritmo para ler a idade de uma pessoa (em anos, meses e dias), e escrever a quantidade de horas vividas por ela. Assuma que todo ano tem 365 dias e todo m\u00eas tem 30 dias. Dias vividos<pre><code>In\u00edcio\n    Escreva \"Digite quantos anos voc\u00ea tem: \"\n    Leia [anos].\n    Escreva \"Digite quantos meses voc\u00ea tem: \"\n    Leia [meses].\n    Escreva \"Digite quantos dias voc\u00ea tem: \"\n    Leia [dias].\n    total = ((anos * 365) + (meses * 30) + dias) * 24\n    Escreva \"Voc\u00ea j\u00e1 viveu [total] horas.\"\nFim\n</code></pre> <ol> <li> <p>Thomas H. Cormen. Algorithms Unlocked. The MIT Press, 2013. ISBN 9780262518802. URL: https://mitpress.mit.edu/9780262518802/algorithms-unlocked/.\u00a0\u21a9</p> </li> <li> <p>Donald E. Knuth. The Art of Computer Programming, Vol. 1: Fundamental Algorithms. Addison-Wesley, Reading, Mass., third edition, 1997. ISBN 0201896834 9780201896831. URL: https://www-cs-faculty.stanford.edu/~knuth/taocp.html#vol1.\u00a0\u21a9</p> </li> </ol>"},{"location":"ciencia_da_computacao/","title":"Ciencia da computacao","text":""},{"location":"ciencia_da_computacao/#ciencia-da-computacao","title":"Ci\u00eancia da Computa\u00e7\u00e3o","text":"<p>A tecnologia permeia todas as atividades humanas nos dias de hoje, principalmente alavancada pela disponibilidade e acessibilidade a ferramentas computacionais. Neste contexto, a Ci\u00eancia da Computa\u00e7\u00e3o torna-se uma \u00e1rea cada vez mais relevante.</p> <p>Dennis Ritchie</p> <p>Ci\u00eancia da Computa\u00e7\u00e3o \u00e9 diferente das disciplinas tradicionais. Filosoficamente, difere das ci\u00eancias f\u00edsicas porque n\u00e3o busca descobrir, explicar, ou explorar o mundo natural, mas estudar as propriedades de m\u00e1quinas criadas por humanos. Nisso \u00e9 an\u00e1loga a Matem\u00e1tica, e de fato a parte de \"ci\u00eancia\" da Ci\u00eancia da Computa\u00e7\u00e3o tem o esp\u00edrito matem\u00e1tico em sua maior parte. Mas um aspecto inevit\u00e1vel da Ci\u00eancia da Computa\u00e7\u00e3o \u00e9 a cria\u00e7\u00e3o de programas de computadores: objetos que, apesar de intang\u00edveis, est\u00e3o sujeitos ao com\u00e9rcio.</p> <p>A Ci\u00eancia da Computa\u00e7\u00e3o n\u00e3o \u00e9 \"ci\u00eancia\" por defini\u00e7\u00e3o (matem\u00e1tica? engenharia? arte? esporte?), nem sobre computadores (como ferramenta). A \u00e1rea pode ser considerada como uma tentativa de formalizar certos processos, definindo uma forma precisa de se falar sobre como realizar algo, em contraste a o que \u00e9 algo.</p> <p>Ci\u00eancia (do Latim scientia*, \"conhecimento\") \u00e9 uma forma sistem\u00e1tica de produzir conhecimento (via m\u00e9todo cient\u00edfico), ou o nome dado a estrutura organizada do conhecimento obtido. O m\u00e9todo cient\u00edfico \u00e9 um conjunto de regras b\u00e1sicas de como proceder para produzir conhecimento, criando algo novo ou corrigindo/incrementando conhecimentos pr\u00e9-existentes[@Newton1729]. Esta metodologia pode - e deve - ser aplicada a experimentos computacionais, mas a Ci\u00eancia da Computa\u00e7\u00e3o n\u00e3o tem este foco.</p> <p>O computador tamb\u00e9m n\u00e3o \u00e9 o objetivo da Ci\u00eancia da Computa\u00e7\u00e3o. A ideia \u00e9 que, uma vez formalizados os processos para realiza\u00e7\u00e3o de uma tarefa, algu\u00e9m (ou algo) possa execut\u00e1-los corretamente. O computador interpreta e executa rapidamente instru\u00e7\u00f5es muito simples, sendo uma das m\u00e1quinas mais vers\u00e1teis para realizar os processos.</p> <p>Edsger H. Dijkstra</p> <p>Ci\u00eancia da Computa\u00e7\u00e3o est\u00e1 t\u00e3o relacionada aos computadores quanto a Astronomia aos telesc\u00f3pios, Biologia aos microsc\u00f3pios, ou Qu\u00edmica aos tubos de ensaio. A Ci\u00eancia n\u00e3o estuda ferramentas. Ela estuda como n\u00f3s as utilizamos, e o que descobrimos com elas.}%</p> <p>O computador executa diversas tarefas por meio de seus processos, e para tanto lida com dois tipos de conhecimento. O primeiro deles \u00e9 o conhecimento declarativo que \u00e9 uma descri\u00e7\u00e3o de fato(s). Por exemplo, \"a raiz quadrada de \\(n\\) \u00e9 o n\u00famero \\(r\\) tal que \\(r^2 = n\\)\". Embora interessante, esta informa\u00e7\u00e3o serve apenas para verificar se \\(r\\) \u00e9 ou n\u00e3o raiz de \\(n\\), n\u00e3o resolve um problema relativamente comum de, dado o n\u00famero \\(n\\), descobrir qual \u00e9 \\(r\\) tal que satisfa\u00e7a a defini\u00e7\u00e3o.</p> <p>A Ci\u00eancia da Computa\u00e7\u00e3o est\u00e1 interessada no segundo tipo, o conhecimento procedural que especifica processos, indicando como [melhor] realizar algo. Por exemplo, para aproximar o valor \\(r\\), pode-se come\u00e7ar com \\(r = 0\\) e incrementar seu valor at\u00e9 que \\(r^2 \\geq n\\). Esta estrat\u00e9gia de busca exaustiva pode ser apresentada de forma um pouco mais estruturada:</p> <ol> <li>Defina \\(r = 0\\) e \\(n \\in \\mathbb{N}\\).</li> <li>Adicione 1 a \\(r\\).</li> <li>Se \\(r^2 \\geq n\\), ent\u00e3o pare (\\(r \\approx \\sqrt{n}\\)). Sen\u00e3o, v\u00e1 para o passo 2.</li> </ol> <p>Uma vez estabelecido o processo de calcular a raiz, este pode ser passado ao computador para que execute as etapas. A versatilidade desta m\u00e1quina permite que ela possa executar diversos tipos de processos com fins diferentes (ou n\u00e3o), desde que adequadamente definidos.</p> <p>A Ci\u00eancia da Computa\u00e7\u00e3o tenta formalizar este conhecimento procedural, e juntar seus blocos em sistemas grandes e complexos que podem ser [re]utilizados nas mais diversas \u00e1reas. Por exemplo, supondo as diversas Leis da F\u00edsica, pode-se elaborar diversos procedimentos para definir posi\u00e7\u00f5es e for\u00e7as, e juntar estes resultados para entretenimento, progresso, ou [praticamente] qualquer outra coisa que se possa imaginar.</p> <p>Esta \"m\u00e1gica\" ocorre via processos computacionais, que s\u00e3o entidades abstratas que existem nos computadores. A medida que evolui, o processo manipula dados (outras entidades abstratas), e esta evolu\u00e7\u00e3o \u00e9 dirigida por regras definidas em um programa (composto por express\u00f5es simb\u00f3licas em uma linguagens de programa\u00e7\u00e3o)1.</p> <p>Programa\u00e7\u00e3o \u00e9 a atividade de escrever os passos do processo de modo que o computador possa entend\u00ea-los e execut\u00e1-los. Programa\u00e7\u00e3o \u00e9 uma forma de arte, mas tamb\u00e9m \u00e9 uma habilidade que pode ser desenvolvida. E voc\u00ea deveria aprender a programar, afinal:</p> <p>Donald Knuth</p> <p>\u00c9 preciso ver um algoritmo para crer nele.</p> <p>No contexto acad\u00eamico, a Ci\u00eancia da Computa\u00e7\u00e3o segue as diretrizes curriculares do Minist\u00e9rio da Educa\u00e7\u00e3o[@MEC2005], e os esfor\u00e7os para incentivar a pesquisa e o ensino s\u00e3o guiados pela Sociedade Brasileira de Computa\u00e7\u00e3o.  O Projeto Pedag\u00f3gico do Curso de Bacharelado em Ci\u00eancia da Computa\u00e7\u00e3o[@ppcBCC2015] diz que o egresso deve possuir conhecimentos para encontrar solu\u00e7\u00f5es computacionais para v\u00e1rias \u00e1reas de conhecimento e estar preparado para a investiga\u00e7\u00e3o, desenvolvimento, an\u00e1lise, modelagem, projeto, e implementa\u00e7\u00e3o de sistemas computacionais, bem como para desenvolver pesquisa cient\u00edfica e tecnol\u00f3gica. Portanto, o profissional deveria ser capaz de resolver qualquer problema l\u00f3gico em qualquer \u00e1rea, desde que a solu\u00e7\u00e3o possa ser implementada em um computador.%</p> <p>Segundo o Curr\u00edculo de Refer\u00eancia da SBC para Cursos de Gradua\u00e7\u00e3o2, a atua\u00e7\u00e3o profissional dos egressos pode ter caracter\u00edsticas da \u00e1rea de computa\u00e7\u00e3o em tr\u00eas componentes, englobando aspectos gerais, t\u00e9cnicos e \u00e9tico-sociais. A regulamenta\u00e7\u00e3o da profiss\u00e3o de inform\u00e1tica est\u00e1 em processo de aprova\u00e7\u00e3o[@Bigonha2013], mas a SBC consolidou sua posi\u00e7\u00e3o institucional na formula\u00e7\u00e3o dos seguintes princ\u00edpios, que devem ser observados[@SBC2013]:</p> <ol> <li>exerc\u00edcio da profiss\u00e3o de Inform\u00e1tica deve ser livre e independer de diploma ou comprova\u00e7\u00e3o de educa\u00e7\u00e3o formal;</li> <li>nenhum conselho de profiss\u00e3o pode criar qualquer impedimento ou restri\u00e7\u00e3o ao princ\u00edpio acima;</li> <li>a \u00e1rea deve ser Auto-Regulada.</li> </ol> <ol> <li> <p>Harold Abelson, Gerald Jay Sussman, and Julie Sussman. Structure and Interpretation of Computer Programs. MIT Press, Cambridge, MA, USA, 1985. ISBN 0262010771.\u00a0\u21a9</p> </li> <li> <p>SBC. Curr\u00edculo de Refer\u00eancia da SBC para Cursos de Gradua\u00e7\u00e3o em Bacharelado em Ci\u00eancia da Computa\u00e7\u00e3o e Engenharia de Computa\u00e7\u00e3o. URL: http://www.sbc.org.br/documentos-da-sbc/category/131-curriculos-de-referencia.\u00a0\u21a9</p> </li> </ol>"},{"location":"computadores/","title":"Computadores","text":"<p>Joe Sondow</p> <p>Um computador \u00e9 como um g\u00eanio travesso. Te d\u00e1 exatamente o que voc\u00ea pede dele, mas nem sempre o que voc\u00ea quer.</p> <p>A humanidade \u00e9 engenhosa, e sempre buscou criar e aprimorar ferramentas para auxiliar nas realiza\u00e7\u00e3o de tarefas. Assim como o fogo e a roda, o computador \u00e9 uma ferramenta que revolucionou o mundo, e hoje em dia \u00e9 dif\u00edcil encontrar algum tipo de atividade que n\u00e3o seja (ou possa ser) auxiliada por esta m\u00e1quina que substituiu pessoas no esfor\u00e7o de processar dados e transform\u00e1-los em resultados. A hist\u00f3ria da computa\u00e7\u00e3o \u00e9 antiga e est\u00e1 entrela\u00e7ada com as hist\u00f3rias dos n\u00fameros, do hardware, de algoritmos e l\u00f3gica, e da programa\u00e7\u00e3o</p> <p>De forma simplificada, um computador \u00e9 uma m\u00e1quina que:</p> <ol> <li>realiza c\u00e1lculos [simples] rapidamente;</li> <li>lembra de [muitos] resultados.</li> </ol> <p>Um \"c\u00e1lculo\" \u00e9 a execu\u00e7\u00e3o de uma opera\u00e7\u00e3o primitiva pela m\u00e1quina, e um \"resultado\" \u00e9 uma informa\u00e7\u00e3o resultante desta opera\u00e7\u00e3o ou j\u00e1 conhecida. A computa\u00e7\u00e3o, portanto, lida basicamente com dois elementos, as informa\u00e7\u00f5es sendo manipuladas (dados) e as regras de manipula\u00e7\u00e3o delas (procedimentos)1. S\u00e3o tantas as aplica\u00e7\u00f5es e possibilidades que criou-se uma nova \u00e1rea de conhecimento: a Ci\u00eancia da Computa\u00e7\u00e3o, que estuda a fundamenta\u00e7\u00e3o te\u00f3rica das constru\u00e7\u00f5es computacionais, bem como suas aplica\u00e7\u00f5es em dispositivos tecnol\u00f3gicos e sistemas de computa\u00e7\u00e3o2.</p> <p>A computa\u00e7\u00e3o \u00e9 muito abrangente, envolvendo diversas outras (l\u00f3gica, matem\u00e1tica, etc.) e, apesar de n\u00e3o ser necessariamente focada nela, est\u00e1 intrinsecamente associada a uma ferramenta: o computador. Ao descrever solu\u00e7\u00f5es como procedimentos que manipulam (corretamente) dados, pode-se usar esta m\u00e1quina para resolver in\u00fameros problemas.</p> <p>A aplica\u00e7\u00e3o do pensamento computacional resulta em solu\u00e7\u00f5es representadas como etapas computacionais e algoritmos para execu\u00e7\u00e3o pelo computador, focando nos dois elementos b\u00e1sicos: conhecimento descritivo (o que?) e, principalmente, procedural (como?). Por exemplo, resolver o problema \"qual a raiz quadrada de um n\u00famero \\(n\\)?\" a solu\u00e7\u00e3o deve definir um processo que encontre um valor \\(r\\) tal que \\(r^2 = n\\), que \u00e9 um conhecimento descritivo. Uma abordagem \u00e9 o m\u00e9todo babil\u00f4nico:</p> M\u00e9todo Babil\u00f4nico<pre><code>Inicie com um n\u00famero positivo arbitr\u00e1rio r\nEnquanto r\u00b2 n\u00e3o for suficientemente pr\u00f3ximo a n:\n    Atualize o valor de r para a m\u00e9dia entre r e n/r.\n</code></pre> <p>Considerando \\(n = 144\\), uma estimativa inicial \\(r = 1\\) e que \"suficientemente pr\u00f3ximo\" signifique que \\(|n - r^2| \\leq 0,5\\), a aplica\u00e7\u00e3o das instru\u00e7\u00f5es acima resultam na constru\u00e7\u00e3o da seguinte sequ\u00eancia de valores para \\(r\\): 1, 72,5, 37,24, 20,55, 13,8 e, finalmente, 12,1. Uma descri\u00e7\u00e3o mais precisa destes algoritmo permite que o computador realize este processo mec\u00e2nico para chegar \u00e0 solu\u00e7\u00e3o desejada. Para lidar com problemas diferentes, basta fornecer grupos diferentes de instru\u00e7\u00f5es!</p> <p>Aten\u00e7\u00e3o</p> <p>O computador interpreta as instru\u00e7\u00f5es no sentido de receb\u00ea-las em uma representa\u00e7\u00e3o espec\u00edfica e traduzi-las em sua opera\u00e7\u00f5es primitivas para execu\u00e7\u00e3o, n\u00e3o no sentido de dar-lhes sentido para obter o resultado desejado. Ele faz o que voc\u00ea manda, n\u00e3o o que voc\u00ea quer.</p> <p>Entender mais sobre esta m\u00e1quina e como ela funciona \u00e9 essencial para us\u00e1-la na resolu\u00e7\u00e3o de problemas. O computador, al\u00e9m de processar e armazenar os dados, tamb\u00e9m precisa moviment\u00e1-los entre os dispositivos e controlar toda essa manipula\u00e7\u00e3o. Para tanto, \u00e9 preciso que diversos componentes el\u00e9tricos, eletr\u00f4nicos e eletromec\u00e2nicos (hardware) trabalhem em conjunto para realizar os processos definidos no algoritmo (software).</p>"},{"location":"computadores/#arquitetura-de-computadores","title":"Arquitetura de Computadores","text":"<p>A arquitetura do computador busca projetar a m\u00e1quina de tal forma a maximizar desempenho e efici\u00eancia energ\u00e9tica dentro das restri\u00e7\u00f5es de custo, pot\u00eancia e disponibilidade existentes3. A fun\u00e7\u00e3o principal do computador \u00e9 realizar as computa\u00e7\u00f5es, ou seja, processar os dados. Isso \u00e9 feito com as opera\u00e7\u00f5es b\u00e1sicas de l\u00f3gica e aritm\u00e9tica que s\u00e3o constru\u00eddas na m\u00e1quina. Para viabilizar estas opera\u00e7\u00f5es, \u00e9 preciso armazenar os dados, mov\u00ea-los entre os dispositivos de armazenagem e processamento e gerenciar esta movimenta\u00e7\u00e3o com o processamento.</p> <p>Na arquitetura mais comum, as instru\u00e7\u00f5es s\u00e3o vistas como informa\u00e7\u00f5es que armazenadas, ou seja, conhecimento descritivo, e s\u00e3o tratadas como dados que o computador processa. Este modelo de \"computador de programa armazenado\", em que as instru\u00e7\u00f5es e os dados existem em um mesmo meio f\u00edsico, \u00e9 conhecido como Arquitetura de von Neumann4, e \u00e9 a forma mais comum dos computadores modernos. Nela, a solu\u00e7\u00e3o de um problema \u00e9 obtida por um ciclo de execu\u00e7\u00e3o simples: busca (a pr\u00f3xima instru\u00e7\u00e3o), decodifica\u00e7\u00e3o (em instru\u00e7\u00f5es primitivas) e execu\u00e7\u00e3o (das primitivas realizando a computa\u00e7\u00e3o).</p> <pre><code>flowchart LR\n    I[Entrada]\n    subgraph Computador\n        M[Mem\u00f3ria]\n        subgraph Processador\n            UC[Unidade de Controle] --&gt; ULA[Unidade L\u00f3gica Aritm\u00e9tica] --&gt; UC\n        end\n    end\n    I[Entrada] --&gt; Computador --&gt; O[Sa\u00edda]\n    Processador --&gt; M --&gt; Processador</code></pre> <p>Este modelo representa os principais componentes necess\u00e1rios para o processo de ler a instru\u00e7\u00e3o, interpret\u00e1-la e execut\u00e1-la. A mem\u00f3ria armazena as instru\u00e7\u00f5es (conhecimento procedural) e os resultados intermedi\u00e1rios (conhecimento descritivo). Novos dados podem ser fornecidos ao computador por algum dispositivo de entrada ou obtidos dele por um dispositivo de sa\u00edda. O processador gerencia quais instru\u00e7\u00f5es devem ser realizadas e suas execu\u00e7\u00f5es, al\u00e9m de movimentar as informa\u00e7\u00f5es entre os componentes. Para isso, tem dispositivos que realizam opera\u00e7\u00f5es de aritm\u00e9tica e l\u00f3gica, testes simples, e manipula\u00e7\u00e3o de dados.</p> <p>A implementa\u00e7\u00e3o f\u00edsica deste modelo necessita de uma parte f\u00edsica que realiza a tarefa, e de uma parte l\u00f3gica que define como realiz\u00e1-la. Apesar de nos preocuparmos mais com a parte l\u00f3gica neste livro, ambas s\u00e3o essenciais para o bom funcionamento.</p>"},{"location":"computadores/#hardware","title":"Hardware","text":"<p>O hardware \u00e9 um conjunto de componentes e equipamentos que comp\u00f5em um sistema computacional, que seguem a arquitetura von Neumann. Os componentes f\u00edsicos t\u00eam diferentes prop\u00f3sitos.</p> <p></p> <ul> <li>\u00a03\u00a0, Unidade Central de Processamento (UCP) \u00e9 o dispositivo que interpreta e executa e instru\u00e7\u00f5es, l\u00ea e escreve a mem\u00f3ria. Seus componentes b\u00e1sicos s\u00e3o a UC (que determina quais opera\u00e7\u00f5es ser\u00e3o realizadas e em que ordem) e a ULA (que realiza opera\u00e7\u00f5es aritm\u00e9ticas e l\u00f3gicas). Os registradores, que armazenam os dados sendo processados no momento, tamb\u00e9m podem ser considerado parte da UCP, mas s\u00e3o conceitualmente parte da mem\u00f3ria. O desempenho da UCP era ligado a sua velocidade, mas certos limites j\u00e1 foram alcan\u00e7ados e, atualmente, os esfor\u00e7os s\u00e3o direcionados a outras formas de melhoria.</li> <li>\u00a04\u00a0, \u00a08\u00a0 mem\u00f3ria \u00e9 o dispositivo que permite armazenar dados em um conjunto ordenado de bits. A armazenagem pode ser vol\u00e1til (perde seus dados com aus\u00eancia de energia) ou n\u00e3o vol\u00e1teis. Al\u00e9m disso, h\u00e1 certa hierarquia de tipos, pois o custo \u00e9 inversamente proporcional a velocidade de acesso. A chamada mem\u00f3ria principal cont\u00e9m os dados sendo manipulados na tarefa em execu\u00e7\u00e3o (na mem\u00f3ria vol\u00e1til), portanto \u00e9 mais r\u00e1pida e intermedia o acesso aos dados da mem\u00f3ria secund\u00e1ria. Esta serve para armazenamento permanente de dados, tem maior capacidade mas desempenho inferior. A caracter\u00edstica mais interessante da mem\u00f3ria principal \u00e9 o acesso aleat\u00f3rio, em que posi\u00e7\u00f5es espec\u00edficas de mem\u00f3ria s\u00e3o acessadas diretamente, utilizando uma l\u00f3gica de endere\u00e7amento. Isto, e a velocidade do acesso, contrastam com a mem\u00f3ria secund\u00e1ria.</li> <li> <p>\u00a01\u00a0, \u00a07\u00a0, \u00a09\u00a0 e 10 Entrada/Sa\u00edda os dispositivos de entrada e sa\u00edda de dados (E/S ou I/O) permitem a comunica\u00e7\u00e3o com o computador, de modo que ele possa receber dados para realizar uma tarefa, e fornecer os resultados desta. Existem diversas formas de transmitir os dados:</p> <ul> <li>Entrada: teclado, mouse, microfone, scanner, leitor de c\u00f3digo de barras, c\u00e2mera, joystick, etc.;</li> <li>Sa\u00edda: monitor, caixas de som, impressora, etc.;</li> <li>E/S: disco r\u00edgido, monitor sens\u00edvel a toques, pendrive, etc.</li> </ul> </li> </ul> <p>Al\u00e9m destes componentes \"b\u00e1sicos\" da arquitetura von Neumann, diversos outros s\u00e3o necess\u00e1rios.</p> <ul> <li>\u00a02\u00a0, placa m\u00e3e conecta os componentes do computador de modo que possam funcionar em conjunto, possibilitando a comunica\u00e7\u00e3o entre eles e a distribui\u00e7\u00e3o de energia.</li> <li>\u00a05\u00a0, placas de expans\u00e3o que possibilitam o uso de outros componentes perif\u00e9ricos, ampliando as aplica\u00e7\u00f5es.</li> <li>\u00a06\u00a0, fonte de alimenta\u00e7\u00e3o que regula a distribui\u00e7\u00e3o de energia para os componentes.</li> <li>barramento \u00e9 o sistema de comunica\u00e7\u00e3o que transfere dados entre os componentes do computador. A taxa de transfer\u00eancia do barramento \u00e9 o que define seu desempenho. Barramentos: processador, cache, mem\u00f3ria, dispositivos de entrada/sa\u00edda, dados.</li> <li>mainFrame/supercomputador s\u00e3o computadores grande porte, geralmente dedicados a aplica\u00e7\u00f5es espec\u00edficas que demandam o processamento de grandes volumes de informa\u00e7\u00e3o.</li> <li>a \"nuvem\" \u00e9 o uso de computadores e servidores compartilhados e interligados por meio da Internet, seguindo o princ\u00edpio da computa\u00e7\u00e3o em grade.</li> </ul> <p>O funcionamento de um computador ocorre pela manipula\u00e7\u00e3o e comunica\u00e7\u00e3o de sinais el\u00e9tricos entre seus componentes, como um processo f\u00edsico, sendo os sinais mais simples s\u00e3o os sinais \"ligado\" e \"desligado\"5. Esse estado bin\u00e1rio de um sinal pode ser representado por um binary digit (um bit), um valor que pode ser um de dois estados distintos e mutuamente exclusivos6:<code>0</code> (desligado) ou <code>1</code> (ligado). Os conjuntos de bits determinam as informa\u00e7\u00f5es armazenadas, inclusive os programas que determinam o que a m\u00e1quina deve fazer.</p>"},{"location":"computadores/#software","title":"SoftwareExerc\u00edcios","text":"<p>O software \u00e9 a parte l\u00f3gica do sistema computacional, que define quais instru\u00e7\u00f5es devem ser executadas pelo hardware. Pode ser dividido em dois tipos, programas de sistema que possibilitam a intera\u00e7\u00e3o com o hardware (computador e perif\u00e9ricos) e fornecem uma plataforma para execu\u00e7\u00e3o das aplica\u00e7\u00f5es, que realizam tarefas mais espec\u00edficas como edi\u00e7\u00e3o de documentos, organiza\u00e7\u00e3o de dados, entretenimento, educacional, manipula\u00e7\u00e3o de m\u00eddia, e outros.</p> Programas de Sistema <p>O sistema operacional \u00e9 o conjunto de programas que gerencia o hardware e fornece servi\u00e7os comuns \u00e0s aplica\u00e7\u00f5es. Podem ser de tempo-real, multi-usu\u00e1rio, multi-tarefas, embarcado, entre outros. Possibilita a comunica\u00e7\u00e3o com os componentes de n\u00facleo, que controla execu\u00e7\u00e3o, interrup\u00e7\u00f5es, gerenciamento de mem\u00f3ria [virtual], acesso a disco e arquivos, comunica\u00e7\u00e3o com dispositivos, etc., bem como de comunica\u00e7\u00e3o, seguran\u00e7a, interface gr\u00e1fica, entre outros.</p> <p>Os sistemas mais conhecidos s\u00e3o: Unix (BSD, GNU-Linux, OS X), Microsoft Windows, Plan 9, Android, etc. \u00c9 poss\u00edvel ter uma ideia da utiliza\u00e7\u00e3o de cada sistema por sua fatia de mercado. Atualmente, o Windows domina o mercado de desktops, e o de dispositivos m\u00f3veis \u00e9 dividido entre Android e iOS. Mas a computa\u00e7\u00e3o de alto desempenho \u00e9 praticamente toda em Unix.</p> <p>Os utilit\u00e1rios s\u00e3o os programas que auxiliam a analisar e configurar o computador, como an\u00e1lise/manuten\u00e7\u00e3o de disco, an\u00e1lise de mem\u00f3ria, anti-v\u00edrus, armazenamento de dados, cifragem, compress\u00e3o, conectividade com a rede, c\u00f3pia de seguran\u00e7a, gerenciador de arquivos, monitora\u00e7\u00e3o do processador, sincroniza\u00e7\u00e3o de dados/arquivos, entre muitos outros. Alguns exemplos s\u00e3o an\u00e1lise/manuten\u00e7\u00e3o de disco, an\u00e1lise de mem\u00f3ria, anti-v\u00edrus, armazenamento de dados, cifragem, compress\u00e3o, conectividade com a rede, c\u00f3pia de seguran\u00e7a, gerenciador de arquivos, monitora\u00e7\u00e3o do processador, sincroniza\u00e7\u00e3o de dados/arquivos.</p> <p>Os controladores de dispositivos, tamb\u00e9m conhecidos como drivers de dispositivos, s\u00e3o os programas que gerenciam um hardware espec\u00edfico do computador, como barramento, impressora, m\u00e1quinas digitais, placa de rede/\u00e1udio/v\u00eddeo/aquisi\u00e7\u00e3o de sinais, scanner, smartphones, etc.</p> <p>As interfaces com usu\u00e1rio s\u00e3o programas que interagem com o usu\u00e1rio, geralmente divididos em fun\u00e7\u00e3o do uso via linha de comando ou interface gr\u00e1fica.</p> <p>Os programas de desenvolvimento auxiliam o desenvolvimento de programas, como compiladores, interpretadores, IDEs, montadores, depuradores, etc.</p> Aplica\u00e7\u00f5es <p>S\u00e3o os programas com fins espec\u00edficos, como navegadores, programa para escrit\u00f3rio, entretenimento, e muitos, muitos mais.</p> Descreva os componentes f\u00edsicos de um computador e suas funcionalidades. <p>A unidade central de processamento \u00e9 o dispositivo que interpreta e executa e instru\u00e7\u00f5es, l\u00ea e escreve a mem\u00f3ria, tendo como parte integrante os registradores que armazenam os dados sendo processados no momento. Mem\u00f3ria permite armazenar dados em um conjunto ordenado de bits.</p> <p>Os dispositivos de entrada e sa\u00edda de dados permitem que humanos e outras m\u00e1quinas se comunica\u00e7\u00e3o com o computador. Exemplos de dispositivos de entrada s\u00e3o: teclado, mouse, microfone, scanner, leitor de c\u00f3digo de barras, c\u00e2mera, joystick, etc. Exemplos de sa\u00edda s\u00e3o: monitor, caixas de som, impressora, etc. H\u00e1 dispositivos que fazem ambas: disco r\u00edgido, monitor sens\u00edvel a toques, pendrive, etc.</p> <p>O barramento \u00e9 o sistema de comunica\u00e7\u00e3o que transfere dados entre os componentes do computador (a taxa de transfer\u00eancia do barramento \u00e9 o que define o desempenho da m\u00e1quina). A fonte de alimenta\u00e7\u00e3o regula a distribui\u00e7\u00e3o de energia para os componentes. A placa m\u00e3e conecta os componentes do computador ao barramento e \u00e0 fonte.</p> H\u00e1 uma hierarquia entre os diferentes tipos de mem\u00f3ria, descreva-a. <p>A classifica\u00e7\u00e3o se d\u00e1 com base em dois conceitos: capacidade de armazenamento e velocidade de acesso. As mem\u00f3rias mais r\u00e1pidas t\u00eam menor capacidade, e vice-versa. O primeiro n\u00edvel \u00e9 a mem\u00f3ria interna, composta pelos registradores, pequenas unidades extremamente r\u00e1pidas no processador, e pela cache que serve para intermediar a comunica\u00e7\u00e3o ente os registradores e a mem\u00f3ria principal. O segundo n\u00edvel \u00e9 mem\u00f3ria RAM, que \u00e9 diretamente ligada \u00e0 UCP para leitura/escrita e j\u00e1 detalhada no texto.</p> <p>O pr\u00f3ximo n\u00edvel \u00e9 a mem\u00f3ria secund\u00e1ria (n\u00e3o vol\u00e1til), que \u00e9 acessada indiretamente pela UCP uma vez que seu conte\u00fado \u00e9 transmitido pelo sistema operacional e componentes de comunica\u00e7\u00e3o para a mem\u00f3ria principal. A capacidade tende a ser significativamente maior que da prim\u00e1ria, e exemplos de dispositivos assim s\u00e3o CDs, SSDs, etc. O \u00faltimo n\u00edvel \u00e9 a mem\u00f3ria terci\u00e1ria, que envolve a manipula\u00e7\u00e3o de informa\u00e7\u00f5es que s\u00e3o muito raramente utilizadas, tanto que podem ser armazenadas de forma isolada, necessitando a reconex\u00e3o f\u00edsica \u00e0 m\u00e1quina (para copiar os dados para a mem\u00f3ria secund\u00e1ria).</p> <ol> <li> <p>Harold Abelson, Gerald Jay Sussman, and Julie Sussman. Structure and Interpretation of Computer Programs. MIT Press, Cambridge, MA, USA, 1985. ISBN 0262010771.\u00a0\u21a9</p> </li> <li> <p>SBC. Curr\u00edculo de Refer\u00eancia da SBC para Cursos de Gradua\u00e7\u00e3o em Bacharelado em Ci\u00eancia da Computa\u00e7\u00e3o e Engenharia de Computa\u00e7\u00e3o. URL: http://www.sbc.org.br/documentos-da-sbc/category/131-curriculos-de-referencia.\u00a0\u21a9</p> </li> <li> <p>John L. Hennessy and David A. Patterson. Computer Architecture, Fifth Edition: A Quantitative Approach. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 5th edition, 2011. ISBN 012383872X.\u00a0\u21a9</p> </li> <li> <p>M.D. Godfrey and D.F. Hendry. The computer as von Neumann planned it. IEEE Annals of the History of Computing, 15(1):11\u201321, 1993. doi:10.1109/85.194088.\u00a0\u21a9</p> </li> <li> <p>David A. Patterson and John L. Hennessy. Computer Organization and Design. Morgan Kaufmann Publishers, 2nd edition, 1998. ISBN 15-586-0428-6.\u00a0\u21a9</p> </li> <li> <p>Aaron M Tenenbaum, Yedidyah Langsam, and Moshe Augenstein. Estruturas de dados usando C. Pearson Makron Books, S\u00e3o Paulo (SP), 1995. ISBN 8534603480 : 9788534603485.\u00a0\u21a9</p> </li> </ol>"},{"location":"pensamento_computacional/","title":"Pensamento Computacional","text":"<p>Albert Einstein</p> <p>N\u00e3o podemos resolver um problema usando o mesmo tipo de pensamento que usamos quando os criamos.</p> <p>Este cap\u00edtulo apresenta as principais ideias do pensamento computacional e como elas podem ser aplicadas. Ao final do texto, espera-se que se tenha uma no\u00e7\u00e3o de como eles podem s\u00e3o utilizados na resolu\u00e7\u00e3o de problemas diferentes.</p> <p>Um aspecto da vida cotidiana \u00e9 o fluxo de atividades, muitas destas com um prop\u00f3sito espec\u00edfico. Nelas, \u00e9 muito comum se ter um objetivo em mente e ponderar sobre como atingi-lo para, ent\u00e3o, elaborar uma sequ\u00eancia de passos que levem ao mesmo. Pode-se considerar que chegar ao objetivo \u00e9 um problema a ser resolvido, e que os passos adequados comp\u00f5em sua solu\u00e7\u00e3o. Uma vez determinada a solu\u00e7\u00e3o para um problema espec\u00edfico, espera-se que ela funcione para toda inst\u00e2ncia do problema. Por exemplo, uma receita \u00e9 uma solu\u00e7\u00e3o adequada para se ter um bolo, e toda vez que se quiser o bolo, bastaria seguir a receita. Esta solu\u00e7\u00e3o resolve at\u00e9 o problema de outras pessoas! Desde que elas queiram este mesmo bolo...</p> <p>A obten\u00e7\u00e3o de uma solu\u00e7\u00e3o pode ser um processo criativo complexo, com etapas de elabora\u00e7\u00e3o, implementa\u00e7\u00e3o e verifica\u00e7\u00e3o. Quando funciona, este processo pode ser muito satisfat\u00f3rio, afinal quem n\u00e3o gosta de bolo? Claro, esta ideia tamb\u00e9m se aplica a outros problemas. \u00c9 poss\u00edvel definir os passos para montar um m\u00f3vel (manual de instru\u00e7\u00f5es), para conseguir lidar com a demanda de clientes em uma institui\u00e7\u00e3o (filas e prioridades), e muito mais.</p> <p>Um algoritmo pode ser considerado como uma descri\u00e7\u00e3o dos passos necess\u00e1rios para resolver o problema, ou seja, representa uma solu\u00e7\u00e3o que poderia ser executada por um agente qualquer. O computador \u00e9 uma m\u00e1quina capaz de interpretar e executar certas instru\u00e7\u00f5es, podendo ser o agente que executa o algoritmo, desde que este seja representado com as instru\u00e7\u00f5es espec\u00edficas que o computador entenda. Assim, para que a m\u00e1quina resolva nossos problemas, devemos guiar o processo de elabora\u00e7\u00e3o de solu\u00e7\u00f5es como uma atividade de cria\u00e7\u00e3o de um algoritmo computacional, que \u00e9 a descri\u00e7\u00e3o precisa de um procedimento para realizar uma tarefa, de modo que um computador possa execut\u00e1-la1.</p> <p>O pensamento computacional \u00e9 o processo envolvido na formula\u00e7\u00e3o de problemas de modo que suas solu\u00e7\u00f5es possam ser representadas como etapas computacionais e algoritmos2. S\u00e3o os processos mentais envolvidos na descri\u00e7\u00e3o de um problema de tal forma que a solu\u00e7\u00e3o possa ser executada por uma pessoa ou por um computador3. Como a computa\u00e7\u00e3o tem permeado cada vez mais nossa vida, e a no\u00e7\u00e3o do pensamento computacional tem sido incorporada como conhecimento desej\u00e1vel para uma pessoa. Uma proposta \u00e9 que o aluno se torne um \"pensador computacional\"4 e, neste caso, espera-se que ele aprenda a:</p> <ul> <li>desenvolver e usar estrat\u00e9gias para resolver problemas com tecnologia;</li> <li>formular problemas para serem resolvidos com a ajuda da tecnologia como coleta e an\u00e1lise de dados, abstra\u00e7\u00e3o e aplica\u00e7\u00e3o de algoritmos;</li> <li>decompor problemas, extrair as informa\u00e7\u00f5es relevantes e conseguir produzir modelos que facilitem a resolu\u00e7\u00e3o d problemas;</li> <li>entender como a automa\u00e7\u00e3o funciona junto ao pensamento algor\u00edtmico para juntar etapas manuais em solu\u00e7\u00f5es automatizadas.</li> </ul> <p>Essencialmente, o pensamento computacional envolve habilidades de converter problemas reais, que s\u00e3o complexos, confusos e mal definidos, em algo que um aut\u00f4mato sem intelig\u00eancia (o computador) consiga resolver sem aux\u00edlio de algu\u00e9m5. H\u00e1 muitos conceitos envolvidos6, como coleta e an\u00e1lise de dados, representa\u00e7\u00e3o de dados e paraleliza\u00e7\u00e3o - vale a pena procurar saber mais sobre eles! Os principais conceitos do processo s\u00e3o apresentados a seguir.</p>"},{"location":"pensamento_computacional/#abstracao","title":"Abstra\u00e7\u00e3o","text":"<p>Abstrair \u00e9 o processo de identificar um conjunto de caracter\u00edsticas invariantes fundamentais a algo7. \u00c9 reconhecer similaridades entre objetos ou situa\u00e7\u00f5es de um problema e focar apenas nelas, ignorando as especificidades para facilitar a forma como tratar o problema8.</p> <p>Por exemplo, o problema de cultivar uma rosa vermelha. Como buscamos o processo de mant\u00ea-la saud\u00e1vel, podemos assumir que este processo independe da cor e, portanto, abstrair este detalhe para cultivar uma rosa. Se for uma esp\u00e9cie de rosa mais robusta, podemos abstrair novamente e simplificar o problema para o cultivo de uma flor. Dependendo da esp\u00e9cie, talvez possamos dar um passo al\u00e9m e reduzir o problema para \"como cultivar uma planta?\" (dar mais um passo e considerar como manter um ser vivo \u00e9 poss\u00edvel, mas excessivo neste contexto).</p> <p>A abstra\u00e7\u00e3o \u00e9 um processo inerente no contexto de pensamento computacional, pois \u00e9 preciso transformar o problema e sua solu\u00e7\u00e3o em representa\u00e7\u00f5es abstratas em um programa de computador. Por exemplo, podemos ter todos os in\u00fameros detalhes de uma cidade, como distribui\u00e7\u00e3o de casas e lojas, tamanhos de constru\u00e7\u00f5es, cores, popula\u00e7\u00e3o, consumo energ\u00e9tico, formas de movimenta\u00e7\u00e3o, etc. Entretanto, para descobrir a rota da sua posi\u00e7\u00e3o at\u00e9 uma loja, podemos abstrair quase tudo e considerar apenas com uma representa\u00e7\u00e3o de certas localiza\u00e7\u00f5es e dos acesso entre elas.</p> UnB \"Real\" Abstra\u00e7\u00e3o"},{"location":"pensamento_computacional/#decomposicao","title":"Decomposi\u00e7\u00e3o","text":"<p>A decomposi\u00e7\u00e3o \u00e9 o processo de separar o problema em partes, ou subproblemas, de modo que cada um deles seja menor e mais simples - portanto mais f\u00e1cil de ser resolvido. Esse processo pode ser repetido at\u00e9 que se tenha um problema simples o suficiente para elaborar uma solu\u00e7\u00e3o. Depois, basta juntar as solu\u00e7\u00f5es de cada subproblema de forma coesa para obter a solu\u00e7\u00e3o do problema original.</p> <p>O primeiro passo para decompor um problema \u00e9 entend\u00ea-lo corretamente de modo a identificar e descrever os processos (e subproblemas) envolvidos na sua resolu\u00e7\u00e3o. Com essa informa\u00e7\u00e3o, \u00e9 poss\u00edvel particionar os processos (e subproblemas) em passos distintos, que ent\u00e3o s\u00e3o organizados de forma estruturada para que possam ser executados.</p> <p>Por exemplo, para calcular a trajet\u00f3ria de um foguete, \u00e9 mais f\u00e1cil decompor o movimento dele nas componentes acelera\u00e7\u00e3o, velocidade e deslocamento e considerar o efeito de cada uma. A decomposi\u00e7\u00e3o continua ao trat\u00e1-las, pois cada uma pode ser decomposta em componentes espec\u00edficos do sistema de coordenadas sendo utilizado. Num sistema cartesiano, a acelera\u00e7\u00e3o \u00e9 tratada como a varia\u00e7\u00e3o da posi\u00e7\u00e3o ao longo do tempo nos eixos, portanto a an\u00e1lise pode ser decomposta para cada eixo \\(x\\), \\(y\\) e \\(z\\).</p> Foguete Componentes do movimento Componentes da acelera\u00e7\u00e3o <p>E o processo pode continuar at\u00e9 que as tarefas seja exequ\u00edveis.</p>"},{"location":"pensamento_computacional/#generalizacao","title":"Generaliza\u00e7\u00e3o","text":"<p>Generalizar \u00e9 criar modelos, regras, princ\u00edpios ou teorias que se adequem \u00e0 uma classe de problemas partir de padr\u00f5es observados em inst\u00e2ncias espec\u00edficas do problema. A ideia \u00e9 que, partindo de uma solu\u00e7\u00e3o correta, esta seja adaptada de modo que possa ser aplicada em problemas similares.</p> <p>Por exemplo, um tri\u00e2ngulo equil\u00e1tero tem os 3 \u00e2ngulos internos iguais a 60\u00b0 e as 3 linhas com o mesmo comprimento. A partir disso, \u00e9 relativamente simples definir um algoritmo que desenhe um. Da mesma forma, um quadrado tem os 4 \u00e2ngulos internos iguais a 90\u00b0 e as 4 linhas com o mesmo comprimento, e tamb\u00e9m \u00e9 simples desenhar um, basta criar linhas com os \u00e2ngulos adequados. Considerando o pent\u00e1gono regular, \u00e9 poss\u00edvel perceber que as solu\u00e7\u00f5es s\u00e3o muito similares... A solu\u00e7\u00e3o proposta constr\u00f3i o desenho de modo que cada linha continua a partir do fim da linha anterior, usando o \u00e2ngulo externo do pol\u00edgono para a rota\u00e7\u00e3o.</p> Propriedade dos \u00e2ngulos interno/externo Tri\u00e2nguloQuadradoPent\u00e1gono Tri\u00e2ngulo Equil\u00e1tero<pre><code>\u00e2ngulo_interno = 60\u00b0\n\u00e2ngulo_externo = 180\u00b0 - \u00e2ngulo_interno\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\n</code></pre> Quadrado<pre><code>\u00e2ngulo_interno = 90\u00b0\n\u00e2ngulo_externo = 180\u00b0 - \u00e2ngulo_interno\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\n</code></pre> Pent\u00e1gono Regular<pre><code>\u00e2ngulo_interno = 72\u00b0\n\u00e2ngulo_externo = 180\u00b0 - \u00e2ngulo_interno\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em 1\u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\n</code></pre> <p>Nos algoritmos, os \u00e2ngulos e a quantidade de linhas s\u00e3o diferentes, mas tamb\u00e9m \u00e9 poss\u00edvel reconhecer um padr\u00e3o nas instru\u00e7\u00f5es. A propriedade geom\u00e9trica de pol\u00edgonos determina que a soma de todos os \u00e2ngulos externos de um pol\u00edgono \u00e9 360\u00b0, e como os \u00e2ngulos s\u00e3o iguais, \u00e9 poss\u00edvel determinar o \u00e2ngulo para cada forma geom\u00e9trica apenas com a informa\u00e7\u00e3o de quantos lados ela tem. Assim, pode-se rescrever os algoritmos e chegar a uma solu\u00e7\u00e3o gen\u00e9rica que atende qualquer pol\u00edgono regular.</p> Tri\u00e2nguloQuadradoPent\u00e1gonoPol\u00edgonoPython + Turtle Tri\u00e2ngulo Equil\u00e1tero<pre><code>\u00e2ngulo_externo = 360 / 3\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Ret\u00e2ngulo Regular<pre><code>\u00e2ngulo_externo = 360 / 4\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Pent\u00e1gono Regular<pre><code>\u00e2ngulo_externo = 360 / 5\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Pol\u00edgono Regular<pre><code>\u00e2ngulo_externo = 360 / n\u00famero_de_lados\n\nRepita n\u00famero_de_lados vezes:\n    Desenhe uma linha de comprimento L.\n    Gire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Pol\u00edgono Regular<pre><code>angulo_externo = 360 / num_lados\nfor _ in range(num_lados):\nlinha(comprimento)\nesquerda(angulo_externo)\n</code></pre>"},{"location":"pensamento_computacional/#projeto-de-algoritmos","title":"Projeto de Algoritmos","text":"<p>O passo final do pensamento computacional \u00e9 criar uma sequ\u00eancia de instru\u00e7\u00f5es que resolve o problema. O ponto chave \u00e9 guiar o racioc\u00ednio. Para tanto, \u00e9 preciso considerar uma s\u00e9rie de coisas. Qual o objetivo principal? Como abstrair o contexto? Como decomp\u00f4-lo em partes mais acess\u00edveis? Em que ordem estas partes devem ser tratadas?</p> <p>Pensamento Algor\u00edtmico</p> <p>Processo de construir uma sequ\u00eancia de passos ordenados que pode ser seguida para obter uma solu\u00e7\u00e3o para todos os problemas constituintes necess\u00e1rios para resolver o problema original8.</p> <p>A aplica\u00e7\u00e3o do pensamento algor\u00edtmico depende de certas informa\u00e7\u00f5es sobre o problema. Quais as informa\u00e7\u00f5es fornecidas? O que se espera como resultado? O que se deve fazer depende de certas condi\u00e7\u00f5es? H\u00e1 alguma parte que precisa ser repetida?</p> <p>Dica</p> <p>Duas ideias que ajudam este processo s\u00e3o: 1) se perguntar \"E se eu fizesse desse jeito?\" (explorando formas diferentes de resolver o problema); e 2) explicar a sua solu\u00e7\u00e3o a algu\u00e9m (ou a um pato de borracha), ao tentar ensinar uma solu\u00e7\u00e3o voc\u00ea estar\u00e1 efetivamente aprendendo sobre ela.</p> <p>Com um entendimento adequado do problema e seu contexto, pode-se projetar o algoritmo. Mais detalhes sobre isso ser\u00e3o discutidos no pr\u00f3ximo cap\u00edtulo, mas o grande Richard Feynman tem um abordagem praticamente infal\u00edvel para isso:</p> Abordagem Feyman de Resolu\u00e7\u00e3o de Problemas <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; P[/Obtenha as informa\u00e7\u00f5es do problema./] --&gt; E[/Escreva o problema/] --&gt; P2[Pense muito sobre o problema] --&gt; E2[/Escreva a solu\u00e7\u00e3o do problema/] --&gt; F([Fim])</code></pre> <p>\u00c9 claro, alguns problemas n\u00e3o t\u00eam solu\u00e7\u00e3o e outra abordagem seria \"consigo mostrar que ele n\u00e3o pode ser resolvido?\" (e assim determinar a solu\u00e7\u00e3o que \u00e9 \"n\u00e3o \u00e9 poss\u00edvel resolver\"). Independentemente, a parte mais importante do pensamento computacional \u00e9, obviamente, o racioc\u00ednio aplicado no projeto da solu\u00e7\u00e3o.</p>"},{"location":"pensamento_computacional/#avaliacao","title":"Avalia\u00e7\u00e3o","text":"<p>A avalia\u00e7\u00e3o visa garantir que a solu\u00e7\u00e3o algor\u00edtmica \u00e9 adequada, ou seja, que resolve o problema. H\u00e1 diversas propriedades que podem/devem ser verificadas.</p> <ul> <li>Corretude: o algoritmo \u00e9 correto se fornece o resultado correto para toda entrada v\u00e1lida9.</li> <li>Efici\u00eancia: o algoritmo \u00e9 eficiente se consome o m\u00ednimo de recursos poss\u00edveis para fornecer um resultado; geralmente o foco \u00e9 em tempo (o qu\u00e3o r\u00e1pido \u00e9 sua execu\u00e7\u00e3o).</li> <li>Usabilidade: o qu\u00e3o f\u00e1cil \u00e9 para usar, lembrar e aprender o algoritmo10.</li> </ul> <p>A corretude \u00e9 a principal caracter\u00edstica, as demais n\u00e3o t\u00eam import\u00e2ncia se a solu\u00e7\u00e3o que n\u00e3o resolve o problema. Tamb\u00e9m \u00e9 um conceito ardiloso1 pois pode depender do contexto. Por exemplo, um algoritmo que aproxima o valor de \\(\\pi\\) pode ser correto num contexto em que a precis\u00e3o de 2 casas decimais \u00e9 suficiente (por exemplo, apresentando resultados simples \u00e0 pessoas), mas incorreto em outro onde a precis\u00e3o necessariamente deve ser bem maior (como calculando trajet\u00f3rias de naves espaciais). A efici\u00eancia n\u00e3o \u00e9 o foco da parte inicial mas ser\u00e1 discutida no cap\u00edtulo de estruturas de dados, e pode ser uma caracter\u00edstica fundamental da solu\u00e7\u00e3o em certos contexto (como o piloto autom\u00e1tico de uma aeronave). No\u00e7\u00f5es de usabilidade e legibilidade do c\u00f3digo permeiam o texto e ser\u00e3o destacadas quando apropriado.</p> <p>Esta verifica\u00e7\u00e3o \u00e9 um processo complexo, que pode ser feita de diversas formas. A mais simples \u00e9 testar o resultado obtido para situa\u00e7\u00f5es conhecidas, e fazer isso na totalidade das condi\u00e7\u00f5es poss\u00edveis ou numa abrang\u00eancia adequada. Quando isto n\u00e3o \u00e9 poss\u00edvel (talvez por que demore demais), h\u00e1 outras formas, como verificar as situa\u00e7\u00f5es antes (pr\u00e9-condi\u00e7\u00e3o) e depois (p\u00f3s-condi\u00e7\u00e3o) de cada passo no algoritmo, ele ser\u00e1 correto se e somente se ambas forem verdadeiras.</p>"},{"location":"pensamento_computacional/#automacao","title":"Automa\u00e7\u00e3oResumoExerc\u00edcios","text":"<p>O uso de mecanismos para realiza\u00e7\u00e3o de um processo espec\u00edfico tem uma s\u00e9rie de vantagens. Provavelmente aumenta a efici\u00eancia na produ\u00e7\u00e3o dos resultados e a uniformidade destes, reduz a incid\u00eancia de erros e viabiliza o recurso humano para lidar com outras atividades. Al\u00e9m disso, muitas tarefas cotidianas s\u00e3o repetitivas e poderiam ser realizadas por um computador dadas as instru\u00e7\u00f5es corretas11.</p> <p>Parte importante deste processo \u00e9 o entendimento do que pode ser computado e tamb\u00e9m do que n\u00e3o pode ser. O computador existe como entidade f\u00edsica e opera dentro de certos limites. Portanto, apesar de podermos planejar solu\u00e7\u00f5es matematicamente corretas, \u00e9 poss\u00edvel que estas n\u00e3o possam ser executadas na m\u00e1quina. Por exemplo, h\u00e1 m\u00e9todos para calcular o valor exato de \u03c0, mas o resultado \u00e9 um valor irracional e o processo para calcular o valor exato tamb\u00e9m \u00e9 infinitamente demorado!</p> \\[\\pi = 4\\cdot\\sum\\limits_{n=0}^{\\infty}\\frac{(-1)^n}{2n+1}\\] <p>Al\u00e9m disso, certas opera\u00e7\u00f5es podem demandar que uma quantidade invi\u00e1vel de informa\u00e7\u00f5es seja armazenada, ou que sejam realizados tantos processos que se torna impratic\u00e1vel aguardar o t\u00e9rmino da computa\u00e7\u00e3o (se ocorrer). O processo de formula\u00e7\u00e3o de uma solu\u00e7\u00e3o algor\u00edtmica necessariamente deve considerar essas limita\u00e7\u00f5es de modo a chegar a uma op\u00e7\u00e3o que seja realiz\u00e1vel.</p> <p>Outro aspecto relevante neste processo \u00e9 que, para ser realizada por um computador, a tarefa e deve ser programada de tal modo que os padr\u00f5es de intera\u00e7\u00e3o envolvidos escondam, mas n\u00e3o retirem os detalhes do contexto. Em Ci\u00eancia da Computa\u00e7\u00e3o, essa abstra\u00e7\u00e3o \u00e9 o processo de eliminar especificidades ao ignorar certas caracter\u00edsticas e de esconder informa\u00e7\u00f5es que n\u00e3o sejam necess\u00e1rias12, o que permite que os padr\u00f5es de intera\u00e7\u00f5es entre processos sejam aplic\u00e1veis em diversos contextos.</p> <p>Lorem ipsum.</p> H\u00e1 dois cubos aparentemente id\u00eanticos, sendo um um pouco mais leve que o outro. Aplique o pensamento computacional para elaborar uma solu\u00e7\u00e3o para o problema de, tendo acesso a uma balan\u00e7a digital, encontrar o mais pesado. <p>O processo pode ser decomposto em duas etapas: an\u00e1lise de um cubo e compara\u00e7\u00e3o dos resultados da an\u00e1lise. A solu\u00e7\u00e3o pode ser descrita em 7 passos: 1) por o primeiro cubo na balan\u00e7a, 2) anotar sua massa, 3) por o segundo cubo na balan\u00e7a, 4) anotar sua massa, 5) comparar os valores anotados, 6) identificar qual o de maior massa e 7) apresenta\u00e7\u00e3o do cubo mais pesado.</p> H\u00e1 dois bolos aparentemente id\u00eanticos, sendo um pouco mais leve que o outro. Aplique o pensamento computacional para elaborar uma solu\u00e7\u00e3o para o problema de, tendo acesso a uma balan\u00e7a de dois pratos (que n\u00e3o indica a massa, mas apenas qual dos pratos est\u00e1 com mais peso), encontrar o bolo mais leve. <p>Este \u00e9 um problema diferente do anterior, mas alguns detalhes podem ser abstra\u00eddos: ao inv\u00e9s de bolos ou cubos, considera-se que h\u00e1 objetos a serem pesados; e em vez de um valor espec\u00edfico para a massa de cada objeto, tem-se um mecanismo que fornece o resultado direto da compara\u00e7\u00e3o entre eles. Novamente o processo pode ser decomposto em duas etapas: disposi\u00e7\u00e3o dos objetos na balan\u00e7a e an\u00e1lise da inclina\u00e7\u00e3o dos pratos. A solu\u00e7\u00e3o pode ser descrita em 2 passos: 1) por cada objeto em um prato na balan\u00e7a e 2) apresentar o objeto que estiver no prato mais alto. Isso poderia ser facilmente adaptado para o problema de achar o objeto mais pesado.</p> Considere 1000 cubos aparentemente id\u00eanticos, sendo um deles um pouco mais pesado que os demais. Aplique o pensamento computacional para elaborar uma solu\u00e7\u00e3o para o problema de encontrar o cubo mais pesado. <p>Uma abordagem \u00e9 aproveitar o comportamento descrito na quest\u00e3o anterior. Ao comparar dois cubos, se os pratos estiverem desalinhados sabe-se que o que estiver no prato mais baixo \u00e9 o desejado. Caso contr\u00e1rio, basta descartar um deles e substitu\u00ed-lo por outro cubo ainda n\u00e3o avaliado. Estes passos s\u00e3o repetidos at\u00e9 que se ache o mais pesado, o que pode levar at\u00e9 999 compara\u00e7\u00f5es na balan\u00e7a.</p> <p>Alternativamente, retomando a abstra\u00e7\u00e3o de que \u00e9 um \"cubo\" pode ser considerado como um \"objeto\", a solu\u00e7\u00e3o descrita continua aplic\u00e1vel. Pode-se abstrair um pouco mais, considerando que o \"objeto\" a ser pesado \u00e9, na verdade, um conjunto de cubos. \u00c9 f\u00e1cil adaptar a solu\u00e7\u00e3o para identificar qual o conjunto mais pesado, basta posicionar a metade dos cubos em cada prato. Embora isso n\u00e3o forne\u00e7a ainda qual o cubo mais pesado, permite identificar em qual dos pratos ele est\u00e1 e, portanto, que se descarte o outro conjunto (onde ele n\u00e3o est\u00e1). Ent\u00e3o, tem-se um novo conjunto de cubos que pode ser separado em duas partes iguais para compara\u00e7\u00e3o na balan\u00e7a e subsequente descarte da parte mais leve. Esse processo \u00e9 repetido at\u00e9 que torne poss\u00edvel identificar inequivocadamente o cubo mais pesado. No caso de 1000 cubos, seriam necess\u00e1rias, no m\u00e1ximo, 10 compara\u00e7\u00f5es na balan\u00e7a!</p> Considere uma quantidade \u00edmpar de cubos aparentemente id\u00eanticos, sendo um deles um pouco mais leve que os demais. Como encontrar o cubo mais leve usando uma balan\u00e7a de dois pratos. <p>Pode-se aproveitar a ideia anterior para separ\u00e1-los em tr\u00eas partes, dois conjuntos com a mesma quantidade de cubos e um cubo a parte. Aos posicionar os conjuntos nos pratos, se n\u00e3o houver desn\u00edvel, o cubo separado \u00e9 o mais pesado do conjunto. Se houver, pode-se descartar os cubos do prato mais pesado e tamb\u00e9m o que foi separado, e repetir o processo com os cubos remanescentes.</p> Nas solu\u00e7\u00f5es anteriores, como \u00e9 poss\u00edvel verificar que o processo \u00e9 correto? <p>H\u00e1 algumas possibilidades. \u00c9 poss\u00edvel que a objeto mais pesado possa ser identificado de outra forma (por exemplo, com uma marca\u00e7\u00e3o invis\u00edvel a olho nu), portanto o processo o cubo indicado sempre for o marcado. Outra forma \u00e9 avaliando se cada passo est\u00e1 correto. No caso da balan\u00e7a de dois pratos, sempre que houver pelo menos um objeto, o prato mais baixo indica o que \u00e9 mais pesado (mesmo que haja dois com o mesmo peso!). Isso tamb\u00e9m \u00e9 verdade se forem dois conjuntos de objetos, um em cada prato, ou seja, cada pesagem corretamente indica o conjunto mais pesado. Se este passo \u00e9 avaliado como correto, diferentes repeti\u00e7\u00f5es dele tamb\u00e9m o ser\u00e3o. Ou seja, ao pesar uma vez e descartar o conjunto mais leve, tem-se novamente o problema de achar o objeto mais pesado em um conjunto menor de objetos - uma vers\u00e3o menor do mesmo problema de antes! O processo de compara\u00e7\u00e3o e descarte, que \u00e9 correto, pode ser repetido at\u00e9 que haja somente dois objetos, situa\u00e7\u00e3o que j\u00e1 foi mostrada que pode ser resolvida corretamente.</p> <ol> <li> <p>Thomas H. Cormen. Algorithms Unlocked. The MIT Press, 2013. ISBN 9780262518802. URL: https://mitpress.mit.edu/9780262518802/algorithms-unlocked/.\u00a0\u21a9\u21a9</p> </li> <li> <p>Alfred V. Aho. Ubiquity symposium: computation and computational thinking. Ubiquity, jan 2011. URL: https://doi.org/10.1145/1922681.1922682, doi:10.1145/1922681.1922682.\u00a0\u21a9</p> </li> <li> <p>Jeannette M Wing. Computational thinking benefits society. 2014. URL: http://socialissues.cs.toronto.edu/index.html%3Fp=279.html.\u00a0\u21a9</p> </li> <li> <p>International Society for Technology in Education. Iste standards. 2018. URL: https://www.iste.org/standards.\u00a0\u21a9</p> </li> <li> <p>The Chartered Institute for IT. Call for evidence - UK Digital Skills Taskforce. 2014.\u00a0\u21a9</p> </li> <li> <p>Computational Thinking Concepts Guide. URL: https://docs.google.com/document/d/1Hyb2WKJrjT7TeZ2ATq6gsBhkQjSZwTH-xfpVMFEn2F8/edit?pli=1.\u00a0\u21a9</p> </li> <li> <p>Erin Burgoon, Marlone Henderson, and Arthur Markman. There are many ways to see the forest for the trees a tour guide for abstraction. Perspectives on Psychological Science, 8:501\u2013520, 09 2013. doi:10.1177/1745691613497964.\u00a0\u21a9</p> </li> <li> <p>Fatih Kursat Cansu and Sibel Kilicarslan Cansu. An overview of computational thinking. International Journal of Computer Science Education in Schools, 3(1):17\u201330, Apr. 2019. URL: https://www.ijcses.org/index.php/ijcses/article/view/53, doi:10.21585/ijcses.v3i1.53.\u00a0\u21a9\u21a9</p> </li> <li> <p>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms. The MIT Press, 2009. ISBN 0-262-03384-4.\u00a0\u21a9</p> </li> <li> <p>Rajat Jain, Tania Joseph, Anvita Saxena, Deepak Gupta, Ashish Khanna, Kalpna Sagar, and Anil K. Ahlawat. Feature selection algorithm for usability engineering: a nature inspired approach. Complex &amp; Intelligent Systems, 9(4):3487\u20133497, 2023. doi:10.1007/s40747-021-00384-z.\u00a0\u21a9</p> </li> <li> <p>Al Sweigart. Automate the Boring Stuff with Python. William Pollock, 2020. ISBN 978-1-59327-992-9. URL: https://automatetheboringstuff.com/.\u00a0\u21a9</p> </li> <li> <p>Timothy Colburn and Gary Shute. Abstraction in computer science. Minds and Machines, 17:169\u2013184, 2007. URL: https://www.d.umn.edu/~tcolburn/papers/Abstraction.pdf.\u00a0\u21a9</p> </li> </ol>"},{"location":"programacao/","title":"Programa\u00e7\u00e3o","text":"<p>Larry O\u2019Brien &amp; Bruce Eckel</p> <p>Programa\u00e7\u00e3o de computadores \u00e9 muito divertida. Como m\u00fasica, \u00e9 uma habilidade originada em um talento desconhecido e pr\u00e1tica constante.</p> <p>Como o programa resultante determina o comportamento obtido, pode-se considerar a programa\u00e7\u00e3o como a a\u00e7\u00e3o de instruir um computador sobre como realizar algum tipo de opera\u00e7\u00e3o - \u00e9 uma forma de se comunicar com a m\u00e1quina.</p> <p>Um computador \u00e9 utilizado na resolu\u00e7\u00e3o de problemas, e geralmente um \"usu\u00e1rio\" fornece informa\u00e7\u00f5es para isso enquanto um \"programador\" define novas opera\u00e7\u00f5es (e tipos de dados)1 que resultam em novas solu\u00e7\u00f5es. O papel do programador \u00e9 usar e orquestrar cada recurso (componentes do computador) para resolver um problema e analisar os dados que obtiver desta solu\u00e7\u00e3o2.</p> <p>Programa\u00e7\u00e3o</p> <p>Programa\u00e7\u00e3o \u00e9 o processo de expressar um algoritmo como instru\u00e7\u00f5es em uma linguagem de programa\u00e7\u00e3o.</p>"},{"location":"programacao/#linguagem-de-programacao","title":"Linguagem de Programa\u00e7\u00e3o","text":"<p>A linguagem de programa\u00e7\u00e3o \u00e9 um conjunto de termos (vocabul\u00e1rio) e regras (sintaxe) que permite a formula\u00e7\u00e3o de instru\u00e7\u00f5es para um computador, viabilizando a express\u00e3o de um algoritmo de tal modo que possa ser executado pela m\u00e1quina. O vocabul\u00e1rio determina o conjunto de termos que t\u00eam significado especificado na linguagem e que deve ser usado na composi\u00e7\u00e3o das instru\u00e7\u00f5es. A sintaxe determina como usar o vocabul\u00e1rio para formar instru\u00e7\u00f5es (gramaticalmente) corretas na linguagem. O significado computacional de uma instru\u00e7\u00e3o v\u00e1lida \u00e9 a sem\u00e2ntica.</p> <p>Esses conceitos existem tamb\u00e9m na l\u00edngua portuguesa. Pode-se construir uma frase com vocabul\u00e1rio inexistente como \"Mxyzptlk zxcvbnm\", ou uma com termos conhecidos mas sint\u00e1tica e semanticamente incorreta como \"p\u00e3o ela navegou\"; sintaticamente correta mas semanticamente incorreta como \"ela navegou p\u00e3o\" e tamb\u00e9m a frase correta \"ela comeu p\u00e3o\".</p> <p>Program state Similarly, a computer program stores data in variables, which represent storage locations in the computer's memory. The contents of these memory locations, at any given point in the program's execution, is called the program's state.[5][6][7]</p> <p>Syntax is the grammar. It describes the way to construct a correct sentence. For example, this water is triangular is syntactically correct.</p> <p>Semantics relates to the meaning. this water is triangular does not mean anything, though the grammar is ok.</p> <p>mming (from Latin imperare = command) is the oldest programming paradigm. A program based on this paradigm is made up of a clearly-defined sequence of instructions to a computer.</p> <p>Therefore, the source code for imperative languages is a series of commands, which specify what the computer has to do \u2013 and when \u2013 in order to achieve a desired result. Values used in variables are changed at program runtime. To control the commands, control structures such as loops or branches are integrated into the code. The focus is on the \u201chow\u201d of the solution path. For example, this approach can be found in Java, Pascal, and C. By contrast, in declarative programming the \u201cwhat\u201d of the solution is described directly.</p> <p>29 406</p> <p>Em uma computa\u00e7\u00e3o, o estado \u00e9 o conjunto de valores sobre o qual se est\u00e1 realizando a opera\u00e7\u00e3o3</p> <p>Incremental change of the program state as a function of time. Execution of computational steps in an order governed by control structures We call the steps for commands Straightforward abstractions of the way a traditional Von Neumann computer works Similar to descriptions of everyday routines, such as food recipes and car repair Typical commands offered by imperative languages Assignment, IO, procedure calls Language representatives Fortran, Algol, Pascal, Basic, C The natural abstraction is the procedure Abstracts one or more actions to a procedure, which can be called as a single command. \"Procedural programming\" We use several names for the computational steps in an imperative language. The word statement is often used with the special computer science meaning 'a elementary instruction in a source language'. The word instruction is another possibility; We prefer to devote this word the computational steps performed at the machine level. We will use the word 'command' for the imperatives in a high level imperative programming language.</p> <p>A procedure abstracts one or more actions to a procedure, which can be activated as a single action.</p> <p>In broad strokes, programming languages are classified by programming paradigm and intended domain of use, with general-purpose programming languages distinguished from domain-specific programming languages</p> <p>Programming paradigms are a way to classify programming languages based on their features. Languages can be classified into multiple paradigms.</p> <p>Some paradigms are concerned mainly with implications for the execution model of the language, such as allowing side effects, or whether the sequence of operations is defined by the execution model. Other paradigms are concerned mainly with the way that code is organized, such as grouping a code into units along with the state that is modified by the code. Yet others are concerned mainly with the style of syntax and grammar.</p> <p>Some common programming paradigms are</p> <p>imperative in which the programmer instructs the machine how to change its state, procedural which groups instructions into procedures, object-oriented which groups instructions with the part of the state they operate on, declarative in which the programmer merely declares properties of the desired result, but not how to compute it functional in which the desired result is declared as the value of a series of function applications, logic in which the desired result is declared as the answer to a question about a system of facts and rules, reactive in whi</p> <p>Traditionally, programming languages have been regarded as describing computation in terms of imperative sentences, i.e. issuing commands. These are generally called imperative programming languages. A great deal of research in programming languages has been aimed at blurring the distinction between a program as a set of instructions and a program as an assertion about the desired answer, which is the main feature of declarative programming.[73] More refined paradigms include procedural programming, object-oriented programming, functional programming, and logic programming; some languages are hybrids of paradigms or multi-paradigmatic. An assembly language is not so much a paradigm as a direct model of an underlying machine architecture. By purpose, programming languages might be considered general purpose, system programming languages, scripting languages, domain-specific languages, or c</p> <p>As linguagens de programa\u00e7\u00e3o seguem certos paradigmas de programa\u00e7\u00e3o</p> <p>{! markdown/programacao/linguagem.md !}</p> <ol> <li> <p>Peter Norvig. Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1st edition, 1992. ISBN 1558601910. URL: https://github.com/norvig/paip-lisp.\u00a0\u21a9</p> </li> <li> <p>Charles Russell Severance, Sue Blumenberg, and Elliott Hauser. Python for Everybody: Exploring Data in Python 3. CreateSpace Independent Publishing Platform, USA, 2016. ISBN 1530051126, 9781530051120.\u00a0\u21a9</p> </li> <li> <p>P.A. Laplante. Dictionary of Computer Science, Engineering and Technology. CRC Press, 2017. ISBN 9781482274578. URL: https://books.google.com.br/books?id=BjsPEAAAQBAJ.\u00a0\u21a9</p> </li> </ol>"},{"location":"algoritmos/codigo/","title":"Codigo","text":""},{"location":"algoritmos/codigo/#codigo","title":"C\u00f3digo","text":"<p>A representa\u00e7\u00e3o mais interessante de um algoritmo, pois pode ser diretamente aplicada a um computador. O algoritmo \u00e9 descrito como um programa de computador, ou seja, utilizando o vocabul\u00e1rio controlado e as regras de sintaxe de uma linguagem de programa\u00e7\u00e3o espec\u00edfica para definir cada passo. Neste caso, as instru\u00e7\u00f5es devem ser escritas cautelosamente de acordo com a linguagem, no n\u00edvel de complexidade determinado pelo projeto desta. Abaixo mostramos poss\u00edveis formas de apresentar a m\u00e9dia aritm\u00e9tica de quatro n\u00fameros.</p> PythonCRust M\u00e9dia Aritm\u00e9tica<pre><code>notas = map(float, input().split())\nprint(f'A m\u00e9dia \u00e9 {sum(notas) / len(notas)}')\n</code></pre> M\u00e9dia Aritm\u00e9tica<pre><code>#include &lt;stdio.h&gt;\nint main(void) {\nfloat nota_1, nota_2, nota_3, nota_4;\nscanf(\"%f%f%f%f\", &amp;nota_1, &amp;nota_2, &amp;nota_3, &amp;nota_4);\nprintf(\"A m\u00e9dia \u00e9 %f\\n\", (nota_1 + nota_2 + nota_3 + nota_4) / 4);\nreturn 0;\n}\n</code></pre> M\u00e9dia Aritm\u00e9tica<pre><code>fn main() {\nuse std::io;\nlet mut entrada = String::new();\nio::stdin().read_line(&amp;mut entrada).expect(\"Erro ao ler a entrada\");\nlet notas: Vec&lt;f32&gt; = entrada.split_whitespace()\n.map(|x| x.parse().expect(\"Entrada n\u00e3o \u00e9 um n\u00famero!\"))\n.collect();\nlet media = notas.iter().sum::&lt;f32&gt;() / notas.len() as f32;\nprintln!(\"A m\u00e9dia \u00e9  {:?}\", media);\n}\n</code></pre>"},{"location":"algoritmos/exercicios/","title":"Exercicios","text":"Exerc\u00edcios Fa\u00e7a um algoritmo em descri\u00e7\u00e3o narrativa para trocar uma l\u00e2mpada queimada de um abajur j\u00e1 tendo outra l\u00e2mpada nova dispon\u00edvel. <p>Trocar L\u00e2mpada<pre><code>    Desligue o abajur da tomada e retire a l\u00e2mpada queimada desenroscando-a em sentido anti-hor\u00e1rio (separe para descartar no local apropriado). Pegue a l\u00e2mpada nova e a coloque no abajur, rosqueando-a no sentido hor\u00e1rio. Ligue o abajur na tomada.\n</code></pre></p> Represente o algoritmo para c\u00e1lculo da m\u00e9dia aritm\u00e9tica de quatro n\u00fameros usando fluxograma. <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; L4[/Leia 4 notas/] --&gt; M[\"\u00b5 = notas \u00f7 4\"] --&gt; A[Apresente \u00b5] --&gt; T([Fim])</code></pre> Monte um fluxograma para um algoritmo que leia os tr\u00eas coeficientes de uma equa\u00e7\u00e3o de segundo grau e diga se as ra\u00edzes s\u00e3o reais ou complexas, e se s\u00e3o iguais. \\(ax^2+bx+c = 0 \\Rightarrow r = \\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\\) <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; L4[/Leia 4 notas/] --&gt; D[\"\u0394 = b\u00b2 - 4ac\"] --&gt; M0{\"\u0394 &lt; 0?\"} --&gt;|Sim| RC[/Ra\u00edzes complexas/] --&gt; F([Fim])\n    M0 --&gt; |N\u00e3o| RR[/Ra\u00edzes reais/] --&gt; D0{\"\u0394 = 0?\"} --&gt;|Sim| VR[/Ra\u00edzes iguais/] --&gt; F\n    D0 --&gt;|N\u00e3o| F</code></pre> Descreva, em pseudoc\u00f3digo, um algoritmo para ler dois n\u00fameros e apresentar o resultado da divis\u00e3o do primeiro pelo segundo. Divis\u00e3o<pre><code>In\u00edcio\n    Escreva \"Digite o numerador: \"\n    Leia [numerador].\n    Escreva \"Digite o denominador: \"\n    Leia o [denominador].\n    divis\u00e3o = numerador \u00f7 denominador\n    Escreva \"O resultado \u00e9 [divis\u00e3o].\"\nFim\n</code></pre> Descreva, em pseudoc\u00f3digo, o algoritmo para ler a idade de uma pessoa (em anos, meses e dias), e escrever a quantidade de horas vividas por ela. Assuma que todo ano tem 365 dias e todo m\u00eas tem 30 dias. Dias vividos<pre><code>In\u00edcio\n    Escreva \"Digite quantos anos voc\u00ea tem: \"\n    Leia [anos].\n    Escreva \"Digite quantos meses voc\u00ea tem: \"\n    Leia [meses].\n    Escreva \"Digite quantos dias voc\u00ea tem: \"\n    Leia [dias].\n    total = ((anos * 365) + (meses * 30) + dias) * 24\n    Escreva \"Voc\u00ea j\u00e1 viveu [total] horas.\"\nFim\n</code></pre>"},{"location":"algoritmos/fluxograma/","title":"Fluxograma","text":""},{"location":"algoritmos/fluxograma/#fluxograma","title":"Fluxograma","text":"<p>Outro jeito bastante intuitivo com o uso de figuras geom\u00e9tricas, como pode ser vista nos diagramas abaixo.</p> <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; EF{Entende&lt;br&gt;fluxogramas?}\n    EF --&gt;|Sim| O[/\u00d3timo!/] --&gt; F([Fim])\n    EF --&gt;|N\u00e3o| VLS{V\u00ea a linha&lt;br&gt;com 'Sim'?}\n    VLS --&gt;|Sim| VLN{E a com&lt;br&gt;'N\u00e3o'?} --&gt;|Sim| O\n    VLS --&gt;|N\u00e3o| ES[\u00c9 a outra&lt;br&gt;linha...]  --&gt; VLS\n    VLN --&gt;|N\u00e3o| MJ[/Mas j\u00e1&lt;br&gt;seguiu v\u00e1rias?!/] --&gt; SS[Siga a seta.] --&gt; VLS</code></pre> <p>Cada forma geom\u00e9trica tem um significado especifico mas, para facilitar, usaremos apenas as a seguir:</p> <ul> <li>Terminal: que indica onde o algoritmo inicia e onde termina.</li> <li>Dado(s): que indica a comunica\u00e7\u00e3o (entrada/sa\u00edda) de dado(s) com o algoritmo.</li> <li>Processo: que indica a execu\u00e7\u00e3o de uma instru\u00e7\u00e3o/tarefa.</li> <li>Decis\u00e3o: que indica a necessidade de se escolher uma (e apenas uma!) das diversas poss\u00edveis a\u00e7\u00f5es subsequentes.</li> <li>Seta: que indica a sequ\u00eancia em que as instru\u00e7\u00f5es ser\u00e3o executadas.</li> </ul> <pre><code>flowchart TD\n    I([Terminal]) --&gt;|seta| P[Processo] &amp; D{Decis\u00e3o} &amp; IO[/Entrada&lt;br&gt;Sa\u00edda/]</code></pre> <p>Geralmente se usa instru\u00e7\u00f5es mais diretas e simples que na descri\u00e7\u00e3o narrativa, tamb\u00e9m em fun\u00e7\u00e3o da limita\u00e7\u00e3o das figuras utilizadas. Isso tem dois efeitos muito interessantes: o uso de fluxograma restringe muito a amplitude do entendimento das instru\u00e7\u00f5es, facilitando a constru\u00e7\u00e3o de instru\u00e7\u00f5es bem definidas para o algoritmo; mas tamb\u00e9m restringe o tipo de instru\u00e7\u00f5es utiliz\u00e1veis, dificultando a constru\u00e7\u00e3o do processo desejado - podem ser necess\u00e1rias mais instru\u00e7\u00f5es para descrever adequadamente um peda\u00e7o mais complexo do comportamento.</p>"},{"location":"algoritmos/narrativa/","title":"Narrativa","text":""},{"location":"algoritmos/narrativa/#descricao-narrativa","title":"Descri\u00e7\u00e3o Narrativa","text":"<p>A forma mais intuitiva de apresentar uma sequ\u00eancia de instru\u00e7\u00f5es, pois usa linguagem natural para faz\u00ea-lo, como no algoritmos de m\u00e9dia aritm\u00e9tica. Apesar de parecer simples por ser a forma que estamos acostumados a usar para comunica\u00e7\u00e3o, \u00e9 extremamente complexa pois considera a enorme capacidade humana de inferir coisas a partir de informa\u00e7\u00e3o incompleta.</p> <p>Essa \"facilidade\" inerente tem um contraponto: as instru\u00e7\u00f5es que usamos n\u00e3o s\u00e3o muito bem definidas e, portanto, o resultado obtido pode ser diferente do esperado dependendo de quem as interpreta. Por exemplo, considere o seguinte algoritmo:</p> Receita de Bolo<pre><code>Bata as claras em neve. Reserve. Bata bem as gemas com a margarina e o a\u00e7\u00facar. Acrescente o leite e farinha aos poucos sem parar de bater. Por \u00faltimo agregue as claras em neve e o fermento. Coloque em forma grande de furo central untada e enfarinhada. Asse em forno m\u00e9dio, pr\u00e9-aquecido, por aproximadamente 40 min. Quando espetar um palito e sair limpo estar\u00e1 assado.\n</code></pre> <p>Para algu\u00e9m que n\u00e3o esteja acostumado a atividades na cozinha, o algoritmo \u00e9 amb\u00edguo e impreciso. Como bater as claras? Por quanto tempo? Reservar o que? Onde? O que \u00e9 \"bater bem\"? Acrescentar o leite a que? Bater o que sem parar? Se n\u00e3o parar como posso fazer as outras coisas? Colocar o que na forma? O que \u00e9 \"enfarinhada\"? Assar a quantos graus? \"Aproximadamente\" s\u00e3o quantos minutos? Espetar o palito onde? O que \u00e9 \"limpo\"? O palito estar\u00e1 assado?</p> <p>Uma descri\u00e7\u00e3o narrativa detalhada o suficiente para evitar qualquer falha na interpreta\u00e7\u00e3o tende a ser bem mais extensa (e menos natural) do que estamos acostumados a utilizar em nossas conversas do dia a dia.</p>"},{"location":"algoritmos/pseudocodigo/","title":"Pseudocodigo","text":""},{"location":"algoritmos/pseudocodigo/#pseudocodigo","title":"Pseudoc\u00f3digo","text":"<p>Outra abordagem bem interessante, pois visa diminuir o esfor\u00e7o de traduzir um algoritmo computacional em instru\u00e7\u00f5es que um computador possa usar. Utiliza termos simples e estruturas de uma linguagem de programa\u00e7\u00e3o, mas com sintaxe e regras menos restritivas. Por exemplo, o algoritmo abaixo em pseudoc\u00f3digo.</p> M\u00e9dia Aritm\u00e9tica<pre><code>In\u00edcio\n    Leia [nota_1]\n    Leia [nota_2]\n    Leia [nota_3]\n    Leia [nota_4]\n    m\u00e9dia  = (nota_1 + nota_2 + nota_3 + nota_4) \u00f7 4\n    Escreva o valor da [m\u00e9dia]\nFim\n</code></pre> <p>Note que o algoritmo da m\u00e9dia em pseudoc\u00f3digo come\u00e7a e termina com duas palavras, <code>In\u00edcio</code> e <code>Fim</code>. Estas, como as palavras <code>Leia</code> e <code>Escreva</code>, pertencem ao que chamamos de vocabul\u00e1rio controlado. O uso deste um conjunto mais restrito de palavras possibilita maior precis\u00e3o e efic\u00e1cia na comunica\u00e7\u00e3o das instru\u00e7\u00f5es.</p> <p>Outro diferencial \u00e9 a considera\u00e7\u00e3o de nomear as informa\u00e7\u00f5es, de modo a poder recuper\u00e1-las em passos subsequentes. Por exemplo, a segunda instru\u00e7\u00e3o obt\u00e9m um valor (comunica\u00e7\u00e3o de um dado) e lhe atribui um nome (<code>nota_1</code>); que \u00e9 recuperado no momento de calcular a soma dos n\u00fameros, na sexta instru\u00e7\u00e3o.</p> <p>Por fim, note tamb\u00e9m que as linhas com as instru\u00e7\u00f5es de cada passo do algoritmo est\u00e3o deslocadas para a direita em rela\u00e7\u00e3o \u00e0s palavras destacadas, ressaltando o conjunto de instru\u00e7\u00f5es dentro do bloco definido por elas. Este deslocamento \u00e9 denominado endenta\u00e7\u00e3o, e facilita a visualiza\u00e7\u00e3o da estrutura do algoritmo.</p> <p>Este detalhamento das instru\u00e7\u00f5es implica que o algoritmo com m\u00e9dia em pseudoc\u00f3digo ficou mais extenso e menos \"natural\" que o mesmo processo descrito no da m\u00e9dia detalhada, mas \u00e9 bem melhor definido e continua sendo de f\u00e1cil entendimento. Al\u00e9m disso, se aproxima mais da forma de representar um algoritmo como uma linguagem de programa\u00e7\u00e3o.</p>"},{"location":"estruturas_de_dados/fila/","title":"Fila","text":"<p>Uma fila \u00e9 um TAD que, como a lista, tem o objetivo de organizar um conjunto de dados para facilitar sua manipula\u00e7\u00e3o. O diferencial \u00e9 claro na inser\u00e7\u00e3o e remo\u00e7\u00e3o de elementos, pois definem um comportamento bem espec\u00edfico.</p> <p>Fila</p> <p>Tipo abstrato de dados cujo processo de inser\u00e7\u00e3o e remo\u00e7\u00e3o determina um comportamento FIFO (first in, first out), onde um elemento \u00e9 removido na mesma ordem em que foi inserido.</p> <p>A ideia \u00e9 simples e presente em nosso cotidiano - frequentemente lidamos com filas em supermercados, bancos, etc. O comportamento esperado \u00e9 que os elementos s\u00e3o agrupados a medida que chegam, e removidos na mesma ordem para processamento. Qualquer pessoa que chegue se posiciona ao final da fila, e somente a primeira pessoa da fila pode sair dela. Se Alice, Bob e Charlie chegam ao banco nesta ordem, a primeira a ser atendida ser\u00e1 Alice, seguida de Bob e ent\u00e3o Charlie.</p>"},{"location":"estruturas_de_dados/fila/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>H\u00e1 diversas formas de se implementar uma fila. \u00c9 preciso manter um conjunto de dados e controlar inser\u00e7\u00e3o e remo\u00e7\u00e3o nele. Consideraremos duas formas.</p>"},{"location":"estruturas_de_dados/fila/#fila-como-um-vetor","title":"Fila como um vetor","text":"<p>O uso de um vetor implica em determinar a aloca\u00e7\u00e3o de uma estrutura de tamanho fixo e a implementa\u00e7\u00e3o pode ser feita de algumas maneiras. A mais simples \u00e9 considerar que h\u00e1 um vetor de tamanho \\(n\\) alocado, que o in\u00edcio da fila o elemento na primeira posi\u00e7\u00e3o do vetor (\u00edndice 0) e que o \u00faltimo \u00e9 o f-\u00e9simo elemento (\\(0 \\leq f &lt; n\\)). A inser\u00e7\u00e3o \u00e9 simples, basta por o novo elemento na posi\u00e7\u00e3o \\(f\\) do vetor e incrementar este \u00edndice. A remo\u00e7\u00e3o tamb\u00e9m \u00e9 simples, apesar de custosa: retirar o primeiro elemento, mover todos os elementos subsequentes em uma posi\u00e7\u00e3o e decrementar o \u00edndice do \u00faltimo elemento (garantindo assim que uma pr\u00f3xima remo\u00e7\u00e3o afete o elemento correto).</p> Inser\u00e7\u00e3o \\(O(1)\\)Remo\u00e7\u00e3o \\(O(n)\\) Inser\u00e7\u00e3o<pre><code># A fila tem f elementos (de uma quantidade m\u00e1xima de n).\nif f &lt; n:\nfila[f] = dado\nf += 1\n</code></pre> Remo\u00e7\u00e3o<pre><code>if f &gt; 0:\n# dado = fila[0]\nfor x in range(f):\nfila[f] = fila[f + 1]\nf -= 1\n</code></pre> <p>\u00c9 poss\u00edvel diminuir o esfor\u00e7o necess\u00e1rio para remo\u00e7\u00e3o mantendo um segundo \u00edndice \\(i\\), que indicaria a posi\u00e7\u00e3o do primeiro elemento, e que varia conforme os elementos s\u00e3o removidos. Assim, as posi\u00e7\u00f5es \"inicial\" e \"final\" dos elementos da lista mudam a medida que os elementos s\u00e3o removidos ou acrescentados. Essa implementa\u00e7\u00e3o \u00e9 mais complexa, mas implica que tanto remo\u00e7\u00e3o quanto inser\u00e7\u00e3o s\u00e3o \\(O(1)\\).</p>"},{"location":"estruturas_de_dados/fila/#fila-como-uma-lista","title":"Fila como uma lista","text":"<p>O uso de um vetor implica a aloca\u00e7\u00e3o de uma quantidade fixa de mem\u00f3ria, que pode ser rearranjada posteriormente se necess\u00e1rio. Como este rearranjo tem um custo, \u00e9 desej\u00e1vel ter um vetor \"grande o suficiente\" para evit\u00e1-lo, mas como estimar adequadamente o qu\u00e3o grande \u00e9 suficiente? Alocar um vetor t\u00e3o grande que seja suficiente para a maioria das opera\u00e7\u00f5es tamb\u00e9m n\u00e3o \u00e9 desej\u00e1vel, uma vez que provavelmente implica em uso ineficiente do recurso de mem\u00f3ria. Uma alternativa \u00e9 gerenciar a mem\u00f3ria para consumir apenas a quantidade de mem\u00f3ria necess\u00e1ria, armazenando os elementos em uma lista simplesmente encadeada.</p> <p>Neste contexto, pode-se inserir no in\u00edcio (em \\(O(1)\\)) e remover do final (em \\(O(n)\\)) como com um vetor, ou o contr\u00e1rio, como exemplificado a seguir.</p> Inser\u00e7\u00e3o \\(O(n)\\)Remo\u00e7\u00e3o \\(O(1)\\) Inser\u00e7\u00e3o<pre><code>if fila:\naux = fila\nwhile aux.prox:\naux = aux.prox\naux.prox = Elemento(dado)\nelse:\nfila = Elemento(dado)\n</code></pre> Remo\u00e7\u00e3o<pre><code>if fila:\n# dado = fila.dado\nfila = fila.prox\n</code></pre> <p>Uma das opera\u00e7\u00f5es continua como \\((O(n))\\), pois \u00e9 preciso percorrer a lista para chegar ao final da fila. Esse esfor\u00e7o pode ser minimizado usando uma estrutura de dados mais adequada ao problema, que permita acesso ao \u00faltimo elemento em \\(O(1)\\): a lista duplamente encadeada c\u00edclica.</p> Implementa\u00e7\u00e3o Ing\u00eanuaC\u00f3digo <p>Busca uma implementa\u00e7\u00e3o \"pyth\u00f4nica\", fornecendo os m\u00e9todos str, len e contains.</p> Fila<pre><code>    #     @author: Guilherme N. Ramos (gnramos@unb.br)\n#\n# Implementa\u00e7\u00e3o ing\u00eanua de uma fila usando lista duplamente encadeada c\u00edclica.\nfrom lista_dec import LDEC\nclass Fila:\n\"\"\"Define uma classe com o comportamento FIFO.\"\"\"\ndef __init__(self):\nself.front = LDEC()\ndef vazia(self):  # O(1)\nreturn self.front.vazia()\ndef enqueue(self, dado):  # O(1)\nself.front.insere_final(dado)\ndef dequeue(self):  # O(1)\nreturn self.front.remove_inicio()\n# Viabilizando itera\u00e7\u00e3o pyth\u00f4nica.\ndef __contains__(self, dado):  # O(n)\nreturn dado in self.front\ndef __len__(self):  # O(1)\nreturn len(self.front)\ndef __str__(self):  # O(n)\nreturn '&lt;-'.join(f'[{dado}]' for dado in self.front)\n</code></pre>"},{"location":"estruturas_de_dados/lista/","title":"Lista","text":"<p>Uma lista</p>"},{"location":"pensamento_computacional/abstracao/","title":"Abstracao","text":""},{"location":"pensamento_computacional/abstracao/#abstracao","title":"Abstra\u00e7\u00e3o","text":"<p>Abstrair \u00e9 o processo de identificar um conjunto de caracter\u00edsticas invariantes fundamentais a algo1. \u00c9 reconhecer similaridades entre objetos ou situa\u00e7\u00f5es de um problema e focar apenas nelas, ignorando as especificidades para facilitar a forma como tratar o problema2.</p> <p>Por exemplo, o problema de cultivar uma rosa vermelha. Como buscamos o processo de mant\u00ea-la saud\u00e1vel, podemos assumir que este processo independe da cor e, portanto, abstrair este detalhe para cultivar uma rosa. Se for uma esp\u00e9cie de rosa mais robusta, podemos abstrair novamente e simplificar o problema para o cultivo de uma flor. Dependendo da esp\u00e9cie, talvez possamos dar um passo al\u00e9m e reduzir o problema para \"como cultivar uma planta?\" (dar mais um passo e considerar como manter um ser vivo \u00e9 poss\u00edvel, mas excessivo neste contexto).</p> <p>A abstra\u00e7\u00e3o \u00e9 um processo inerente no contexto de pensamento computacional, pois \u00e9 preciso transformar o problema e sua solu\u00e7\u00e3o em representa\u00e7\u00f5es abstratas em um programa de computador. Por exemplo, podemos ter todos os in\u00fameros detalhes de uma cidade, como distribui\u00e7\u00e3o de casas e lojas, tamanhos de constru\u00e7\u00f5es, cores, popula\u00e7\u00e3o, consumo energ\u00e9tico, formas de movimenta\u00e7\u00e3o, etc. Entretanto, para descobrir a rota da sua posi\u00e7\u00e3o at\u00e9 uma loja, podemos abstrair quase tudo e considerar apenas com uma representa\u00e7\u00e3o de certas localiza\u00e7\u00f5es e dos acesso entre elas.</p> UnB \"Real\" Abstra\u00e7\u00e3o <ol> <li> <p>Erin Burgoon, Marlone Henderson, and Arthur Markman. There are many ways to see the forest for the trees a tour guide for abstraction. Perspectives on Psychological Science, 8:501\u2013520, 09 2013. doi:10.1177/1745691613497964.\u00a0\u21a9</p> </li> <li> <p>Fatih Kursat Cansu and Sibel Kilicarslan Cansu. An overview of computational thinking. International Journal of Computer Science Education in Schools, 3(1):17\u201330, Apr. 2019. URL: https://www.ijcses.org/index.php/ijcses/article/view/53, doi:10.21585/ijcses.v3i1.53.\u00a0\u21a9</p> </li> </ol>"},{"location":"pensamento_computacional/algoritmos/","title":"Algoritmos","text":""},{"location":"pensamento_computacional/algoritmos/#projeto-de-algoritmos","title":"Projeto de Algoritmos","text":"<p>O passo final do pensamento computacional \u00e9 criar uma sequ\u00eancia de instru\u00e7\u00f5es que resolve o problema. O ponto chave \u00e9 guiar o racioc\u00ednio. Para tanto, \u00e9 preciso considerar uma s\u00e9rie de coisas. Qual o objetivo principal? Como abstrair o contexto? Como decomp\u00f4-lo em partes mais acess\u00edveis? Em que ordem estas partes devem ser tratadas?</p> <p>Pensamento Algor\u00edtmico</p> <p>Processo de construir uma sequ\u00eancia de passos ordenados que pode ser seguida para obter uma solu\u00e7\u00e3o para todos os problemas constituintes necess\u00e1rios para resolver o problema original1.</p> <p>A aplica\u00e7\u00e3o do pensamento algor\u00edtmico depende de certas informa\u00e7\u00f5es sobre o problema. Quais as informa\u00e7\u00f5es fornecidas? O que se espera como resultado? O que se deve fazer depende de certas condi\u00e7\u00f5es? H\u00e1 alguma parte que precisa ser repetida?</p> <p>Dica</p> <p>Duas ideias que ajudam este processo s\u00e3o: 1) se perguntar \"E se eu fizesse desse jeito?\" (explorando formas diferentes de resolver o problema); e 2) explicar a sua solu\u00e7\u00e3o a algu\u00e9m (ou a um pato de borracha), ao tentar ensinar uma solu\u00e7\u00e3o voc\u00ea estar\u00e1 efetivamente aprendendo sobre ela.</p> <p>Com um entendimento adequado do problema e seu contexto, pode-se projetar o algoritmo. Mais detalhes sobre isso ser\u00e3o discutidos no pr\u00f3ximo cap\u00edtulo, mas o grande Richard Feynman tem um abordagem praticamente infal\u00edvel para isso:</p> Abordagem Feyman de Resolu\u00e7\u00e3o de Problemas <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; P[/Obtenha as informa\u00e7\u00f5es do problema./] --&gt; E[/Escreva o problema/] --&gt; P2[Pense muito sobre o problema] --&gt; E2[/Escreva a solu\u00e7\u00e3o do problema/] --&gt; F([Fim])</code></pre> <p>\u00c9 claro, alguns problemas n\u00e3o t\u00eam solu\u00e7\u00e3o e outra abordagem seria \"consigo mostrar que ele n\u00e3o pode ser resolvido?\" (e assim determinar a solu\u00e7\u00e3o que \u00e9 \"n\u00e3o \u00e9 poss\u00edvel resolver\"). Independentemente, a parte mais importante do pensamento computacional \u00e9, obviamente, o racioc\u00ednio aplicado no projeto da solu\u00e7\u00e3o.</p> <ol> <li> <p>Fatih Kursat Cansu and Sibel Kilicarslan Cansu. An overview of computational thinking. International Journal of Computer Science Education in Schools, 3(1):17\u201330, Apr. 2019. URL: https://www.ijcses.org/index.php/ijcses/article/view/53, doi:10.21585/ijcses.v3i1.53.\u00a0\u21a9</p> </li> </ol>"},{"location":"pensamento_computacional/automacao/","title":"Automacao","text":""},{"location":"pensamento_computacional/automacao/#automacao","title":"Automa\u00e7\u00e3o","text":"<p>O uso de mecanismos para realiza\u00e7\u00e3o de um processo espec\u00edfico tem uma s\u00e9rie de vantagens. Provavelmente aumenta a efici\u00eancia na produ\u00e7\u00e3o dos resultados e a uniformidade destes, reduz a incid\u00eancia de erros e viabiliza o recurso humano para lidar com outras atividades. Al\u00e9m disso, muitas tarefas cotidianas s\u00e3o repetitivas e poderiam ser realizadas por um computador dadas as instru\u00e7\u00f5es corretas1.</p> <p>Parte importante deste processo \u00e9 o entendimento do que pode ser computado e tamb\u00e9m do que n\u00e3o pode ser. O computador existe como entidade f\u00edsica e opera dentro de certos limites. Portanto, apesar de podermos planejar solu\u00e7\u00f5es matematicamente corretas, \u00e9 poss\u00edvel que estas n\u00e3o possam ser executadas na m\u00e1quina. Por exemplo, h\u00e1 m\u00e9todos para calcular o valor exato de \u03c0, mas o resultado \u00e9 um valor irracional e o processo para calcular o valor exato tamb\u00e9m \u00e9 infinitamente demorado!</p> \\[\\pi = 4\\cdot\\sum\\limits_{n=0}^{\\infty}\\frac{(-1)^n}{2n+1}\\] <p>Al\u00e9m disso, certas opera\u00e7\u00f5es podem demandar que uma quantidade invi\u00e1vel de informa\u00e7\u00f5es seja armazenada, ou que sejam realizados tantos processos que se torna impratic\u00e1vel aguardar o t\u00e9rmino da computa\u00e7\u00e3o (se ocorrer). O processo de formula\u00e7\u00e3o de uma solu\u00e7\u00e3o algor\u00edtmica necessariamente deve considerar essas limita\u00e7\u00f5es de modo a chegar a uma op\u00e7\u00e3o que seja realiz\u00e1vel.</p> <p>Outro aspecto relevante neste processo \u00e9 que, para ser realizada por um computador, a tarefa e deve ser programada de tal modo que os padr\u00f5es de intera\u00e7\u00e3o envolvidos escondam, mas n\u00e3o retirem os detalhes do contexto. Em Ci\u00eancia da Computa\u00e7\u00e3o, essa abstra\u00e7\u00e3o \u00e9 o processo de eliminar especificidades ao ignorar certas caracter\u00edsticas e de esconder informa\u00e7\u00f5es que n\u00e3o sejam necess\u00e1rias2, o que permite que os padr\u00f5es de intera\u00e7\u00f5es entre processos sejam aplic\u00e1veis em diversos contextos.</p> <ol> <li> <p>Al Sweigart. Automate the Boring Stuff with Python. William Pollock, 2020. ISBN 978-1-59327-992-9. URL: https://automatetheboringstuff.com/.\u00a0\u21a9</p> </li> <li> <p>Timothy Colburn and Gary Shute. Abstraction in computer science. Minds and Machines, 17:169\u2013184, 2007. URL: https://www.d.umn.edu/~tcolburn/papers/Abstraction.pdf.\u00a0\u21a9</p> </li> </ol>"},{"location":"pensamento_computacional/avaliacao/","title":"Avaliacao","text":""},{"location":"pensamento_computacional/avaliacao/#avaliacao","title":"Avalia\u00e7\u00e3o","text":"<p>A avalia\u00e7\u00e3o visa garantir que a solu\u00e7\u00e3o algor\u00edtmica \u00e9 adequada, ou seja, que resolve o problema. H\u00e1 diversas propriedades que podem/devem ser verificadas.</p> <ul> <li>Corretude: o algoritmo \u00e9 correto se fornece o resultado correto para toda entrada v\u00e1lida1.</li> <li>Efici\u00eancia: o algoritmo \u00e9 eficiente se consome o m\u00ednimo de recursos poss\u00edveis para fornecer um resultado; geralmente o foco \u00e9 em tempo (o qu\u00e3o r\u00e1pido \u00e9 sua execu\u00e7\u00e3o).</li> <li>Usabilidade: o qu\u00e3o f\u00e1cil \u00e9 para usar, lembrar e aprender o algoritmo2.</li> </ul> <p>A corretude \u00e9 a principal caracter\u00edstica, as demais n\u00e3o t\u00eam import\u00e2ncia se a solu\u00e7\u00e3o que n\u00e3o resolve o problema. Tamb\u00e9m \u00e9 um conceito ardiloso3 pois pode depender do contexto. Por exemplo, um algoritmo que aproxima o valor de \\(\\pi\\) pode ser correto num contexto em que a precis\u00e3o de 2 casas decimais \u00e9 suficiente (por exemplo, apresentando resultados simples \u00e0 pessoas), mas incorreto em outro onde a precis\u00e3o necessariamente deve ser bem maior (como calculando trajet\u00f3rias de naves espaciais). A efici\u00eancia n\u00e3o \u00e9 o foco da parte inicial mas ser\u00e1 discutida no cap\u00edtulo de estruturas de dados, e pode ser uma caracter\u00edstica fundamental da solu\u00e7\u00e3o em certos contexto (como o piloto autom\u00e1tico de uma aeronave). No\u00e7\u00f5es de usabilidade e legibilidade do c\u00f3digo permeiam o texto e ser\u00e3o destacadas quando apropriado.</p> <p>Esta verifica\u00e7\u00e3o \u00e9 um processo complexo, que pode ser feita de diversas formas. A mais simples \u00e9 testar o resultado obtido para situa\u00e7\u00f5es conhecidas, e fazer isso na totalidade das condi\u00e7\u00f5es poss\u00edveis ou numa abrang\u00eancia adequada. Quando isto n\u00e3o \u00e9 poss\u00edvel (talvez por que demore demais), h\u00e1 outras formas, como verificar as situa\u00e7\u00f5es antes (pr\u00e9-condi\u00e7\u00e3o) e depois (p\u00f3s-condi\u00e7\u00e3o) de cada passo no algoritmo, ele ser\u00e1 correto se e somente se ambas forem verdadeiras.</p> <ol> <li> <p>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms. The MIT Press, 2009. ISBN 0-262-03384-4.\u00a0\u21a9</p> </li> <li> <p>Rajat Jain, Tania Joseph, Anvita Saxena, Deepak Gupta, Ashish Khanna, Kalpna Sagar, and Anil K. Ahlawat. Feature selection algorithm for usability engineering: a nature inspired approach. Complex &amp; Intelligent Systems, 9(4):3487\u20133497, 2023. doi:10.1007/s40747-021-00384-z.\u00a0\u21a9</p> </li> <li> <p>Thomas H. Cormen. Algorithms Unlocked. The MIT Press, 2013. ISBN 9780262518802. URL: https://mitpress.mit.edu/9780262518802/algorithms-unlocked/.\u00a0\u21a9</p> </li> </ol>"},{"location":"pensamento_computacional/decomposicao/","title":"Decomposicao","text":""},{"location":"pensamento_computacional/decomposicao/#decomposicao","title":"Decomposi\u00e7\u00e3o","text":"<p>A decomposi\u00e7\u00e3o \u00e9 o processo de separar o problema em partes, ou subproblemas, de modo que cada um deles seja menor e mais simples - portanto mais f\u00e1cil de ser resolvido. Esse processo pode ser repetido at\u00e9 que se tenha um problema simples o suficiente para elaborar uma solu\u00e7\u00e3o. Depois, basta juntar as solu\u00e7\u00f5es de cada subproblema de forma coesa para obter a solu\u00e7\u00e3o do problema original.</p> <p>O primeiro passo para decompor um problema \u00e9 entend\u00ea-lo corretamente de modo a identificar e descrever os processos (e subproblemas) envolvidos na sua resolu\u00e7\u00e3o. Com essa informa\u00e7\u00e3o, \u00e9 poss\u00edvel particionar os processos (e subproblemas) em passos distintos, que ent\u00e3o s\u00e3o organizados de forma estruturada para que possam ser executados.</p> <p>Por exemplo, para calcular a trajet\u00f3ria de um foguete, \u00e9 mais f\u00e1cil decompor o movimento dele nas componentes acelera\u00e7\u00e3o, velocidade e deslocamento e considerar o efeito de cada uma. A decomposi\u00e7\u00e3o continua ao trat\u00e1-las, pois cada uma pode ser decomposta em componentes espec\u00edficos do sistema de coordenadas sendo utilizado. Num sistema cartesiano, a acelera\u00e7\u00e3o \u00e9 tratada como a varia\u00e7\u00e3o da posi\u00e7\u00e3o ao longo do tempo nos eixos, portanto a an\u00e1lise pode ser decomposta para cada eixo \\(x\\), \\(y\\) e \\(z\\).</p> Foguete Componentes do movimento Componentes da acelera\u00e7\u00e3o <p>E o processo pode continuar at\u00e9 que as tarefas seja exequ\u00edveis.</p>"},{"location":"pensamento_computacional/exercicios/","title":"Exercicios","text":"Exerc\u00edcios H\u00e1 dois cubos aparentemente id\u00eanticos, sendo um um pouco mais leve que o outro. Aplique o pensamento computacional para elaborar uma solu\u00e7\u00e3o para o problema de, tendo acesso a uma balan\u00e7a digital, encontrar o mais pesado. <p>O processo pode ser decomposto em duas etapas: an\u00e1lise de um cubo e compara\u00e7\u00e3o dos resultados da an\u00e1lise. A solu\u00e7\u00e3o pode ser descrita em 7 passos: 1) por o primeiro cubo na balan\u00e7a, 2) anotar sua massa, 3) por o segundo cubo na balan\u00e7a, 4) anotar sua massa, 5) comparar os valores anotados, 6) identificar qual o de maior massa e 7) apresenta\u00e7\u00e3o do cubo mais pesado.</p> H\u00e1 dois bolos aparentemente id\u00eanticos, sendo um pouco mais leve que o outro. Aplique o pensamento computacional para elaborar uma solu\u00e7\u00e3o para o problema de, tendo acesso a uma balan\u00e7a de dois pratos (que n\u00e3o indica a massa, mas apenas qual dos pratos est\u00e1 com mais peso), encontrar o bolo mais leve. <p>Este \u00e9 um problema diferente do anterior, mas alguns detalhes podem ser abstra\u00eddos: ao inv\u00e9s de bolos ou cubos, considera-se que h\u00e1 objetos a serem pesados; e em vez de um valor espec\u00edfico para a massa de cada objeto, tem-se um mecanismo que fornece o resultado direto da compara\u00e7\u00e3o entre eles. Novamente o processo pode ser decomposto em duas etapas: disposi\u00e7\u00e3o dos objetos na balan\u00e7a e an\u00e1lise da inclina\u00e7\u00e3o dos pratos. A solu\u00e7\u00e3o pode ser descrita em 2 passos: 1) por cada objeto em um prato na balan\u00e7a e 2) apresentar o objeto que estiver no prato mais alto. Isso poderia ser facilmente adaptado para o problema de achar o objeto mais pesado.</p> Considere 1000 cubos aparentemente id\u00eanticos, sendo um deles um pouco mais pesado que os demais. Aplique o pensamento computacional para elaborar uma solu\u00e7\u00e3o para o problema de encontrar o cubo mais pesado. <p>Uma abordagem \u00e9 aproveitar o comportamento descrito na quest\u00e3o anterior. Ao comparar dois cubos, se os pratos estiverem desalinhados sabe-se que o que estiver no prato mais baixo \u00e9 o desejado. Caso contr\u00e1rio, basta descartar um deles e substitu\u00ed-lo por outro cubo ainda n\u00e3o avaliado. Estes passos s\u00e3o repetidos at\u00e9 que se ache o mais pesado, o que pode levar at\u00e9 999 compara\u00e7\u00f5es na balan\u00e7a.</p> <p>Alternativamente, retomando a abstra\u00e7\u00e3o de que \u00e9 um \"cubo\" pode ser considerado como um \"objeto\", a solu\u00e7\u00e3o descrita continua aplic\u00e1vel. Pode-se abstrair um pouco mais, considerando que o \"objeto\" a ser pesado \u00e9, na verdade, um conjunto de cubos. \u00c9 f\u00e1cil adaptar a solu\u00e7\u00e3o para identificar qual o conjunto mais pesado, basta posicionar a metade dos cubos em cada prato. Embora isso n\u00e3o forne\u00e7a ainda qual o cubo mais pesado, permite identificar em qual dos pratos ele est\u00e1 e, portanto, que se descarte o outro conjunto (onde ele n\u00e3o est\u00e1). Ent\u00e3o, tem-se um novo conjunto de cubos que pode ser separado em duas partes iguais para compara\u00e7\u00e3o na balan\u00e7a e subsequente descarte da parte mais leve. Esse processo \u00e9 repetido at\u00e9 que torne poss\u00edvel identificar inequivocadamente o cubo mais pesado. No caso de 1000 cubos, seriam necess\u00e1rias, no m\u00e1ximo, 10 compara\u00e7\u00f5es na balan\u00e7a!</p> Considere uma quantidade \u00edmpar de cubos aparentemente id\u00eanticos, sendo um deles um pouco mais leve que os demais. Como encontrar o cubo mais leve usando uma balan\u00e7a de dois pratos. <p>Pode-se aproveitar a ideia anterior para separ\u00e1-los em tr\u00eas partes, dois conjuntos com a mesma quantidade de cubos e um cubo a parte. Aos posicionar os conjuntos nos pratos, se n\u00e3o houver desn\u00edvel, o cubo separado \u00e9 o mais pesado do conjunto. Se houver, pode-se descartar os cubos do prato mais pesado e tamb\u00e9m o que foi separado, e repetir o processo com os cubos remanescentes.</p> Nas solu\u00e7\u00f5es anteriores, como \u00e9 poss\u00edvel verificar que o processo \u00e9 correto? <p>H\u00e1 algumas possibilidades. \u00c9 poss\u00edvel que a objeto mais pesado possa ser identificado de outra forma (por exemplo, com uma marca\u00e7\u00e3o invis\u00edvel a olho nu), portanto o processo o cubo indicado sempre for o marcado. Outra forma \u00e9 avaliando se cada passo est\u00e1 correto. No caso da balan\u00e7a de dois pratos, sempre que houver pelo menos um objeto, o prato mais baixo indica o que \u00e9 mais pesado (mesmo que haja dois com o mesmo peso!). Isso tamb\u00e9m \u00e9 verdade se forem dois conjuntos de objetos, um em cada prato, ou seja, cada pesagem corretamente indica o conjunto mais pesado. Se este passo \u00e9 avaliado como correto, diferentes repeti\u00e7\u00f5es dele tamb\u00e9m o ser\u00e3o. Ou seja, ao pesar uma vez e descartar o conjunto mais leve, tem-se novamente o problema de achar o objeto mais pesado em um conjunto menor de objetos - uma vers\u00e3o menor do mesmo problema de antes! O processo de compara\u00e7\u00e3o e descarte, que \u00e9 correto, pode ser repetido at\u00e9 que haja somente dois objetos, situa\u00e7\u00e3o que j\u00e1 foi mostrada que pode ser resolvida corretamente.</p>"},{"location":"pensamento_computacional/generalizacao/","title":"Generalizacao","text":""},{"location":"pensamento_computacional/generalizacao/#generalizacao","title":"Generaliza\u00e7\u00e3o","text":"<p>Generalizar \u00e9 criar modelos, regras, princ\u00edpios ou teorias que se adequem \u00e0 uma classe de problemas partir de padr\u00f5es observados em inst\u00e2ncias espec\u00edficas do problema. A ideia \u00e9 que, partindo de uma solu\u00e7\u00e3o correta, esta seja adaptada de modo que possa ser aplicada em problemas similares.</p> <p>Por exemplo, um tri\u00e2ngulo equil\u00e1tero tem os 3 \u00e2ngulos internos iguais a 60\u00b0 e as 3 linhas com o mesmo comprimento. A partir disso, \u00e9 relativamente simples definir um algoritmo que desenhe um. Da mesma forma, um quadrado tem os 4 \u00e2ngulos internos iguais a 90\u00b0 e as 4 linhas com o mesmo comprimento, e tamb\u00e9m \u00e9 simples desenhar um, basta criar linhas com os \u00e2ngulos adequados. Considerando o pent\u00e1gono regular, \u00e9 poss\u00edvel perceber que as solu\u00e7\u00f5es s\u00e3o muito similares... A solu\u00e7\u00e3o proposta constr\u00f3i o desenho de modo que cada linha continua a partir do fim da linha anterior, usando o \u00e2ngulo externo do pol\u00edgono para a rota\u00e7\u00e3o.</p> Propriedade dos \u00e2ngulos interno/externo Tri\u00e2nguloQuadradoPent\u00e1gono Tri\u00e2ngulo Equil\u00e1tero<pre><code>\u00e2ngulo_interno = 60\u00b0\n\u00e2ngulo_externo = 180\u00b0 - \u00e2ngulo_interno\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\n</code></pre> Quadrado<pre><code>\u00e2ngulo_interno = 90\u00b0\n\u00e2ngulo_externo = 180\u00b0 - \u00e2ngulo_interno\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\n</code></pre> Pent\u00e1gono Regular<pre><code>\u00e2ngulo_interno = 72\u00b0\n\u00e2ngulo_externo = 180\u00b0 - \u00e2ngulo_interno\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em 1\u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\n</code></pre> <p>Nos algoritmos, os \u00e2ngulos e a quantidade de linhas s\u00e3o diferentes, mas tamb\u00e9m \u00e9 poss\u00edvel reconhecer um padr\u00e3o nas instru\u00e7\u00f5es. A propriedade geom\u00e9trica de pol\u00edgonos determina que a soma de todos os \u00e2ngulos externos de um pol\u00edgono \u00e9 360\u00b0, e como os \u00e2ngulos s\u00e3o iguais, \u00e9 poss\u00edvel determinar o \u00e2ngulo para cada forma geom\u00e9trica apenas com a informa\u00e7\u00e3o de quantos lados ela tem. Assim, pode-se rescrever os algoritmos e chegar a uma solu\u00e7\u00e3o gen\u00e9rica que atende qualquer pol\u00edgono regular.</p> Tri\u00e2nguloQuadradoPent\u00e1gonoPol\u00edgonoPython + Turtle Tri\u00e2ngulo Equil\u00e1tero<pre><code>\u00e2ngulo_externo = 360 / 3\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Ret\u00e2ngulo Regular<pre><code>\u00e2ngulo_externo = 360 / 4\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Pent\u00e1gono Regular<pre><code>\u00e2ngulo_externo = 360 / 5\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Pol\u00edgono Regular<pre><code>\u00e2ngulo_externo = 360 / n\u00famero_de_lados\n\nRepita n\u00famero_de_lados vezes:\n    Desenhe uma linha de comprimento L.\n    Gire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Pol\u00edgono Regular<pre><code>angulo_externo = 360 / num_lados\nfor _ in range(num_lados):\nlinha(comprimento)\nesquerda(angulo_externo)\n</code></pre>"},{"location":"programacao/C/","title":"N\u00fameros Inteiros em C","text":"<p>Toda linguagem de programa\u00e7\u00e3o fornece alguns tipos de dados primitivos (ou embutidos) A linguagem C define o tipo de dado <code>int</code> para armazenar n\u00fameros inteiros. As principais opera\u00e7\u00f5es com inteiros s\u00e3o:</p> Opera\u00e7\u00e3o Resultado Exemplo x + y soma de x e y 2 + 3 = 5 x - y diferen\u00e7a de x e y 3 - 2 = -1 x * y produto de x e y 2 * 3 = 6 x / y quociente inteiro da divis\u00e3o de x por y 2 / 3 = 1 x % y resto da divis\u00e3o de x por y 3 % 2 = 1 -x x negado -2 <p>Na mem\u00f3ria, os n\u00fameros s\u00e3o armazenados como complemento de 2 em 32 bits, portanto os valores s\u00e3o limitados ao intervalo \\([-2^{31}, 2^{31}) = [-2147483648, 2147483648)\\). Adicionalmente, C fornece dois modificadores, <code>unsigned</code>, que determina que valor armazenado \u00e9 sempre positivo e usa o bit de sinal para a magnitude (o valor est\u00e1 em \\([0, 2^{32}) = [0, 4294967296)\\)); e <code>long</code> que duplica a quantidade de bits para armazenagem (valor em $[-2^{63}, 2^{63})).</p> Inteiro em C<pre><code>int inteiro_32 = -42;\nunsigned int inteiro_32_sem_sinal = 42;\nlong int inteiro_64 = 9000000000; /* 9 bilh\u00f5es */\n</code></pre>"},{"location":"programacao/estruturas/","title":"Estruturas de Dados","text":"<p>David Jones</p> <p>Acerte as estruturas de dados primeiro, e o resto do programa se escrever\u00e1 sozinho.</p>"},{"location":"programacao/funcoes/","title":"Fun\u00e7\u00f5es","text":"<p>Here\u2019s what you\u2019ll learn in this tutorial:</p> <p>How functions work in Python and why they\u2019re beneficial How to define and call your own Python function Mechanisms for passing arguments to your function How to return data from your function back to the calling environment Free PDF Download: Python 3 Cheat Sheet</p> <p>Functions in Python You may be familiar with the mathematical concept of a function. A function is a relationship or mapping between one or more inputs and a set of outputs. In mathematics, a function is typically represented like this:</p> <p>mathematical function Here, f is a function that operates on the inputs x and y. The output of the function is z. However, programming functions are much more generalized and versatile than this mathematical definition. In fact, appropriate function definition and use is so critical to proper software development that virtually all modern programming languages support both built-in and user-defined functions.</p> <p>In programming, a function is a self-contained block of code that encapsulates a specific task or related group of tasks. In previous tutorials in this series, you\u2019ve been introduced to some of the built-in functions provided by Python. id(), for example, takes one argument and returns that object\u2019s unique integer identifier:</p> <p>s = 'foobar' id(s) 56313440 len() returns the length of the argument passed to it:</p> <p>a = ['foo', 'bar', 'baz', 'qux'] len(a) 4 any() takes an iterable as its argument and returns True if any of the items in the iterable are truthy and False otherwise:</p> <p>any([False, False, False]) False any([False, True, False]) True</p> <p>any(['bar' == 'baz', len('foo') == 4, 'qux' in {'foo', 'bar', 'baz'}]) False any(['bar' == 'baz', len('foo') == 3, 'qux' in {'foo', 'bar', 'baz'}]) True Each of these built-in functions performs a specific task. The code that accomplishes the task is defined somewhere, but you don\u2019t need to know where or even how the code works. All you need to know about is the function\u2019s interface:</p> <p>What arguments (if any) it takes What values (if any) it returns Then you call the function and pass the appropriate arguments. Program execution goes off to the designated body of code and does its useful thing. When the function is finished, execution returns to your code where it left off. The function may or may not return data for your code to use, as the examples above do.</p> <p>When you define your own Python function, it works just the same. From somewhere in your code, you\u2019ll call your Python function and program execution will transfer to the body of code that makes up the function.</p> <p>Note: In this case, you will know where the code is and exactly how it works because you wrote it!</p> <p>When the function is finished, execution returns to the location where the function was called. Depending on how you designed the function\u2019s interface, data may be passed in when the function is called, and return values may be passed back when it finishes.</p> <p>Virtually all programming languages used today support a form of user-defined functions, although they aren\u2019t always called functions. In other languages, you may see them referred to as one of the following:</p> <p>Subroutines Procedures Methods Subprograms So, why bother defining functions? There are several very good reasons. Let\u2019s go over a few now.</p> <p>Abstraction and Reusability Suppose you write some code that does something useful. As you continue development, you find that the task performed by that code is one you need often, in many different locations within your application. What should you do? Well, you could just replicate the code over and over again, using your editor\u2019s copy-and-paste capability.</p> <p>Later on, you\u2019ll probably decide that the code in question needs to be modified. You\u2019ll either find something wrong with it that needs to be fixed, or you\u2019ll want to enhance it in some way. If copies of the code are scattered all over your application, then you\u2019ll need to make the necessary changes in every location.</p> <p>Note: At first blush, that may seem like a reasonable solution, but in the long term, it\u2019s likely to be a maintenance nightmare! While your code editor may help by providing a search-and-replace function, this method is error-prone, and you could easily introduce bugs into your code that will be difficult to find.</p> <p>A better solution is to define a Python function that performs the task. Anywhere in your application that you need to accomplish the task, you simply call the function. Down the line, if you decide to change how it works, then you only need to change the code in one location, which is the place where the function is defined. The changes will automatically be picked up anywhere the function is called.</p> <p>The abstraction of functionality into a function definition is an example of the Don\u2019t Repeat Yourself (DRY) Principle of software development. This is arguably the strongest motivation for using functions.</p> <p>Modularity Functions allow complex processes to be broken up into smaller steps. Imagine, for example, that you have a program that reads in a file, processes the file contents, and then writes an output file. Your code could look like this:</p>"},{"location":"programacao/funcoes/#main-program","title":"Main program","text":""},{"location":"programacao/funcoes/#code-to-read-file-in","title":"Code to read file in","text":"<p>"},{"location":"programacao/funcoes/#code-to-process-file","title":"Code to process file","text":"<p>"},{"location":"programacao/funcoes/#code-to-write-file-out","title":"Code to write file out","text":"<p>  In this example, the main program is a bunch of code strung together in a long sequence, with whitespace and comments to help organize it. However, if the code were to get much lengthier and more complex, then you\u2019d have an increasingly difficult time wrapping your head around it. <p>Alternatively, you could structure the code more like the following:</p> <p>def read_file():     # Code to read file in      <p>def process_file():     # Code to process file      <p>def write_file():     # Code to write file out"},{"location":"programacao/funcoes/#main-program_1","title":"Main program","text":"<p>read_file() process_file() write_file() This example is modularized. Instead of all the code being strung together, it\u2019s broken out into separate functions, each of which focuses on a specific task. Those tasks are read, process, and write. The main program now simply needs to call each of these in turn.</p> <p>Note: The def keyword introduces a new Python function definition. You\u2019ll learn all about this very soon.</p> <p>In life, you do this sort of thing all the time, even if you don\u2019t explicitly think of it that way. If you wanted to move some shelves full of stuff from one side of your garage to the other, then you hopefully wouldn\u2019t just stand there and aimlessly think, \u201cOh, geez. I need to move all that stuff over there! How do I do that???\u201d You\u2019d divide the job into manageable steps:</p> <p>Take all the stuff off the shelves. Take the shelves apart. Carry the shelf parts across the garage to the new location. Re-assemble the shelves. Carry the stuff across the garage. Put the stuff back on the shelves. Breaking a large task into smaller, bite-sized sub-tasks helps make the large task easier to think about and manage. As programs become more complicated, it becomes increasingly beneficial to modularize them in this way.</p> <p>Namespace Separation A namespace is a region of a program in which identifiers have meaning. As you\u2019ll see below, when a Python function is called, a new namespace is created for that function, one that is distinct from all other namespaces that already exist.</p> <p>The practical upshot of this is that variables can be defined and used within a Python function even if they have the same name as variables defined in other functions or in the main program. In these cases, there will be no confusion or interference because they\u2019re kept in separate namespaces.</p> <p>This means that when you write code within a function, you can use variable names and identifiers without worrying about whether they\u2019re already used elsewhere outside the function. This helps minimize errors in code considerably.</p> <p>Note: You\u2019ll learn much more about namespaces later in this series.</p> <p>Hopefully, you\u2019re sufficiently convinced of the virtues of functions and eager to create some! Let\u2019s see how.</p> <p>Function Calls and Definition The usual syntax for defining a Python function is as follows:</p> <p>def ([]):      The components of the definition are explained in the table below: <p>Component   Meaning def The keyword that informs Python that a function is being defined  A valid Python identifier that names the function     An optional, comma-separated list of parameters that may be passed to the function :   Punctuation that denotes the end of the Python function header (the name and parameter list)   A block of valid Python statements The final item, , is called the body of the function. The body is a block of statements that will be executed when the function is called. The body of a Python function is defined by indentation in accordance with the off-side rule. This is the same as code blocks associated with a control structure, like an if or while statement. <p>The syntax for calling a Python function is as follows:</p> <p>([])  are the values passed into the function. They correspond to the  in the Python function definition. You can define a function that doesn\u2019t take any arguments, but the parentheses are still required. Both a function definition and a function call must always include parentheses, even if they\u2019re empty. <p>As usual, you\u2019ll start with a small example and add complexity from there. Keeping the time-honored mathematical tradition in mind, you\u2019ll call your first Python function f(). Here\u2019s a script file, foo.py, that defines and calls f():</p> <p>1def f():  2    s = '-- Inside f()'  3    print(s)  4  5print('Before calling f()')  6f()  7print('After calling f()') Here\u2019s how this code works:</p> <p>Line 1 uses the def keyword to indicate that a function is being defined. Execution of the def statement merely creates the definition of f(). All the following lines that are indented (lines 2 to 3) become part of the body of f() and are stored as its definition, but they aren\u2019t executed yet.</p> <p>Line 4 is a bit of whitespace between the function definition and the first line of the main program. While it isn\u2019t syntactically necessary, it is nice to have. To learn more about whitespace around top-level Python function definitions, check out Writing Beautiful Pythonic Code With PEP 8.</p> <p>Line 5 is the first statement that isn\u2019t indented because it isn\u2019t a part of the definition of f(). It\u2019s the start of the main program. When the main program executes, this statement is executed first.</p> <p>Line 6 is a call to f(). Note that empty parentheses are always required in both a function definition and a function call, even when there are no parameters or arguments. Execution proceeds to f() and the statements in the body of f() are executed.</p> <p>Line 7 is the next line to execute once the body of f() has finished. Execution returns to this print() statement.</p> <p>The sequence of execution (or control flow) for foo.py is shown in the following diagram:</p> <p>When foo.py is run from a Windows command prompt, the result is as follows:</p> <p>C:\\Users\\john\\Documents\\Python\\doc&gt;python foo.py Before calling f() -- Inside f() After calling f() Occasionally, you may want to define an empty function that does nothing. This is referred to as a stub, which is usually a temporary placeholder for a Python function that will be fully implemented at a later time. Just as a block in a control structure can\u2019t be empty, neither can the body of a function. To define a stub function, use the passstatement:</p> <p>def f(): ...     pass ... f() As you can see above, a call to a stub function is syntactically valid but doesn\u2019t do anything.</p> <p>Argument Passing So far in this tutorial, the functions you\u2019ve defined haven\u2019t taken any arguments. That can sometimes be useful, and you\u2019ll occasionally write such functions. More often, though, you\u2019ll want to pass data into a function so that its behavior can vary from one invocation to the next. Let\u2019s see how to do that.</p> <p>Positional Arguments The most straightforward way to pass arguments to a Python function is with positional arguments (also called required arguments). In the function definition, you specify a comma-separated list of parameters inside the parentheses:</p> <p>def f(qty, item, price): ...     print(f'{qty} {item} cost ${price:.2f}') ... When the function is called, you specify a corresponding list of arguments:</p> <p>f(6, 'bananas', 1.74) 6 bananas cost $1.74 The parameters (qty, item, and price) behave like variables that are defined locally to the function. When the function is called, the arguments that are passed (6, 'bananas', and 1.74) are bound to the parameters in order, as though by variable assignment:</p> <p>Parameter       Argument qty \u2190   6 item    \u2190   bananas price   \u2190   1.74 In some programming texts, the parameters given in the function definition are referred to as formal parameters, and the arguments in the function call are referred to as actual parameters:</p> <p>Difference between parameters and arguments Although positional arguments are the most straightforward way to pass data to a function, they also afford the least flexibility. For starters, the order of the arguments in the call must match the order of the parameters in the definition. There\u2019s nothing to stop you from specifying positional arguments out of order, of course:</p> <p>f('bananas', 1.74, 6) bananas 1.74 cost $6.00 The function may even still run, as it did in the example above, but it\u2019s very unlikely to produce the correct results. It\u2019s the responsibility of the programmer who defines the function to document what the appropriate arguments should be, and it\u2019s the responsibility of the user of the function to be aware of that information and abide by it.</p> <p>With positional arguments, the arguments in the call and the parameters in the definition must agree not only in order but in number as well. That\u2019s the reason positional arguments are also referred to as required arguments. You can\u2019t leave any out when calling the function:</p>"},{"location":"programacao/funcoes/#too-few-arguments","title":"Too few arguments","text":"<p>f(6, 'bananas') Traceback (most recent call last):   File \"\", line 1, in      f(6, 'bananas') TypeError: f() missing 1 required positional argument: 'price' Nor can you specify extra ones:"},{"location":"programacao/funcoes/#too-many-arguments","title":"Too many arguments","text":"<p>f(6, 'bananas', 1.74, 'kumquats') Traceback (most recent call last):   File \"\", line 1, in      f(6, 'bananas', 1.74, 'kumquats') TypeError: f() takes 3 positional arguments but 4 were given Positional arguments are conceptually straightforward to use, but they\u2019re not very forgiving. You must specify the same number of arguments in the function call as there are parameters in the definition, and in exactly the same order. In the sections that follow, you\u2019ll see some argument-passing techniques that relax these restrictions. <p>Keyword Arguments When you\u2019re calling a function, you can specify arguments in the form =. In that case, each  must match a parameter in the Python function definition. For example, the previously defined function f() may be called with keyword arguments as follows: <p>f(qty=6, item='bananas', price=1.74) 6 bananas cost $1.74 Referencing a keyword that doesn\u2019t match any of the declared parameters generates an exception:</p> <p>f(qty=6, item='bananas', cost=1.74) Traceback (most recent call last):   File \"\", line 1, in &lt;module&amp;ggt; TypeError: f() got an unexpected keyword argument 'cost' Using keyword arguments lifts the restriction on argument order. Each keyword argument explicitly designates a specific parameter by name, so you can specify them in any order and Python will still know which argument goes with which parameter: <p>f(item='bananas', price=1.74, qty=6) 6 bananas cost $1.74 Like with positional arguments, though, the number of arguments and parameters must still match:</p>"},{"location":"programacao/funcoes/#still-too-few-arguments","title":"Still too few arguments","text":"<p>f(qty=6, item='bananas') Traceback (most recent call last):   File \"\", line 1, in      f(qty=6, item='bananas') TypeError: f() missing 1 required positional argument: 'price' So, keyword arguments allow flexibility in the order that function arguments are specified, but the number of arguments is still rigid. <p>You can call a function using both positional and keyword arguments:</p> <p>f(6, price=1.74, item='bananas') 6 bananas cost $1.74</p> <p>f(6, 'bananas', price=1.74) 6 bananas cost $1.74 When positional and keyword arguments are both present, all the positional arguments must come first:</p> <p>f(6, item='bananas', 1.74) SyntaxError: positional argument follows keyword argument Once you\u2019ve specified a keyword argument, there can\u2019t be any positional arguments to the right of it.</p> <p>Default Parameters If a parameter specified in a Python function definition has the form =, then  becomes a default value for that parameter. Parameters defined this way are referred to as default or optional parameters. An example of a function definition with default parameters is shown below: <p>def f(qty=6, item='bananas', price=1.74): ...     print(f'{qty} {item} cost ${price:.2f}') ... When this version of f() is called, any argument that\u2019s left out assumes its default value:</p> <p>f(4, 'apples', 2.24) 4 apples cost $2.24 f(4, 'apples') 4 apples cost $1.74</p> <p>f(4) 4 bananas cost $1.74 f() 6 bananas cost $1.74</p> <p>f(item='kumquats', qty=9) 9 kumquats cost $1.74 f(price=2.29) 6 bananas cost $2.29 In summary:</p> <p>Positional arguments must agree in order and number with the parameters declared in the function definition. Keyword arguments must agree with declared parameters in number, but they may be specified in arbitrary order. Default parameters allow some arguments to be omitted when the function is called. Mutable Default Parameter Values Things can get weird if you specify a default parameter value that is a mutable object. Consider this Python function definition:</p> <p>def f(my_list=[]): ...     my_list.append('###') ...     return my_list ... f() takes a single list parameter, appends the string '###' to the end of the list, and returns the result:</p> <p>f(['foo', 'bar', 'baz']) ['foo', 'bar', 'baz', '###']</p> <p>f([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5, '###'] The default value for parameter my_list is the empty list, so if f() is called without any arguments, then the return value is a list with the single element '###':</p> <p>f() ['###'] Everything makes sense so far. Now, what would you expect to happen if f() is called without any parameters a second and a third time? Let\u2019s see:</p> <p>f() ['###', '###'] f() ['###', '###', '###'] Oops! You might have expected each subsequent call to also return the singleton list ['###'], just like the first. Instead, the return value keeps growing. What happened?</p> <p>In Python, default parameter values are defined only once when the function is defined (that is, when the def statement is executed). The default value isn\u2019t re-defined each time the function is called. Thus, each time you call f() without a parameter, you\u2019re performing .append() on the same list.</p> <p>You can demonstrate this with id():</p> <p>def f(my_list=[]): ...     print(id(my_list)) ...     my_list.append('###') ...     return my_list ... f() 140095566958408 ['###'] f() 140095566958408 ['###', '###'] f() 140095566958408 ['###', '###', '###'] The object identifier displayed confirms that, when my_list is allowed to default, the value is the same object with each call. Since lists are mutable, each subsequent .append() call causes the list to get longer. This is a common and pretty well-documented pitfall when you\u2019re using a mutable object as a parameter\u2019s default value. It potentially leads to confusing code behavior, and is probably best avoided.</p> <p>As a workaround, consider using a default argument value that signals no argument has been specified. Most any value would work, but None is a common choice. When the sentinel value indicates no argument is given, create a new empty list inside the function:</p> <p>def f(my_list=None): ...     if my_list is None: ...         my_list = [] ...     my_list.append('###') ...     return my_list ...</p> <p>f() ['###'] f() ['###'] f() ['###']</p> <p>f(['foo', 'bar', 'baz']) ['foo', 'bar', 'baz', '###']</p> <p>f([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5, '###'] Note how this ensures that my_list now truly defaults to an empty list whenever f() is called without an argument.</p> <p>Pass-By-Value vs Pass-By-Reference in Pascal In programming language design, there are two common paradigms for passing an argument to a function:</p> <p>Pass-by-value: A copy of the argument is passed to the function. Pass-by-reference: A reference to the argument is passed to the function. Other mechanisms exist, but they are essentially variations on these two. In this section, you\u2019re going to take a short detour from Python and briefly look at Pascal, a programming language that makes a particularly clear distinction between these two.</p> <p>Note: Don\u2019t worry if you aren\u2019t familiar with Pascal! The concepts are similar to those of Python, and the examples shown are accompanied by enough detailed explanation that you should get a general idea. Once you\u2019ve seen how argument passing works in Pascal, we\u2019ll circle back around to Python, and you\u2019ll see how it compares.</p> <p>Here\u2019s what you need to know about Pascal syntax:</p> <p>Procedures: A procedure in Pascal is similar to a Python function. Colon-equals: This operator (:=) is used for assignment in Pascal. It\u2019s analogous to the equals sign (=) in Python. writeln(): This function displays data to the console, similar to Python\u2019s print(). With that bit of groundwork in place, here\u2019s the first Pascal example:</p> <p>1// Pascal Example #1  2  3procedure f(fx : integer);  4begin  5    writeln('Start  f():  fx = ', fx);  6    fx := 10;  7    writeln('End    f():  fx = ', fx);  8end;  9 10// Main program 11var 12    x : integer; 13 14begin 15    x := 5; 16    writeln('Before f():  x = ', x); 17    f(x); 18    writeln('After  f():  x = ', x); 19end. Here\u2019s what\u2019s going on:</p> <p>Line 12: The main program defines an integer variable x. Line 15: It initially assigns x the value 5. Line 17: It then calls procedure f(), passing x as an argument. Line 5: Inside f(), the writeln() statement shows that the corresponding parameter fx is initially 5, the value passed in. Line 6: fx is then assigned the value 10. Line 7: This value is verified by this writeln() statement executed just before f() exits. Line 18: Back in the calling environment of the main program, this writeln() statement shows that after f() returns, x is still 5, as it was prior to the procedure call. Running this code generates the following output:</p> <p>Before f():  x = 5 Start  f():  fx = 5 End    f():  fx = 10 After  f():  x = 5 In this example, x is passed by value, so f() receives only a copy. When the corresponding parameter fx is modified, x is unaffected.</p> <p>Note: If you want to see this in action, then you can run the code for yourself using an online Pascal compiler.</p> <p>Just follow these steps:</p> <p>Copy the code from the code box above. Visit the Online Pascal Compiler. In the code box on the left, replace any existing contents with the code you copied in step 1. Click Execute. You should see the same output as above.</p> <p>Now, compare this with the next example:</p> <p>1// Pascal Example #2  2  3procedure f(var fx : integer);  4begin  5    writeln('Start  f():  fx = ', fx);  6    fx := 10;  7    writeln('End    f():  fx = ', fx);  8end;  9 10// Main program 11var 12    x : integer; 13 14begin 15    x := 5; 16    writeln('Before f():  x = ', x); 17    f(x); 18    writeln('After  f():  x = ', x); 19end. This code is identical to the first example, with one change. It\u2019s the presence of the word var in front of fx in the definition of procedure f() on line 3. That indicates that the argument to f() is passed by reference. Changes made to the corresponding parameter fx will also modify the argument in the calling environment.</p> <p>The output from this code is the same as before, except for the last line:</p> <p>Before f():  x = 5 Start  f():  fx = 5 End    f():  fx = 10 After  f():  x = 10 Again, fx is assigned the value 10 inside f() as before. But this time, when f() returns, x in the main program has also been modified.</p> <p>In many programming languages, that\u2019s essentially the distinction between pass-by-value and pass-by-reference:</p> <p>If a variable is passed by value, then the function has a copy to work on, but it can\u2019t modify the original value in the calling environment. If a variable is passed by reference, then any changes the function makes to the corresponding parameter will affect the value in the calling environment. The reason why comes from what a reference means in these languages. Variable values are stored in memory. In Pascal and similar languages, a reference is essentially the address of that memory location, as demonstrated below:</p> <p>In the diagram on the left, x has memory allocated in the main program\u2019s namespace. When f() is called, x is passed by value, so memory for the corresponding parameter fx is allocated in the namespace of f(), and the value of x is copied there. When f() modifies fx, it\u2019s this local copy that is changed. The value of x in the calling environment remains unaffected.</p> <p>In the diagram on the right, x is passed by reference. The corresponding parameter fx points to the actual address in the main program\u2019s namespace where the value of x is stored. When f() modifies fx, it\u2019s modifying the value in that location, just the same as if the main program were modifying x itself.</p> <p>Pass-By-Value vs Pass-By-Reference in Python Are parameters in Python pass-by-value or pass-by-reference? The answer is they\u2019re neither, exactly. That\u2019s because a reference doesn\u2019t mean quite the same thing in Python as it does in Pascal.</p> <p>Recall that in Python, every piece of data is an object. A reference points to an object, not a specific memory location. That means assignment isn\u2019t interpreted the same way in Python as it is in Pascal. Consider the following pair of statements in Pascal:</p> <p>x := 5 x := 10 These are interpreted this way:</p> <p>The variable x references a specific memory location. The first statement puts the value 5 in that location. The next statement overwrites the 5 and puts 10 there instead. By contrast, in Python, the analogous assignment statements are as follows:</p> <p>x = 5 x = 10 These assignment statements have the following meaning:</p> <p>The first statement causes x to point to an object whose value is 5. The next statement reassigns x as a new reference to a different object whose value is 10. Stated another way, the second assignment rebinds x to a different object with value 10. In Python, when you pass an argument to a function, a similar rebinding occurs. Consider this example:</p> <p>1&gt;&gt;&gt; def f(fx):  2...     fx = 10  3...  4&gt;&gt;&gt; x = 5  5&gt;&gt;&gt; f(x)  6&gt;&gt;&gt; x  75 In the main program, the statement x = 5 on line 4 creates a reference named x bound to an object whose value is 5. f() is then called on line 5, with x as an argument. When f() first starts, a new reference called fx is created, which initially points to the same 5 object as x does:</p> <p>Argument Passing Summary Argument passing in Python can be summarized as follows. Passing an immutable object, like an int, str, tuple, or frozenset, to a Python function acts like pass-by-value. The function can\u2019t modify the object in the calling environment.</p> <p>Passing a mutable object such as a list, dict, or set acts somewhat\u2014but not exactly\u2014like pass-by-reference. The function can\u2019t reassign the object wholesale, but it can change items in place within the object, and these changes will be reflected in the calling environment.</p> <p>Side Effects So, in Python, it\u2019s possible for you to modify an argument from within a function so that the change is reflected in the calling environment. But should you do this? This is an example of what\u2019s referred to in programming lingo as a side effect.</p> <p>More generally, a Python function is said to cause a side effect if it modifies its calling environment in any way. Changing the value of a function argument is just one of the possibilities.</p> <p>Note: You\u2019re probably familiar with side effects from the field of human health, where the term typically refers to an unintended consequence of medication. Often, the consequence is undesirable, like vomiting or sedation. On the other hand, side effects can be used intentionally. For example, some medications cause appetite stimulation, which can be used to an advantage, even if that isn\u2019t the medication\u2019s primary intent.</p> <p>The concept is similar in programming. If a side effect is a well-documented part of the function specification, and the user of the function is expressly aware of when and how the calling environment might be modified, then it can be okay. But a programmer may not always properly document side effects, or they may not even be aware that side effects are occurring.</p> <p>When they\u2019re hidden or unexpected, side effects can lead to program errors that are very difficult to track down. Generally, it\u2019s best to avoid them.</p> <p>The return Statement What\u2019s a Python function to do then? After all, in many cases, if a function doesn\u2019t cause some change in the calling environment, then there isn\u2019t much point in calling it at all. How should a function affect its caller?</p> <p>Well, one possibility is to use function return values. A return statement in a Python function serves two purposes:</p> <p>It immediately terminates the function and passes execution control back to the caller. It provides a mechanism by which the function can pass data back to the caller. Exiting a Function Within a function, a return statement causes immediate exit from the Python function and transfer of execution back to the caller:</p> <p>def f(): ...     print('foo') ...     print('bar') ...     return ...</p> <p>f() foo bar In this example, the return statement is actually superfluous. A function will return to the caller when it falls off the end\u2014that is, after the last statement of the function body is executed. So, this function would behave identically without the return statement.</p> <p>However, return statements don\u2019t need to be at the end of a function. They can appear anywhere in a function body, and even multiple times. Consider this example:</p> <p>1&gt;&gt;&gt; def f(x):  2...     if x &lt; 0:  3...         return  4...     if x &gt; 100:  5...         return  6...     print(x)  7...  8  9&gt;&gt;&gt; f(-3) 10&gt;&gt;&gt; f(105) 11&gt;&gt;&gt; f(64) 1264 The first two calls to f() don\u2019t cause any output, because a return statement is executed and the function exits prematurely, before the print() statement on line 6 is reached.</p> <p>This sort of paradigm can be useful for error checking in a function. You can check several error conditions at the start of the function, with return statements that bail out if there\u2019s a problem:</p> <p>def f():     if error_cond1:         return     if error_cond2:         return     if error_cond3:         return</p> <pre><code>&lt;normal processing&gt;\n</code></pre> <p>If none of the error conditions are encountered, then the function can proceed with its normal processing.</p> <p>Returning Data to the Caller In addition to exiting a function, the return statement is also used to pass data back to the caller. If a return statement inside a Python function is followed by an expression, then in the calling environment, the function call evaluates to the value of that expression:</p> <p>1&gt;&gt;&gt; def f():  2...     return 'foo'  3...  4  5&gt;&gt;&gt; s = f()  6&gt;&gt;&gt; s  7'foo' Here, the value of the expression f() on line 5 is 'foo', which is subsequently assigned to variable s.</p> <p>A function can return any type of object. In Python, that means pretty much anything whatsoever. In the calling environment, the function call can be used syntactically in any way that makes sense for the type of object the function returns.</p> <p>For example, in this code, f() returns a dictionary. In the calling environment then, the expression f() represents a dictionary, and f()['baz'] is a valid key reference into that dictionary:</p> <p>def f(): ...     return dict(foo=1, bar=2, baz=3) ...</p> <p>f() {'foo': 1, 'bar': 2, 'baz': 3} f()['baz'] 3 In the next example, f() returns a string that you can slice like any other string:</p> <p>def f(): ...     return 'foobar' ...</p> <p>f()[2:4] 'ob' Here, f() returns a list that can be indexed or sliced:</p> <p>def f(): ...     return ['foo', 'bar', 'baz', 'qux'] ...</p> <p>f() ['foo', 'bar', 'baz', 'qux'] f()[2] 'baz' f()[::-1] ['qux', 'baz', 'bar', 'foo'] If multiple comma-separated expressions are specified in a return statement, then they\u2019re packed and returned as a tuple:</p> <p>def f(): ...     return 'foo', 'bar', 'baz', 'qux' ...</p> <p>type(f())  t = f() t ('foo', 'bar', 'baz', 'qux') <p>a, b, c, d = f() print(f'a = {a}, b = {b}, c = {c}, d = {d}') a = foo, b = bar, c = baz, d = qux When no return value is given, a Python function returns the special Python value None:</p> <p>def f(): ...     return ...</p> <p>print(f()) None The same thing happens if the function body doesn\u2019t contain a return statement at all and the function falls off the end:</p> <p>def g(): ...     pass ...</p> <p>print(g()) None Recall that None is falsy when evaluated in a Boolean context.</p> <p>Since functions that exit through a bare return statement or fall off the end return None, a call to such a function can be used in a Boolean context:</p> <p>def f(): ...     return ... def g(): ...     pass ...</p> <p>if f() or g(): ...     print('yes') ... else: ...     print('no') ... no Here, calls to both f() and g() are falsy, so f() or g() is as well, and the else clause executes.</p> <p>Revisiting Side Effects Suppose you want to write a function that takes an integer argument and doubles it. That is, you want to pass an integer variable to the function, and when the function returns, the value of the variable in the calling environment should be twice what it was. In Pascal, you could accomplish this using pass-by-reference:</p> <p>1procedure double(var x : integer);  2begin  3    x := x * 2;  4end;  5  6var  7    x : integer;  8  9begin 10    x := 5; 11    writeln('Before procedure call: ', x); 12    double(x); 13    writeln('After procedure call:  ', x); 14end. Executing this code produces the following output, which verifies that double() does indeed modify x in the calling environment:</p> <p>Before procedure call: 5 After procedure call:  10 In Python, this won\u2019t work. As you now know, Python integers are immutable, so a Python function can\u2019t change an integer argument by side effect:</p> <p>def double(x): ...     x *= 2 ...</p> <p>x = 5 double(x) x 5 However, you can use a return value to obtain a similar effect. Simply write double() so that it takes an integer argument, doubles it, and returns the doubled value. Then, the caller is responsible for the assignment that modifies the original value:</p> <p>def double(x): ...     return x * 2 ...</p> <p>x = 5 x = double(x) x 10 This is arguably preferable to modifying by side effect. It\u2019s very clear that x is being modified in the calling environment because the caller is doing so itself. Anyway, it\u2019s the only option, because modification by side effect doesn\u2019t work in this case.</p> <p>Still, even in cases where it\u2019s possible to modify an argument by side effect, using a return value may still be clearer. Suppose you want to double every item in a list. Because lists are mutable, you could define a Python function that modifies the list in place:</p> <p>def double_list(x): ...     i = 0 ...     while i &lt; len(x): ...             x[i] *= 2 ...             i += 1 ...</p> <p>a = [1, 2, 3, 4, 5] double_list(a) a [2, 4, 6, 8, 10] Unlike double() in the previous example, double_list() actually works as intended. If the documentation for the function clearly states that the list argument\u2019s contents are changed, then this may be a reasonable implementation.</p> <p>However, you can also write double_list() to pass the desired list back by return value and allow the caller to make the assignment, similar to how double() was re-written in the previous example:</p> <p>def double_list(x): ...     r = [] ...     for i in x: ...             r.append(i * 2) ...     return r ...</p> <p>a = [1, 2, 3, 4, 5] a = double_list(a) a [2, 4, 6, 8, 10] Either approach works equally well. As is often the case, this is a matter of style, and personal preferences vary. Side effects aren\u2019t necessarily consummate evil, and they have their place, but because virtually anything can be returned from a function, the same thing can usually be accomplished through return values as well.</p> <p>Variable-Length Argument Lists In some cases, when you\u2019re defining a function, you may not know beforehand how many arguments you\u2019ll want it to take. Suppose, for example, that you want to write a Python function that computes the average of several values. You could start with something like this:</p> <p>def avg(a, b, c): ...     return (a + b + c) / 3 ... All is well if you want to average three values:</p> <p>avg(1, 2, 3) 2.0 However, as you\u2019ve already seen, when positional arguments are used, the number of arguments passed must agree with the number of parameters declared. Clearly then, all isn\u2019t well with this implementation of avg() for any number of values other than three:</p> <p>avg(1, 2, 3, 4) Traceback (most recent call last):   File \"\", line 1, in      avg(1, 2, 3, 4) TypeError: avg() takes 3 positional arguments but 4 were given You could try to define avg() with optional parameters: <p>def avg(a, b=0, c=0, d=0, e=0): ...     . ...     . ...     . ... This allows for a variable number of arguments to be specified. The following calls are at least syntactically correct:</p> <p>avg(1) avg(1, 2) avg(1, 2, 3) avg(1, 2, 3, 4) avg(1, 2, 3, 4, 5) But this approach still suffers from a couple of problems. For starters, it still only allows up to five arguments, not an arbitrary number. Worse yet, there\u2019s no way to distinguish between the arguments that were specified and those that were allowed to default. The function has no way to know how many arguments were actually passed, so it doesn\u2019t know what to divide by:</p> <p>def avg(a, b=0, c=0, d=0, e=0): ...     return (a + b + c + d + e) / # Divided by what??? ... Evidently, this won\u2019t do either.</p> <p>You could write avg() to take a single list argument:</p> <p>def avg(a): ...     total = 0 ...     for v in a: ...             total += v ...     return total / len(a) ...</p> <p>avg([1, 2, 3]) 2.0 avg([1, 2, 3, 4, 5]) 3.0 At least this works. It allows an arbitrary number of values and produces a correct result. As an added bonus, it works when the argument is a tuple as well:</p> <p>t = (1, 2, 3, 4, 5) avg(t) 3.0 The drawback is that the added step of having to group the values into a list or tuple is probably not something the user of the function would expect, and it isn\u2019t very elegant. Whenever you find Python code that looks inelegant, there\u2019s probably a better option.</p> <p>In this case, indeed there is! Python provides a way to pass a function a variable number of arguments with argument tuple packing and unpacking using the asterisk (*) operator.</p> <p>Conclusion As applications grow larger, it becomes increasingly important to modularize code by breaking it up into smaller functions of manageable size. You now hopefully have all the tools you need to do this.</p> <p>You\u2019ve learned:</p> <p>How to create a user-defined function in Python Several different ways you can pass arguments to a function How you can return data from a function to its caller How to add documentation to functions with docstrings and annotations Next up in this series are two tutorials that cover searching and pattern matching. You will get an in-depth look at a Python module called re, which contains functionality for searching and matching using a versatile pattern syntax called a regular expression.</p> <p>Getting Started With Python Functions Most programming languages allow you to assign a name to a code block that performs a concrete computation. These named code blocks can be reused quickly because you can use their name to call them from different places in your code.</p> <p>Programmers call these named code blocks subroutines, routines, procedures, or functions depending on the language they use. In some languages, there\u2019s a clear difference between a routine or procedure and a function.</p> <p>Sometimes that difference is so strong that you need to use a specific keyword to define a procedure or subroutine and another keyword to define a function. For example the Visual Basic programming language uses Sub and Function to differentiate between the two.</p> <p>In general, a procedure is a named code block that performs a set of actions without computing a final value or result. On the other hand, a function is a named code block that performs some actions with the purpose of computing a final value or result, which is then sent back to the caller code. Both procedures and functions can act upon a set of input values, commonly known as arguments.</p> <p>In Python, these kinds of named code blocks are known as functions because they always send a value back to the caller. The Python documentation defines a function as follows:</p> <p>A series of statements which returns some value to a caller. It can also be passed zero or more arguments which may be used in the execution of the body. (Source)</p> <p>Even though the official documentation states that a function \u201creturns some value to the caller,\u201d you\u2019ll soon see that functions can return any Python object to the caller code.</p> <p>In general, a function takes arguments (if any), performs some operations, and returns a value (or object). The value that a function returns to the caller is generally known as the function\u2019s return value. All Python functions have a return value, either explicit or implicit. You\u2019ll cover the difference between explicit and implicit return values later in this tutorial.</p> <p>To write a Python function, you need a header that starts with the def keyword, followed by the name of the function, an optional list of comma-separated arguments inside a required pair of parentheses, and a final colon.</p> <p>The second component of a function is its code block, or body. Python defines code blocks using indentation instead of brackets, begin and end keywords, and so on. So, to define a function in Python you can use the following syntax:</p> <p>def function_name(arg1, arg2,..., argN):     # Function's code goes here...     pass When you\u2019re coding a Python function, you need to define a header with the def keyword, the name of the function, and a list of arguments in parentheses. Note that the list of arguments is optional, but the parentheses are syntactically required. Then you need to define the function\u2019s code block, which will begin one level of indentation to the right.</p> <p>In the above example, you use a pass statement. This kind of statement is useful when you need a placeholder statement in your code to make it syntactically correct, but you don\u2019t need to perform any action. pass statements are also known as the null operation because they don\u2019t perform any action.</p> <p>Note: The full syntax to define functions and their arguments is beyond the scope of this tutorial. For an in-depth resource on this topic, check out Defining Your Own Python Function.</p> <p>To use a function, you need to call it. A function call consists of the function\u2019s name followed by the function\u2019s arguments in parentheses:</p> <p>function_name(arg1, arg2, ..., argN) You\u2019ll need to pass arguments to a function call only if the function requires them. The parentheses, on the other hand, are always required in a function call. If you forget them, then you won\u2019t be calling the function but referencing it as a function object.</p> <p>To make your functions return a value, you need to use the Python return statement. That\u2019s what you\u2019ll cover from this point on.</p>"},{"location":"programacao/funcoes/#argumentos-opcionais","title":"Argumentos Opcionais","text":"<p>Defining your own functions is an essential skill for writing clean and effective code. In this tutorial, you\u2019ll explore the techniques you have available for defining Python functions that take optional arguments. When you master Python optional arguments, you\u2019ll be able to define functions that are more powerful and more flexible.</p> <p>In this tutorial, you\u2019ll learn:</p> <p>What the difference is between parameters and arguments How to define functions with optional arguments and default parameter values How to define functions using args and kwargs How to deal with error messages about optional arguments</p> <p>Creating Functions in Python for Reusing Code You can think of a function as a mini-program that runs within another program or within another function. The main program calls the mini-program and sends information that the mini-program will need as it runs. When the function completes all of its actions, it may send some data back to the main program that has called it.</p> <p>The primary purpose of a function is to allow you to reuse the code within it whenever you need it, using different inputs if required.</p> <p>When you use functions, you are extending your Python vocabulary. This lets you express the solution to your problem in a clearer and more succinct way.</p> <p>In Python, by convention, you should name a function using lowercase letters with words separated by an underscore, such as do_something(). These conventions are described in PEP 8, which is Python\u2019s style guide. You\u2019ll need to add parentheses after the function name when you call it. Since functions represent actions, it\u2019s a best practice to start your function names with a verb to make your code more readable.</p> <p>Defining Functions With No Input Parameters In this tutorial, you\u2019ll use the example of a basic program that creates and maintains a shopping list and prints it out when you\u2019re ready to go to the supermarket.</p> <p>Start by creating a shopping list:</p> <p>shopping_list = {     \"Bread\": 1,     \"Milk\": 2,     \"Chocolate\": 1,     \"Butter\": 1,     \"Coffee\": 1, } You\u2019re using a dictionary to store the item name as the key and the quantity you need to buy of each item as the value. You can define a function to display the shopping list:</p>"},{"location":"programacao/funcoes/#optional_paramspy","title":"optional_params.py","text":"<p>shopping_list = {     \"Bread\": 1,     \"Milk\": 2,     \"Chocolate\": 1,     \"Butter\": 1,     \"Coffee\": 1, }</p> <p>def show_list():     for item_name, quantity in shopping_list.items():         print(f\"{quantity}x {item_name}\")</p> <p>show_list() When you run this script, you\u2019ll get a printout of the shopping list:</p> <p>$ python optional_params.py 1x Bread 2x Milk 1x Chocolate 1x Butter 1x Coffee The function you\u2019ve defined has no input parameters as the parentheses in the function signature are empty. The signature is the first line in the function definition:</p> <p>def show_list(): You don\u2019t need any input parameters in this example since the dictionary shopping_list is a global variable. This means that it can be accessed from everywhere in the program, including from within the function definition. This is called the global scope. You can read more about scope in Python Scope &amp; the LEGB Rule: Resolving Names in Your Code.</p> <p>Using global variables in this way is not a good practice. It can lead to several functions making changes to the same data structure, which can lead to bugs that are hard to find. You\u2019ll see how to improve on this later on in this tutorial when you\u2019ll pass the dictionary to the function as an argument.</p> <p>Note: For more information on using global variables in functions, head over to Using and Creating Global Variables in Your Python Functions.</p> <p>In the next section, you\u2019ll define a function that has input parameters.</p> <p>Defining Functions With Required Input Arguments Instead of writing the shopping list directly in the code, you can now initialize an empty dictionary and write a function that allows you to add items to the shopping list:</p>"},{"location":"programacao/funcoes/#optional_paramspy_1","title":"optional_params.py","text":"<p>shopping_list = {}</p>"},{"location":"programacao/funcoes/#_1","title":"...","text":"<p>def add_item(item_name, quantity):     if item_name in shopping_list.keys():         shopping_list[item_name] += quantity     else:         shopping_list[item_name] = quantity</p> <p>add_item(\"Bread\", 1) print(shopping_list) The function iterates through the dictionary\u2019s keys, and if the key exists, the quantity is increased. If the item is not one of the keys, the key is created and a value of 1 is assigned to it. You can run this script to show the printed dictionary:</p> <p>$ python optional_params.py {'Bread': 1} You\u2019ve included two parameters in the function signature:</p> <p>item_name quantity Parameters don\u2019t have any values yet. The parameter names are used in the code within the function definition. When you call the function, you pass arguments within the parentheses, one for each parameter. An argument is a value you pass to the function.</p> <p>The distinction between parameters and arguments can often be overlooked. It\u2019s a subtle but important difference. You may sometimes find parameters referred to as formal parameters and arguments as actual parameters.</p> <p>The arguments you input when calling add_item() are required arguments. If you try to call the function without the arguments, you\u2019ll get an error:</p>"},{"location":"programacao/funcoes/#optional_paramspy_2","title":"optional_params.py","text":"<p>shopping_list = {}</p> <p>def add_item(item_name, quantity):     if item_name in shopping_list.keys():         shopping_list[item_name] += quantity     else:         shopping_list[item_name] = quantity</p> <p>add_item() print(shopping_list) The traceback will give a TypeError stating that the arguments are required:</p> <p>$ python optional_params.py Traceback (most recent call last):   File \"optional_params.py\", line 11, in      add_item() TypeError: add_item() missing 2 required positional arguments: 'item_name' and 'quantity' You\u2019ll look at more error messages related to using the wrong number of arguments, or using them in the wrong order, in a later section of this tutorial. <p>Using Python Optional Arguments With Default Values In this section, you\u2019ll learn how to define a function that takes an optional argument. Functions with optional arguments offer more flexibility in how you can use them. You can call the function with or without the argument, and if there is no argument in the function call, then a default value is used.</p> <p>Default Values Assigned to Input Parameters You can modify the function add_item() so that the parameter quantity has a default value:</p>"},{"location":"programacao/funcoes/#optional_paramspy_3","title":"optional_params.py","text":"<p>shopping_list = {}</p> <p>def add_item(item_name, quantity=1):     if item_name in shopping_list.keys():         shopping_list[item_name] += quantity     else:         shopping_list[item_name] = quantity</p> <p>add_item(\"Bread\") add_item(\"Milk\", 2) print(shopping_list) In the function signature, you\u2019ve added the default value 1 to the parameter quantity. This doesn\u2019t mean that the value of quantity will always be 1. If you pass an argument corresponding to quantity when you call the function, then that argument will be used as the value for the parameter. However, if you don\u2019t pass any argument, then the default value will be used.</p> <p>Parameters with default values can\u2019t be followed by regular parameters. You\u2019ll read more about the order in which you can define parameters later in this tutorial.</p> <p>The function add_item() now has one required parameter and one optional parameter. In the code example above, you call add_item() twice. Your first function call has a single argument, which corresponds to the required parameter item_name. In this case, quantity defaults to 1. Your second function call has two arguments, so the default value isn\u2019t used in this case. You can see the output of this below:</p> <p>$ python optional_params.py {'Bread': 1, 'Milk': 2} You can also pass required and optional arguments into a function as keyword arguments. Keyword arguments can also be referred to as named arguments:</p> <p>add_item(item_name=\"Milk\", quantity=2) You can now revisit the first function you defined in this tutorial and refactor it so that it also accepts a default argument:</p> <p>def show_list(include_quantities=True):     for item_name, quantity in shopping_list.items():         if include_quantities:             print(f\"{quantity}x {item_name}\")         else:             print(item_name) Now when you use show_list(), you can call it with no input arguments or pass a Boolean value as a flag argument. If you don\u2019t pass any arguments when calling the function, then the shopping list is displayed by showing each item\u2019s name and quantity. The function will display the same output if you pass True as an argument when calling the function. However, if you use show_list(False), only the item names are displayed.</p> <p>You should avoid using flags in cases where the value of the flag alters the function\u2019s behavior significantly. A function should only be responsible for one thing. If you want a flag to push the function into an alternative path, you may consider writing a separate function instead.</p> <p>Common Default Argument Values In the examples you worked on above, you used the integer 1 as a default value in one case and the Boolean value True in the other. These are common default values you\u2019ll find in function definitions. However, the data type you should use for default values depends on the function you\u2019re defining and how you want the function to be used.</p> <p>The integers 0 and 1 are common default values to use when a parameter\u2019s value needs to be an integer. This is because 0 and 1 are often useful fallback values to have. In the add_item() function you wrote earlier, setting the quantity for a new item to 1 is the most logical option.</p> <p>However, if you had a habit of buying two of everything you purchase when you go to the supermarket, then setting the default value to 2 may be more appropriate for you.</p> <p>When the input parameter needs to be a string, a common default value to use is the empty string (\"\"). This assigns a value whose data type is string but doesn\u2019t put in any additional characters. You can modify add_item() so that both arguments are optional:</p> <p>def add_item(item_name=\"\", quantity=1):     if item_name in shopping_list.keys():         shopping_list[item_name] += quantity     else:         shopping_list[item_name] = quantity You have modified the function so that both parameters have a default value and therefore the function can be called with no input parameters:</p> <p>add_item() This line of code will add an item to the shopping_list dictionary with an empty string as a key and a value of 1. It\u2019s fairly common to check whether an argument has been passed when the function is called and run some code accordingly. You can change the above function to do this:</p> <p>def add_item(item_name=\"\", quantity=1):     if not item_name:         quantity = 0     if item_name in shopping_list.keys():         shopping_list[item_name] += quantity     else:         shopping_list[item_name] = quantity In this version, if no item is passed to the function, the function sets the quantity to 0. The empty string has a falsy value, which means that bool(\"\") returns False, whereas any other string will have a truthy value. When an if keyword is followed by a truthy or falsy value, the if statement will interpret these as True or False. You can read more about truthy and falsy values in Python Booleans: Use Truth Values in Your Code.</p> <p>Therefore, you can use the variable directly within an if statement to check whether an optional argument was used.</p> <p>Another common value that\u2019s often used as a default value is None. This is Python\u2019s way of representing nothing, although it is actually an object that represents the null value. You\u2019ll see an example of when None is a useful default value to use in the next section.</p> <p>Data Types That Shouldn\u2019t Be Used as Default Arguments You\u2019ve used integers and strings as default values in the examples above, and None is another common default value. These are not the only data types you can use as default values. However, not all data types should be used.</p> <p>In this section, you\u2019ll see why mutable data types should not be used as default values in function definitions. A mutable object is one whose values can be changed, such as a list or a dictionary. You can find out more about mutable and immutable data types in Python\u2019s Mutable vs Immutable Types: What\u2019s the Difference?, Immutability in Python, and Python\u2019s official documentation.</p> <p>You can add the dictionary containing the item names and quantities as an input parameter to the function you defined earlier. You can start by making all arguments required ones:</p> <p>def add_item(item_name, quantity, shopping_list):     if item_name in shopping_list.keys():         shopping_list[item_name] += quantity     else:         shopping_list[item_name] = quantity</p> <pre><code>return shopping_list\n</code></pre> <p>You can now pass shopping_list to the function when you call it. This makes the function more self-contained as it doesn\u2019t rely on a variable called shopping_list to exist in the scope that\u2019s calling the function. This change also makes the function more flexible as you can use it with different input dictionaries.</p> <p>You\u2019ve also added the return statement to return the modified dictionary. This line is technically not required at this stage as dictionaries are a mutable data type and therefore the function will change the state of the dictionary that exists in the main module. However, you\u2019ll need the return statement later when you make this argument optional, so it\u2019s best to include it now.</p> <p>To call the function, you\u2019ll need to assign the data returned by the function to a variable:</p> <p>shopping_list = add_item(\"Coffee\", 2, shopping_list) You can also add a shopping_list parameter to show_list(), the first function you defined in this tutorial. You can now have several shopping lists in your program and use the same functions to add items and display the shopping lists:</p>"},{"location":"programacao/funcoes/#optional_paramspy_4","title":"optional_params.py","text":"<p>hardware_store_list = {} supermarket_list = {}</p> <p>def show_list(shopping_list, include_quantities=True):     print()     for item_name, quantity in shopping_list.items():         if include_quantities:             print(f\"{quantity}x {item_name}\")         else:             print(item_name)</p> <p>def add_item(item_name, quantity, shopping_list):     if item_name in shopping_list.keys():         shopping_list[item_name] += quantity     else:         shopping_list[item_name] = quantity</p> <pre><code>return shopping_list\n</code></pre> <p>hardware_store_list = add_item(\"Nails\", 1, hardware_store_list) hardware_store_list = add_item(\"Screwdriver\", 1, hardware_store_list) hardware_store_list = add_item(\"Glue\", 3, hardware_store_list)</p> <p>supermarket_list = add_item(\"Bread\", 1, supermarket_list) supermarket_list = add_item(\"Milk\", 2, supermarket_list)</p> <p>show_list(hardware_store_list) show_list(supermarket_list) You can see the output of this code below. The list of items to buy from the hardware store is shown first. The second part of the output shows the items needed from the supermarket:</p> <p>$ python optional_params.py</p> <p>1x Nails 1x Screwdriver 3x Glue</p> <p>1x Bread 2x Milk You\u2019ll now add a default value for the parameter shopping_list in add_item() so that if no dictionary is passed to the function, then an empty dictionary is used. The most tempting option is to make the default value an empty dictionary. You\u2019ll see why this is not a good idea soon, but you can try this option for now:</p>"},{"location":"programacao/funcoes/#optional_paramspy_5","title":"optional_params.py","text":"<p>def show_list(shopping_list, include_quantities=True):     print()     for item_name, quantity in shopping_list.items():         if include_quantities:             print(f\"{quantity}x {item_name}\")         else:             print(item_name)</p> <p>def add_item(item_name, quantity, shopping_list={}):     if item_name in shopping_list.keys():         shopping_list[item_name] += quantity     else:         shopping_list[item_name] = quantity</p> <pre><code>return shopping_list\n</code></pre> <p>clothes_shop_list = add_item(\"Shirt\", 3) show_list(clothes_shop_list) When you run this script, you\u2019ll get the output below showing the items needed from the clothes shop, which may give the impression that this code works as intended:</p> <p>$ python optional_params.py</p> <p>3x Shirt However, this code has a serious flaw that can lead to unexpected and wrong results. You can add a new shopping list for items needed from the electronics store by using add_item() with no argument corresponding to shopping_list. This leads to the default value being used, which you\u2019d hope would create a new empty dictionary:</p>"},{"location":"programacao/funcoes/#optional_paramspy_6","title":"optional_params.py","text":"<p>def show_list(shopping_list, include_quantities=True):     print()     for item_name, quantity in shopping_list.items():         if include_quantities:             print(f\"{quantity}x {item_name}\")         else:             print(item_name)</p> <p>def add_item(item_name, quantity, shopping_list={}):     if item_name in shopping_list.keys():         shopping_list[item_name] += quantity     else:         shopping_list[item_name] = quantity</p> <pre><code>return shopping_list\n</code></pre> <p>clothes_shop_list = add_item(\"Shirt\", 3) electronics_store_list = add_item(\"USB cable\", 1) show_list(clothes_shop_list) show_list(electronics_store_list) You\u2019ll see the problem when you look at the output from this code:</p> <p>$ python optional_params.py</p> <p>3x Shirt 1x USB cable</p> <p>3x Shirt 1x USB cable Both shopping lists are identical even though you assigned the output from add_item() to different variables each time you called the function. The problem happens because dictionaries are a mutable data type.</p> <p>You assigned an empty dictionary as the default value for the parameter shopping_list when you defined the function. The first time you call the function, this dictionary is empty. However, as dictionaries are a mutable type, when you assign values to the dictionary, the default dictionary is no longer empty.</p> <p>When you call the function the second time and the default value for shopping_list is required again, the default dictionary is no longer empty as it was populated the first time you called the function. Since you\u2019re calling the same function, you\u2019re using the same default dictionary stored in memory.</p> <p>This behavior doesn\u2019t happen with immutable data types. The solution to this problem is to use another default value, such as None, and then create an empty dictionary within the function when no optional argument is passed:</p>"},{"location":"programacao/funcoes/#optional_paramspy_7","title":"optional_params.py","text":"<p>def show_list(shopping_list, include_quantities=True):     print()     for item_name, quantity in shopping_list.items():         if include_quantities:             print(f\"{quantity}x {item_name}\")         else:             print(item_name)</p> <p>def add_item(item_name, quantity, shopping_list=None):     if shopping_list is None:         shopping_list = {}     if item_name in shopping_list.keys():         shopping_list[item_name] += quantity     else:         shopping_list[item_name] = quantity</p> <pre><code>return shopping_list\n</code></pre> <p>clothes_shop_list = add_item(\"Shirt\", 3) electronics_store_list = add_item(\"USB cable\", 1) show_list(clothes_shop_list) show_list(electronics_store_list) You can check whether a dictionary has been passed as an argument using the if statement. You should not rely on the falsy nature of None but instead explicitly check that the argument is None. Relying on the fact that None will be treated as a false value can cause problems if another argument that is falsy is passed.</p> <p>Now when you run your script again, you\u2019ll get the correct output since a new dictionary is created each time you use the function with the default value for shopping_list:</p> <p>$ python optional_params.py</p> <p>3x Shirt</p> <p>1x USB cable You should always avoid using a mutable data type as a default value when defining a function with optional parameters.</p> <p>Functions Accepting Any Number of Arguments Before defining a function that accepts any number of arguments, you\u2019ll need to be familiar with the unpacking operator. You can start with a list such as the following one:</p> <p>some_items = [\"Coffee\", \"Tea\", \"Cake\", \"Bread\"] The variable some_items points to a list, and the list, in turn, has four items within it. If you use some_items as an argument to print(), then you\u2019re passing one variable to print():</p> <p>print(some_items) ['Coffee', 'Tea', 'Cake', 'Bread'] print() displays the list, as you would expect. However, if you had to use *some_items within the parentheses of print(), you\u2019ll get a different outcome:</p> <p>print(*some_items) Coffee Tea Cake Bread This time, print() displays the four separate strings rather than the list. This is equivalent to writing the following:</p> <p>print(\"Coffee\", \"Tea\", \"Cake\", \"Bread\") Coffee Tea Cake Bread When the asterisk or star symbol (*) is used immediately before a sequence, such as some_items, it unpacks the sequence into its individual components. When a sequence such as a list is unpacked, its items are extracted and treated as individual objects.</p> <p>You may have noticed that print() can take any number of arguments. You\u2019ve used it with one input argument and with four input arguments in the examples above. You can also use print() with empty parentheses, and it will print a blank line.</p> <p>You\u2019re now ready to define your own functions that accept a variable number of input arguments. For the time being, you can simplify add_items() to accept only the names of the items you want in the shopping list. You\u2019ll set the quantity to 1 for each item. You\u2019ll then get back to including the quantities as part of the input arguments in the next section.</p> <p>The function signature that includes the variable number of input arguments using args looks like this:</p> <p>def add_items(shopping_list, *args): You\u2019ll often see function signatures that use the name args to represent this type of optional argument. However, this is just a parameter name. There is nothing special about the name args. It is the preceding * that gives this parameter its particular properties, which you\u2019ll read about below. Often, it\u2019s better to use a parameter name that suits your needs best to make the code more readable, as in the example below:</p>"},{"location":"programacao/funcoes/#optional_paramspy_8","title":"optional_params.py","text":"<p>shopping_list = {}</p> <p>def show_list(shopping_list, include_quantities=True):     print()     for item_name, quantity in shopping_list.items():         if include_quantities:             print(f\"{quantity}x {item_name}\")         else:             print(item_name)</p> <p>def add_items(shopping_list, *item_names):     for item_name in item_names:         shopping_list[item_name] = 1</p> <pre><code>return shopping_list\n</code></pre> <p>shopping_list = add_items(shopping_list, \"Coffee\", \"Tea\", \"Cake\", \"Bread\") show_list(shopping_list) The first argument when calling add_items() is a required argument. Following the first argument, the function can accept any number of additional arguments. In this case, you\u2019ve added four additional arguments when calling the function. Here\u2019s the output of the above code:</p> <p>$ python optional_params.py</p> <p>1x Coffee 1x Tea 1x Cake 1x Bread You can understand what\u2019s happening with the item_names parameter by looking at a simplified example:</p> <p>def add_items_demo(*item_names): ...     print(type(item_names)) ...     print(item_names) ... add_items_demo(\"Coffee\", \"Tea\", \"Cake\", \"Bread\")  ('Coffee', 'Tea', 'Cake', 'Bread') When you display the data type, you can see that item_names is a tuple. Therefore, all the additional arguments are assigned as items in the tuple item_names. You can then use this tuple within the function definition as you did in the main definition of add_items() above, in which you\u2019re iterating through the tuple item_names using a for loop. <p>This is not the same as passing a tuple as an argument in the function call. Using *args allows you to use the function more flexibly as you can add as many arguments as you wish without the need to place them in a tuple in the function call.</p> <p>If you don\u2019t add any additional arguments when you call the function, then the tuple will be empty:</p> <p>add_items_demo()  () When you add args to a function definition, you\u2019ll usually add them after all the required and optional parameters. You can have keyword-only arguments that follow the args, but for this tutorial, you can assume that args will usually be added after all other arguments, except for kwargs, which you\u2019ll learn about in the following section. <p>Functions Accepting Any Number of Keyword Arguments When you define a function with parameters, you have a choice of calling the function using either non-keyword arguments or keyword arguments:</p> <p>def test_arguments(a, b): ...     print(a) ...     print(b) ... test_arguments(\"first argument\", \"second argument\") first argument second argument test_arguments(a=\"first argument\", b=\"second argument\") first argument second argument In the first function call, the arguments are passed by position, whereas in the second one they\u2019re passed by keyword. If you use keyword arguments, you no longer need to input arguments in the order they are defined:</p> <p>test_arguments(b=\"second argument\", a=\"first argument\") first argument second argument You can change this default behavior by declaring positional-only arguments or keyword-only arguments.</p> <p>When defining a function, you can include any number of optional keyword arguments to be included using kwargs, which stands for keyword arguments. The function signature looks like this:</p> <p>def add_items(shopping_list, kwargs): The parameter name kwargs is preceded by two asterisks (). The double star or asterisk operates similarly to the single asterisk you used earlier to unpack items from a sequence. The double star is used to unpack items from a mapping. A mapping is a data type that has paired values as items, such as a dictionary.</p> <p>The parameter name kwargs is often used in function definitions, but the parameter can have any other name as long as it\u2019s preceded by the ** operator. You can now rewrite add_items() so that it accepts any number of keyword arguments:</p>"},{"location":"programacao/funcoes/#optional_paramspy_9","title":"optional_params.py","text":"<p>shopping_list = {}</p> <p>def show_list(shopping_list, include_quantities=True):     print()     for item_name, quantity in shopping_list.items():         if include_quantities:             print(f\"{quantity}x {item_name}\")         else:             print(item_name)</p> <p>def add_items(shopping_list, **things_to_buy):     for item_name, quantity in things_to_buy.items():         shopping_list[item_name] = quantity</p> <pre><code>return shopping_list\n</code></pre> <p>shopping_list = add_items(shopping_list, coffee=1, tea=2, cake=1, bread=3) show_list(shopping_list) The output from this code displays the items in the dictionary shopping_list, showing all four things you wish to buy and their respective quantities. You included this information as keyword arguments when you called the function:</p> <p>$ python optional_params.py</p> <p>1x coffee 2x tea 1x cake 3x bread Earlier, you learned that args is a tuple, and the optional non-keyword arguments used in the function call are stored as items in the tuple. The optional keyword arguments are stored in a dictionary, and the keyword arguments are stored as key-value pairs in this dictionary:</p> <p>def add_items_demo(**things_to_buy): ...     print(type(things_to_buy)) ...     print(things_to_buy) ... add_items_demo(coffee=1, tea=2, cake=1, bread=3)  {'coffee': 1, 'tea': 2, 'cake': 1, 'bread': 3} To learn more about args and kwargs, you can read Python args and kwargs: Demystified, and you\u2019ll find more detail about keyword and non-keyword arguments in functions and the order in which arguments can be used in Defining Your Own Python Function. <p>Conclusion Defining your own function to create a self-contained subroutine is one of the key building blocks when writing code. The most useful and powerful functions are those that perform one clear task and that you can use in a flexible manner. Using optional arguments is a key technique to achieve this.</p> <p>In this tutorial, you\u2019ve learned:</p> <p>What the difference is between parameters and arguments How to define functions with optional arguments and default parameter values How to define functions using args and kwargs How to deal with error messages about optional arguments A good understanding of optional arguments will also help you use functions in the standard library and in other third-party modules. Displaying the documentation for these functions will show you the function signature from which you\u2019ll be able to identify which arguments are required, which ones are optional, and which ones are args or kwargs.</p> <p>However, the main skill you\u2019ve learned in this tutorial is to define your own functions. You can now start writing functions with required and optional parameters and with a variable number of non-keyword and keyword arguments. Mastering these skills will help you take your Python coding to the next level.</p>"},{"location":"programacao/funcoes_recursivas/","title":"Funcoes recursivas","text":"Exerc\u00edcios Como adaptar a curva de Koch para um quadrado? <p>``` python title=\"Quadrado de Koch\" def quadrado_de_koch(comprimento):     if comprimento &lt; 8:         linha(comprimento)          # __     else:         comprimento /= 4</p> <pre><code>    curva_de_koch(comprimento)  # __\n\n    gira(90)\n    curva_de_koch(comprimento)  # __|\n\n    gira(-90)                   #    __\n    curva_de_koch(comprimento)  # __|\n\n    gira(-90)                   #    __\n    curva_de_koch(comprimento)  # __|  |\n\n    gira(90)                    #    __\n    curva_de_koch(comprimento)  # __|  |__\n</code></pre>"},{"location":"programacao/linguagem/","title":"Linguagem de Programa\u00e7\u00e3o","text":""},{"location":"programacao/linguagem/#linguagem-de-programacao","title":"Linguagem de Programa\u00e7\u00e3o","text":"<p>Programa\u00e7\u00e3o / Linguagem de programa\u00e7\u00e3o</p> <p>Programa\u00e7\u00e3o \u00e9 o processo de transformar o algoritmo em instru\u00e7\u00f5es em uma linguagem de programa\u00e7\u00e3o, que permite a formula\u00e7\u00e3o de instru\u00e7\u00f5es a um computador. A linguagem de programa\u00e7\u00e3o \u00e9 um conjunto de termos (vocabul\u00e1rio) e regras (sintaxe) que permite a formula\u00e7\u00e3o de instru\u00e7\u00f5es para um computador.</p> <p>Toda linguagem de programa\u00e7\u00e3o \u00e9 baseada em instru\u00e7\u00f5es primitivas, as entidades mais simples que ela trata; em formas de combina\u00e7\u00e3o destes elementos simples, e em formas de abstra\u00e7\u00e3o destas combina\u00e7\u00f5es de modo que possam tamb\u00e9m ser consideradas como primitivas1. Por exemplo, pode-se combinar muitas instru\u00e7\u00f5es primitivas necess\u00e1rias para exibir uma mensagem na sa\u00edda padr\u00e3o de tal forma que este processo seja f\u00e1cil e intuitivamente obtido por uma nova primitiva: <code>print</code>.</p> <p>Alan Turing mostrou que 6 primitivas s\u00e3o suficientes para computar qualquer coisa [comput\u00e1vel]. Assim, uma linguagem de programa\u00e7\u00e3o [Turing-completa] define tanto a sintaxe quanto a sem\u00e2ntica necess\u00e1rias para traduzir o pensamento computacional em passos que um computador pode executar.</p> <p>As linguagens modernas t\u00eam um conjunto maior e mais conveniente de primitivas que as 6 de Turing, e permitem que voc\u00ea as agrupe para elaborar programas mais complexos. Estas novas abstra\u00e7\u00f5es tamb\u00e9m podem ser agrupadas, e assim sucessivamente. Por exemplo, as primitivas mais comuns s\u00e3o: n\u00fameros (\\(1\\), \\(-2\\), \\(3.14\\)), s\u00edmbolos (\"@\", \"Alan M. Turing\", \":)\"), e opera\u00e7\u00f5es simples (\\(+\\), \\(-\\), \\(\\times\\), \\(\\div\\)).</p> <p>A sintaxe da linguagem indica quais express\u00f5es s\u00e3o simbolicamente corretas (<code>1 + 1</code>), ou n\u00e3o (<code>Jo\u00e3o \u00f7</code>). A sem\u00e2ntica lida com o significado associado a uma express\u00e3o sintaticamente correta, que pode ser logicamente correto (<code>dois = 1 + 1</code>) ou n\u00e3o (<code>area_do_quadrado = lado + lado</code>). Erros sint\u00e1ticos s\u00e3o relativamente f\u00e1ceis de se encontrar, mas o mesmo n\u00e3o pode ser dito sobre erros sem\u00e2nticos.</p> <p>A linguagem de m\u00e1quina \u00e9 a que o hardware [espec\u00edfico] entende (c\u00f3digo bin\u00e1rio). A vantagem \u00e9 que n\u00e3o \u00e9 preciso gastar esfor\u00e7os traduzindo instru\u00e7\u00f5es, mas \u00e9 praticamente incompreens\u00edvel para humanos [normais].</p> <p>Uma linguagem de baixo n\u00edvel usa instru\u00e7\u00f5es mnem\u00f4nicas para tentar facilitar a programa\u00e7\u00e3o. A vantagem \u00e9 ser muito mais intelig\u00edvel que a de m\u00e1quina, mas tamb\u00e9m \u00e9 pouco amig\u00e1vel e, dependendo do hardware utilizado, precisa ser traduzida para linguagem de m\u00e1quina.</p> <p>J\u00e1 uma linguagem de alto n\u00edvel usa um vocabul\u00e1rio mais rico para facilitar programa\u00e7\u00e3o. \u00c9 \"facilmente\" aprendida e independente do hardware, mas precisa ser traduzida para linguagem de m\u00e1quina. As linguagens de alto n\u00edvel claramente possibilitam programas mais breves e leg\u00edveis, mas o fazem pela composi\u00e7\u00e3o e abstra\u00e7\u00e3o das primitivas da m\u00e1quina. Conhecendo uma linguagem de programa\u00e7\u00e3o, pode-se elaborar programas bem interessantes.</p> <p>O exemplo tradicional \u00e9 o \"Ol\u00e1 mundo!\".</p> PythonRustCAssemblyC\u00f3digo Bin\u00e1rio Ol\u00e1 mundo!<pre><code>print('Ola mundo!')\n</code></pre> Ol\u00e1 mundo!<pre><code>fn main() {\nprintln!(\"Hello World!\");\n}\n</code></pre> Ol\u00e1 mundo!<pre><code>#include &lt;stdio.h&gt;\nint main() {\nprintf(\"Ola mundo!\\n\");\nreturn 0;\n}\n</code></pre> Ol\u00e1 mundo!<pre><code>section .data\nmsg     db      'Ola mundo!', 0AH\nlen     equ     $-msg\n\nsection .text\nglobal  _start\n_start: mov     edx, len\n        mov     ecx, msg\n        mov     ebx, 1\n        mov     eax, 4\n        int     80h\n\n        mov     ebx, 0\n        mov     eax, 1\n        int     80h\n</code></pre> Ol\u00e1 mundo!<pre><code>0111 1111 0100 0101 0100 1100 0100 0110\n0000 0010 0000 0001 0000 0001 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000\n0000 0010 0000 0000 0011 1110 0000 0000\n0000 0001 0000 0000 0000 0000 0000 0000\n0100 0000 0000 0100 0100 0000 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000\n(continua por mais 2120 linhas)\n</code></pre> <p>Dica</p> <p>Compreender os fundamentos e t\u00e9cnicas de programa\u00e7\u00e3o \u00e9 mais importante que dominar uma linguagem espec\u00edfica.</p> <p>Havendo um programa sintaticamente correto, \u00e9 preciso traduzi-lo da linguagem de alto n\u00edvel para a linguagem de m\u00e1quina para que haja instru\u00e7\u00f5es que o computador usado consiga interpretar (cada dispositivo fala sua pr\u00f3pria linguagem). Neste processo, o c\u00f3digo fonte \u00e9 verificado para garantir que n\u00e3o cont\u00e9m erros sint\u00e1ticos. Dependendo da implementa\u00e7\u00e3o da linguagem, este c\u00f3digo \u00e9 compilado, gerando um objeto (a vers\u00e3o das instru\u00e7\u00f5es originais em bin\u00e1rio) que, por sua vez, \u00e9 interpretado por um programa gerando um arquivo que pode ser executado.</p> <p>Qualquer linguagem de programa\u00e7\u00e3o pode ser interpretada ou compilada, estas s\u00e3o formas de implementa\u00e7\u00e3o (e n\u00e3o caracter\u00edsticas da linguagem) que n\u00e3o s\u00e3o, necessariamente, exclusivas. A interpreta\u00e7\u00e3o \u00e9 realizada por um programa espec\u00edfico (o interpretador) que realiza as instru\u00e7\u00f5es pelo programa sendo interpretado de modo que este seja executado. Imagine que, a cada passo, uma instru\u00e7\u00e3o \u00e9 interpretada e executada. J\u00e1 a compila\u00e7\u00e3o (realizada pelo programa compilador) traduz completamente o programa original em c\u00f3digo objeto que pode ser executado pela m\u00e1quina.</p> <p>A interpreta\u00e7\u00e3o tende a ser mais port\u00e1til, e tem a \"vantagem\" de realizar um passo de cada vez, j\u00e1 a compila\u00e7\u00e3o pode a gerar c\u00f3digo otimizado e que n\u00e3o precisa ser interpretado a cada instru\u00e7\u00e3o. Outra diferen\u00e7a \u00e9 que interpretadores s\u00e3o mais simples de se construir que compiladores.</p> <p>Existem diversas ferramentas para realizar este processo, como o compilador GCC para linguagem C ou o interpretador Python 3. No caso do exemplo abaixo, supondo que se esteja no diret\u00f3rio do arquivo com c\u00f3digo fonte, bastaria executar na linha de comando:</p> PythonC Ol\u00e1 mundo!<pre><code>$ python ola_mundo.py\n</code></pre> Ol\u00e1 mundo!<pre><code>$ gcc ola_mundo.c -o ola_mundo\n$ ./ola_mundo\n</code></pre>"},{"location":"programacao/linguagem/#conceitos-basicos","title":"Conceitos B\u00e1sicos","text":"<p>A execu\u00e7\u00e3o do programa passa pela interpreta\u00e7\u00e3o das instru\u00e7\u00f5es apresentadas. Uma instru\u00e7\u00e3o <code>&lt;instr&gt;</code> \u00e9 um comando sintaticamente correto que pode ser diretamente executado. J\u00e1 uma express\u00e3o <code>&lt;expr&gt;</code> \u00e9 uma instru\u00e7\u00e3o que precisa ser interpretada e que produz um resultado (que pode ser armazenado). Por exemplo, ao interagir com um agente humano como executor do algoritmo, ele entende a instru\u00e7\u00e3o <code>&lt;Levante&gt;</code> e a realiza, mas n\u00e3o h\u00e1 uma informa\u00e7\u00e3o produzida como resultado disto. Em seguida, podemos passar a express\u00e3o <code>&lt;Fale seu nome&gt;</code>, cujos termos precisam ser analisados e interpretados no contexto para que o agente possa reconhecer quem deve executar (o pr\u00f3prio agente), qual a a\u00e7\u00e3o  a ser executada (falar) e sobre o que ela deve executar (o nome) - s\u00f3 ent\u00e3o ele pode executar o que foi solicitado e produzir uma nova informa\u00e7\u00e3o (o nome falado), que se pode ser armazenado (ou n\u00e3o) para uma necessidade futura.</p> <p>Uma express\u00e3o pode ser composta por apenas um valor, como <code>&lt;Pedro&gt;</code> ou <code>&lt;42&gt;</code>, e tamb\u00e9m por diferentes valores e operadores. A express\u00e3o <code>2 + 3</code> produz o resultado 5 ao ser executada.</p> Instru\u00e7\u00f5esExpress\u00f5es Python<pre><code>pass\n</code></pre> Python<pre><code>&gt;&gt;&gt; 21 * 2\n42\n&gt;&gt;&gt; 20 - (2 ** 3 - 1)\n7\n&gt;&gt;&gt; -1 + (-4 * 2.5 + 3 / 2)\n-9.5\n</code></pre> Tipo de Dado <p>Todo processo no computador gerencia a execu\u00e7\u00e3o de um programa armazenado, a implementa\u00e7\u00e3o de um algoritmo computacional n\u00e3os sendo, portanto, poss\u00edvel dissociar um algoritmo de dados manipulados - o pr\u00f3prio programa \u00e9 um conjunto de dados (as instru\u00e7\u00f5es). Al\u00e9m disso, praticamente todos os programas manipulam dados fornecidos e gerados no processamento, na forma de vari\u00e1veis ou constantes, que s\u00e3o os objetos de dados b\u00e1sicos manipulados em um programa2.</p> <p>Ao executar um algoritmo computacional, estamos exigindo esfor\u00e7o da m\u00e1quina para realizar o trabalho de processamento. Este esfor\u00e7o depende da quantidade de instru\u00e7\u00f5es sendo executadas, e do custo de cada instru\u00e7\u00f5es (podemos ter instru\u00e7\u00f5es mais simples e baratas, e instru\u00e7\u00f5es mais complexas e caras). A organiza\u00e7\u00e3o dos dados tem impacto direto neste esfor\u00e7o, e buscamos deix\u00e1-los organizados de forma a tornar o processo menos custoso. Por exemplo, imagine que seu problema \u00e9 interpretar n\u00fameros e som\u00e1-los, \u00e9 muito mais f\u00e1cil1 fazer isso se lhe forem apresentados os n\u00fameros estruturados como \\(49\\) e \\(1\\) (com resultado \\(50\\)) que se fossem como \\(XLIX\\) e \\(I\\) (tamb\u00e9m com resultado \\(L\\)).</p> <p>A mem\u00f3ria do computador \u00e9 um conjunto ordenado de bits, ou seja, toda informa\u00e7\u00e3o \u00e9 armazenada como zeros e uns e h\u00e1 uma ordem posicional entre eles (existe um primeiro bit, que pode ser <code>0/1</code>, um segundo bit que tamb\u00e9m pode ser <code>0/1</code>, e assim sucessivamente at\u00e9 um \u00faltimo bit). Para facilitar, h\u00e1 uma nomenclatura espec\u00edfica para lidar com a quantidade de bits sendo 1 byte (8 bits) a unidade mais comum para quantific\u00e1-lo. A composi\u00e7\u00e3o de bits permite representar mais estados; 2 bits s\u00e3o 4 estados (<code>00/01/11/10</code>), 3 bits definem 8 estados, e assim sucessivamente - havendo \\(n\\) bits podemos definir \\(2^n\\) estados distintos. O significado da informa\u00e7\u00e3o armazenada depende da forma de interpretar estes bits, um mesmo conjunto de bits tem significados diferentes se for interpretado como um n\u00famero, um s\u00edmbolo ou outra coisa. Por exemplo, um byte pode assumir um de 256 valores num\u00e9ricos diferentes, mas tamb\u00e9m pode representar in\u00fameras informa\u00e7\u00f5es diferentes se mudarmos a forma de interpret\u00e1-lo.</p> <p></p> <p>A representa\u00e7\u00e3o do dado \u00e9 necessariamente bin\u00e1ria mas a interpreta\u00e7\u00e3o dos bits \u00e9 o que define a informa\u00e7\u00e3o. Esta interpreta\u00e7\u00e3o \u00e9 determinada pelo tipo de dado, e cada tipo tem suas caracter\u00edsticas espec\u00edficas definidas pela linguagem de programa\u00e7\u00e3o. Por exemplo, o conjunto de bits <code>01000001001000000000000000000000</code> pode ser interpretado como o valor num\u00e9rico do tipo inteiro 1092616192, como o valor num\u00e9rico do tipo real 10.0 ou como um tipo simb\u00f3lico <code>A</code> (ASCII). Estes tr\u00eas tipos de dados, entre outros, geralmente est\u00e3o presentes em qualquer linguagem de programa\u00e7\u00e3o.</p> <p>Dica</p> <p>Como um mesmo conjunto de bits pode ser interpretado de diferentes formas, \u00e9 necess\u00e1rio saber que tipo de dado foi armazenado na mem\u00f3ria para interpret\u00e1-lo corretamente.</p> <p>Um tipo abstrato de dado (TAD) determina um tipo de dado e as opera\u00e7\u00f5es definidas sobre ele, delimitando assim a quantidade de informa\u00e7\u00e3o necess\u00e1ria para manipula\u00e7\u00e3o dos valores pelo computador e, consequentemente, facilitando a programa\u00e7\u00e3o. Um exemplo de TAD \u00e9 o conjunto de n\u00fameros naturais \\(\\mathbb{N}\\) e suas opera\u00e7\u00f5es aritm\u00e9ticas \\(+, -, /, *\\)).</p> <p>Estrutura de Dados</p> <p>Forma concreta de se implementar um tipo abstrato de dados em uma linguagem de programa\u00e7\u00e3o, de modo a organizar os dados na mem\u00f3ria para facilitar o acesso e a manipula\u00e7\u00e3o destes.</p> <p>Portanto, para cada linguagem de programa\u00e7\u00e3o espec\u00edfica, o tipo do dado determina:</p> <ol> <li>o significado do valor armazenado;</li> <li>como o valor \u00e9 armazenado nos bits;</li> <li>quais os poss\u00edveis valores que podem ser armazenados; e</li> <li>quais as opera\u00e7\u00f5es podem ser realizadas com o valor.</li> </ol> <p>Dica</p> <p>As caracter\u00edsticas de uma estrutura de dados espec\u00edfica s\u00e3o importantes pois determinam o que pode e tamb\u00e9m o que n\u00e3o pode ser feito com ela.</p> Exerc\u00edcios Dado um n\u00famero n\u00e3o negativo qualquer na base hexadecimal, descreva o algoritmos para transform\u00e1-lo em um n\u00famero bin\u00e1rio. <p>Como a base 16 \u00e9 m\u00faltipla de 2, o processo manual \u00e9 bem simples. Cada algarismo hexadecimal pode ser diretamente mapeado para seu valor bin\u00e1rio de 4 bits, na mesma ordem. Por exemplo, para \\(2A_{16}\\) temos que \\(2_{16} \\rightarrow 0010_2\\) e \\(A_{16} \\rightarrow 1010_2\\), portanto \\(2A_{16}\\rightarrow 00101010_2\\).</p> <p>Constante</p> <p>Uma constante <code>&lt;C&gt;</code> \u00e9 um valor armazenado que n\u00e3o \u00e9 alterado no decorrer do processamento.</p> <p>Vari\u00e1vel</p> <p>Uma vari\u00e1vel <code>&lt;v&gt;</code> \u00e9 um valor armazenado que pode ser alterado no decorrer do processamento.</p> ConstantesVari\u00e1veis Python<pre><code>&gt;&gt;&gt; math.pi\n3.141592653589793\n</code></pre> Python<pre><code>&gt;&gt;&gt; y = 13\n&gt;&gt;&gt; x = 42\n&gt;&gt;&gt; y = 123  # o valor de x n\u00e3o foi alterado, mas o de y sim.\n</code></pre> <p>Vari\u00e1veis e constantes exigem um pouco mais de</p> <ol> <li> <p>Harold Abelson, Gerald Jay Sussman, and Julie Sussman. Structure and Interpretation of Computer Programs. MIT Press, Cambridge, MA, USA, 1985. ISBN 0262010771.\u00a0\u21a9\u21a9</p> </li> <li> <p>Brian W. Kernighan and Dennis M. Ritchie. C: a linguagem de programa\u00e7\u00e3o padr\u00e3o ANSI. Campus, Rio de Janeiro, 1989. ISBN 8570015860 9788570015860.\u00a0\u21a9</p> </li> </ol>"},{"location":"programacao/python/","title":"N\u00fameros Inteiros em Python","text":"<p>Toda linguagem de programa\u00e7\u00e3o fornece alguns tipos de dados primitivos (ou embutidos) A linguagem Python define o tipo de dado <code>int</code> para armazenar n\u00fameros inteiros. As principais opera\u00e7\u00f5es com inteiros s\u00e3o:</p> Opera\u00e7\u00e3o Resultado Exemplo x + y soma de x e y 2 + 3 = 5 x - y diferen\u00e7a de x e y 3 - 2 = -1 x * y produto de x e y 2 * 3 = 6 x / y quociente da divis\u00e3o de x por y 2 / 3 = 1.5 x // y quociente inteiro da divis\u00e3o de x por y 2 // 3 = 1 x % y resto da divis\u00e3o de x por y 3 % 2 = 1 -x x negado -2 abs(x) valor absoluto de x abs(-2) = 2 int(x) x convertido em inteiro int(1.5) = 1 x ** y x elevado a y 2 ** 3 = 8 <p>Na mem\u00f3ria, os n\u00fameros s\u00e3o armazenados como complemento de 2, mas Python usa uma abordagem que t\u00eam precis\u00e3o \"ilimitada\" - um mecanismo que usa quantos bits forem necess\u00e1rios para armazenar corretamente o valor. Isso permite que se lide com n\u00fameros muito grandes mas, obviamente, o magnitude m\u00e1xima ainda est\u00e1 limitada \u00e0 quantidade da mem\u00f3ria dispon\u00edvel.</p> Inteiro em Python<pre><code>inteiro_32 = 42\ninteiro_64 = - 2 ** 63\ninteiro_super_longo = - 2 ** 1000\n</code></pre>"},{"location":"programacao/python/#numeros-reais-em-python","title":"N\u00fameros Reais em Python","text":"<p>O tipo de dado <code>float</code> para armazenar n\u00fameros reais em 64 bits. As principais opera\u00e7\u00f5es com inteiros s\u00e3o:</p> Opera\u00e7\u00e3o Resultado Exemplo x + y soma de x e y 2.5 + 3.25 = 5.25 x - y diferen\u00e7a de x e y 3.5 - 2.75 = -0.75 x * y produto de x e y 2.5 * 3.0 = 7.5 x / y quociente da divis\u00e3o de x por y 2.0 / 3.0 = 1.5 x // y quociente inteiro da divis\u00e3o de x por y 2.0 // 3.0 = 1 x % y resto da divis\u00e3o de x por y 7.5 % 3.0 = 1.5 -x x negado -2.5 abs(x) valor absoluto de x abs(-2.5) = 2.5 float(x) x convertido em ponto flutuante float(1) = 1.0 x ** y x elevado a y .64 ** .5 = 0.8"},{"location":"programacao/tipos_de_dados/","title":"Estruturas de Dados","text":"<p>David Jones</p> <p>Acerte as estruturas de dados primeiro, e o resto do programa se escrever\u00e1 sozinho.</p> <p>Todo processo no computador gerencia a execu\u00e7\u00e3o de um programa armazenado, a implementa\u00e7\u00e3o de um algoritmo computacional n\u00e3os sendo, portanto, poss\u00edvel dissociar um algoritmo de dados manipulados - o pr\u00f3prio programa \u00e9 um conjunto de dados (as instru\u00e7\u00f5es). Al\u00e9m disso, praticamente todos os programas manipulas dados fornecidos e gerados no processamento, na forma de vari\u00e1veis ou constantes, que s\u00e3o os objetos de dados b\u00e1sicos manipulados em um programa1.</p> <p>O forma como organizamos estes dados tem impacto direto no desempenho do computador. Ao executar um algoritmo computacional, estamos exigindo esfor\u00e7o da m\u00e1quina para realizar o trabalho de processamento. Este esfor\u00e7o depende da quantidade de instru\u00e7\u00f5es sendo executadas, e do custo de cada instru\u00e7\u00f5es (podemos ter instru\u00e7\u00f5es mais simples e baratas, e instru\u00e7\u00f5es mais complexas e caras). A organiza\u00e7\u00e3o dos dados tem impacto direto neste esfor\u00e7o, e buscamos deix\u00e1-los organizados de forma a tornar o processo menos custoso. Por exemplo, imagine que seu problema \u00e9 interpretar n\u00fameros e som\u00e1-los, \u00e9 muito mais f\u00e1cil1 fazer isso se lhe forem apresentados os n\u00fameros estruturados como \\(49\\) e \\(1\\) (com resultado \\(50\\)) que se fossem como \\(XLIX\\) e \\(I\\) (tamb\u00e9m com resultado \\(L\\)).</p> <p>A mem\u00f3ria do computador \u00e9 um conjunto ordenado de bits, ou seja, toda informa\u00e7\u00e3o \u00e9 armazenada como zeros e uns e h\u00e1 uma ordem posicional entre eles (existe um primeiro bit, que pode ser <code>0/1</code>, um segundo bit que tamb\u00e9m pode ser <code>0/1</code>, e assim sucessivamente at\u00e9 um \u00faltimo bit). Para facilitar, h\u00e1 uma nomenclatura espec\u00edfica para lidar com a quantidade de bits sendo 1 byte (8 bits) a unidade mais comum para quantific\u00e1-lo. A composi\u00e7\u00e3o de bits permite representar mais estados; 2 bits s\u00e3o 4 estados (<code>00/01/11/10</code>), 3 bits definem 8 estados, e assim sucessivamente - havendo \\(n\\) bits podemos definir \\(2^n\\) estados distintos. O significado da informa\u00e7\u00e3o armazenada depende da forma de interpretar estes bits, um mesmo conjunto de bits tem significados diferentes se for interpretado como um n\u00famero, um s\u00edmbolo ou outra coisa. Por exemplo, um byte pode assumir um de 256 valores num\u00e9ricos diferentes, mas tamb\u00e9m pode representar in\u00fameras informa\u00e7\u00f5es diferentes se mudarmos a forma de interpret\u00e1-lo.</p> <p></p> <p>A representa\u00e7\u00e3o do dado \u00e9 necessariamente bin\u00e1ria mas a interpreta\u00e7\u00e3o dos bits \u00e9 o que define a informa\u00e7\u00e3o. Esta interpreta\u00e7\u00e3o \u00e9 determinada pelo tipo de dado, e cada tipo tem suas caracter\u00edsticas espec\u00edficas definidas pela linguagem de programa\u00e7\u00e3o. Por exemplo, o conjunto de bits <code>01000001001000000000000000000000</code> pode ser interpretado como o valor num\u00e9rico do tipo inteiro 1092616192, como o valor num\u00e9rico do tipo real 10.0 ou como um tipo simb\u00f3lico <code>A</code> (ASCII). Estes tr\u00eas tipos de dados, entre outros, geralmente est\u00e3o presentes em qualquer linguagem de programa\u00e7\u00e3o.</p> <p>Dica</p> <p>Como um mesmo conjunto de bits pode ser interpretado de diferentes formas, \u00e9 preciso saber que tipo de dado foi armazenado na mem\u00f3ria para interpret\u00e1-lo corretamente.</p> <p>Um tipo abstrato de dado (TAD) determina um tipo de dado e as opera\u00e7\u00f5es definidas sobre ele, delimitando assim a quantidade de informa\u00e7\u00e3o necess\u00e1ria para manipula\u00e7\u00e3o dos valores pelo computador e, consequentemente, facilitando a programa\u00e7\u00e3o. Por exemplo, o conjunto de n\u00fameros naturais \\(\\mathbb{N}\\) e suas opera\u00e7\u00f5es (como \\(+, -, /, *\\)) \u00e9 um TAD.</p> <p>Estrutura de Dados</p> <p>Forma concreta de se implementar um tipo abstrato de dados em uma linguagem de programa\u00e7\u00e3o, de modo a organizar os dados na mem\u00f3ria para facilitar o acesso e a manipula\u00e7\u00e3o destes.</p> <p>Portanto, para cada linguagem de programa\u00e7\u00e3o espec\u00edfica, o tipo do dado determina:</p> <ol> <li>o significado do valor armazenado;</li> <li>como o valor \u00e9 armazenado nos bits;</li> <li>quais os poss\u00edveis valores que podem ser armazenados; e</li> <li>quais as opera\u00e7\u00f5es podem ser realizadas com o valor.</li> </ol> <p>Dica</p> <p>As caracter\u00edsticas de uma estrutura de dados espec\u00edfica s\u00e3o importantes pois determinam o que pode e tamb\u00e9m o que n\u00e3o pode ser feito com ela.</p> N\u00fameros <p>Um n\u00famero \u00e9 um objeto matem\u00e1tico usado para descrever uma quantidade, e uma base num\u00e9rica \u00e9 um conjunto de algarismos utilizados para representar um n\u00famero. Quais s\u00e3o os s\u00edmbolos e as regras de como utiliz\u00e1-los s\u00e3o definidos pelos sistema de numera\u00e7\u00e3o usado. O valor de um n\u00famero \u00e9 \u00fanico, mas sua representa\u00e7\u00e3o pode variar conforme o sistema utilizado - \u00e9 f\u00e1cil ilustrar isso comparando o abordagem usamos normalmente, com algarismos ar\u00e1bicos e a nota\u00e7\u00e3o posicional, \u00e0 abordagem que os antigos romanos usavam. Para o valor quarenta e nove, temos as representa\u00e7\u00f5es \\(49\\) e \\(XLIX\\), respectivamente.</p> <p>Na nota\u00e7\u00e3o posicional, o valor representado por um algarismo depende da posi\u00e7\u00e3o em que ele se encontra no conjunto de s\u00edmbolos que representa o n\u00famero, sendo valores a esquerda mais influentes que os a direita. O valor deste n\u00famero \u00e9 determinado pela soma dos valores relativos de cada algarismo. Por exemplo: 123 = 100 + 20 + 3, o algarismo mais a esquerda (1) tem uma influ\u00eancia maior que os demais no valor, e \u00e9 considerado o mais significativo. O algarismo seguinte (2) tem uma influ\u00eancia menor que o anterior, mas maior que o seguinte. Isso se sucede at\u00e9 o \u00faltimo algarismo, o mais a direita, que \u00e9 chamado de menos significativo. Podemos reescrever a informa\u00e7\u00e3o da seguinte forma:</p> \\[123 = 100 + 20 + 3 = 1\u00b710^2+ 2\u00b710^1+ 3\u00b710^0\\] <p>Nesta representa\u00e7\u00e3o, duas coisas se destacam. A primeira \u00e9 que a influ\u00eancia de cada algarismo \u00e9 determinada por uma pot\u00eancia de 10, que \u00e9 a base num\u00e9rica. A segunda, \u00e9 que esta pot\u00eancia \u00e9 uma sequ\u00eancia crescente da posi\u00e7\u00e3o menos significativa para a mais significativa, iniciando-se por 0. De forma mais gen\u00e9rica, um algarismo \\(A\\) tem uma influ\u00eancia proporcional a sua posi\u00e7\u00e3o \\(i\\) para uma base num\u00e9rica \\(B\\).</p> \\[A\u00b7{B^i}\\] <p>No valor 123, na base decimal, entendemos seu valor pela soma de seus componentes. O algarismo 3 est\u00e1 na posi\u00e7\u00e3o mais a direita, considerada como posi\u00e7\u00e3o \\(i = 0\\), portanto seu peso no valor resultante \u00e9 de 3\u00b710\\(^0\\). A posi\u00e7\u00e3o seguinte (a esquerda) \u00e9 i = 1 com o algarismo 2, acrescentando 2\u00b710\\(^1\\) ao resultado. O \u00faltimo algarismo (mais a esquerda) \u00e9 1 e est\u00e1 na posi\u00e7\u00e3o 2, acrescentando 1\u00b710\\(^2\\). De forma gen\u00e9rica, o valor de um n\u00famero em uma base num\u00e9rica \\(B\\) qualquer, representado com \\(n\\) algarismos \\(A_i : A \\in [0, B), i \\in [0, n)\\), \u00e9 calculado com a seguinte f\u00f3rmula:</p> \\[A_{n-1}A_{n-2}\u2026{A_2}A_1A_0 = \\sum\\limits_{i=0}^{n - 1}{A_i\u00b7{B^i}}\\] <p>Para representar a informa\u00e7\u00e3o num\u00e9rica na mem\u00f3ria do computador, ela necessariamente deve ser representada como um conjunto de bits. Isto \u00e9 relativamente simples, o bit tem dois estados, 0/1 que s\u00e3o os algarismos da base num\u00e9rica bin\u00e1ria. Portanto, podemos usar esta base na nota\u00e7\u00e3o posicional para basta representar um valor num\u00e9rico qualquer como bits na mem\u00f3ria. Como tamb\u00e9m usaremos algarismos ar\u00e1bicos, para diferenciar as bases num\u00e9ricas acrescentamos um sufixo ao n\u00famero.</p> \\[1101_2 = 1\u00b72^3+ 1\u00b72^2+ 0\u00b72^1+ 1\u00b72^0 = 8 + 4 + 0 + 1 = 13_{10}\\] <p>Por ser uma base de valor baixo, s\u00e3o poucos os algarismos e, portanto, as representa\u00e7\u00f5es dos n\u00fameros se tornam extensas. Outras bases de valor mais elevado permitem compactar isso, e as mais \u00fateis s\u00e3o as m\u00faltiplas de 2 j\u00e1 que a convers\u00e3o delas para a bin\u00e1ria \u00e9 simplificada. A tabela abaixo mostra alguns valores nas bases mais comuns na computa\u00e7\u00e3o: bin\u00e1ria, octal, decimal e hexadecimal. Note que, como a nota\u00e7\u00e3o posicional utiliza apenas um s\u00edmbolo por posi\u00e7\u00e3o, a base hexadecimal define os valores superiores a 9 (o maior algarismo ar\u00e1bico) para letras do alfabeto latino.</p> <p> bin\u00e1ria octal decimal hexadecimal 0 0 0 0 1 1 1 1 10 2 2 2 11 3 3 3 100 4 4 4 101 5 5 5 110 6 6 6 111 7 7 7 1000 10 8 8 1001 11 9 9 1010 12 10 A 1011 13 11 B 1100 14 12 C 1101 15 13 D 1110 16 14 E 1111 17 15 F 101010 52 42 2A 1111011 173 123 7B <p></p>"},{"location":"programacao/tipos_de_dados/#numeros-inteiros","title":"N\u00fameros Inteiros","text":"<p>J\u00e1 vimos a representa\u00e7\u00e3o dos n\u00fameros naturais em bin\u00e1rio. Entretanto, muitas problemas lidam com os n\u00fameros inteiros, que podem ter valores negativos. Felizmente, um n\u00famero s\u00f3 pode ser negativo ou n\u00e3o, ou seja, a informa\u00e7\u00e3o do sinal \u00e9 facilmente representada em um bit. A conven\u00e7\u00e3o \u00e9 que o bit mais a esquerda armazena a informa\u00e7\u00e3o se o n\u00famero \u00e9 negativo (ligado/1) ou se \u00e9 positivo (desligado/0), e os demais bits armazenam a informa\u00e7\u00e3o do valor do n\u00famero. H\u00e1 formas distintas de se interpretar este \u00faltimo conjunto de bits, como listadas a seguir.</p> <p>Sinal e Magnitude, onde o bit mais significativo indica o sinal e os demais bits determinam o valor diretamente pela nota\u00e7\u00e3o posicional (como um n\u00famero natural). Esta abordagem \u00e9 intuitivamente simples para entendermos.</p> <p> bits sinal nota\u00e7\u00e3o posicional decimal 000 +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 \\(-(0\u00b72^1+ 0\u00b72^0)\\) -0 101 -01 \\(-(0\u00b72^1+ 1\u00b72^0)\\) -1 110 -10 \\(-(1\u00b72^1+ 0\u00b72^0)\\) -2 111 -11 \\(-(1\u00b72^1+ 1\u00b72^0)\\) -3 <p></p> <p>Complemento de um tamb\u00e9m considera o bit mais a esquerda como indicador de sinal e os demais para o valor, conforme o sinal. Se positivo, os bits restantes indicam o valor pela nota\u00e7\u00e3o posicional (como na abordagem de sinal e magnitude); se negativo, \u00e9 preciso inverter todos os bits antes de considerar a nota\u00e7\u00e3o posicional. Esta varia\u00e7\u00e3o \u00e9 um pouco mais complexa para entendermos, mas tem vantagens quanto \u00e0 anterior para algumas opera\u00e7\u00f5es. Uma delas \u00e9 que precisa-se de menos esfor\u00e7o para para inverter o sinal de um valor, uma opera\u00e7\u00e3o muito frequente em problemas computacionais. Usando complemento de um, basta inverter todos os bits.</p> <p> bits sinal inverte? nota\u00e7\u00e3o posicional decimal 000 +00 n\u00e3o +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 n\u00e3o +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 n\u00e3o +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 n\u00e3o +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 sim -11 \\(-(1\u00b72^1+ 1\u00b72^0)\\) -3 101 -01 sim -10 \\(-(1\u00b72^1+ 0\u00b72^0)\\) -2 110 -10 sim -01 \\(-(0\u00b72^1+ 1\u00b72^0)\\) -1 111 -11 sim -00 \\(-(0\u00b72^1+ 0\u00b72^0)\\) -0 <p></p> <p>Por fim, a forma mais utilizada \u00e9 complemento de dois. Nela, tamb\u00e9m o bit mais a esquerda define o sinal e os demais determinam o valor conforme o sinal. Se positivo, os bits restantes indicam o valor pela nota\u00e7\u00e3o posicional; se negativo, \u00e9 preciso inverter todos os bits e incrementar em 1 o resultado antes de considerar a nota\u00e7\u00e3o posicional. Embora mais complicada para n\u00f3s, esta abordagem tem vantagens sobre as demais, como quantidade de valores distintos que se pode armazenar e facilidade na computa\u00e7\u00e3o de opera\u00e7\u00f5es aritm\u00e9ticas.</p> <p> bits sinal inverte? +1 nota\u00e7\u00e3o posicional decimal 000 +00 n\u00e3o +00 n\u00e3o +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 n\u00e3o +01 n\u00e3o +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 n\u00e3o +10 n\u00e3o +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 n\u00e3o +11 n\u00e3o +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 sim -11 sim -100 \\(-(1\u00b72^2+ 0\u00b72^1+ 0\u00b72^0)\\) -4 101 -01 sim -10 sim -011 \\(-(0\u00b72^2+ 1\u00b72^1+ 1\u00b72^0)\\) -3 110 -10 sim -01 sim -010 \\(-(0\u00b72^2+ 1\u00b72^1+ 0\u00b72^0)\\) -2 111 -11 sim -00 sim -001 \\(-(0\u00b72^2+ 0\u00b72^1+ 1\u00b72^0)\\) -1 <p></p> <p>Geralmente, valores inteiros s\u00e3o armazenados em um tipo de dado <code>inteiro</code> de 32 ou 64 bits. Considerando o primeiro caso, a estrutura de dados para complemento de dois determina:</p> <ol> <li>O significado \u00e9 de um valor num\u00e9rico inteiro, que pode ser negativo.</li> <li>O valor \u00e9 armazenado como Complemento de 2 nos 32 bits.</li> <li>Os poss\u00edveis valores armazenados est\u00e3o no intervalo \\([-2^{31}, 2^{31})\\).</li> <li>As opera\u00e7\u00f5es aritm\u00e9ticas b\u00e1sicas (\\(+, -, \\times\\ e\\ \\div\\)) est\u00e3o definidas na linguagem de programa\u00e7\u00e3o - e possivelmente outras.</li> </ol>"},{"location":"programacao/tipos_de_dados/#numeros-reais","title":"N\u00fameros Reais","text":"<p>Os n\u00fameros reais tamb\u00e9m podem ser representados como bin\u00e1rios pelo sistema posicional, basta estender a l\u00f3gica da nota\u00e7\u00e3o posicional. Por exemplo, considere o seguinte n\u00famero decimal:</p> \\[13,125 = 1\\cdot{10^1} + 3\\cdot{10^0} + 1\\cdot{10^{-1}} + 2\\cdot{10^{-2}} + 5\\cdot{10^{-3}}\\] <p>Este valor pode ser representado com a mesma l\u00f3gica em 7 bits:</p> \\[1\\cdot2^3 + 1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 0\\cdot2^{-2} + 1\\cdot2^{-3} = 1101,001_2\\] <p>Neste caso usamos 4 bits para o valor inteiro e 3 para o valor fracion\u00e1rio.</p> Ponto Fixo <p>A representa\u00e7\u00e3o com ponto fixo define que, dada uma quantidade \\(Q\\) de bits para representar o n\u00famero, h\u00e1 uma quantidade fixa \\(m\\) de bits que armazenam a parte inteira e outra quantidade \\(f\\) que armazena a parte fracion\u00e1ria do n\u00famero (tais que \\(Q = m + f\\)). Por exemplo, supondo \\(Qm.f = Q5.3\\), o n\u00famero 13,125 seria representado pelos bits <code>01101001</code> cujo valor \u00e9 interpretado como <code>01101,001</code>. Supondo \\(Q4.4\\), este mesmo valor \u00e9 representado por <code>11010010</code>.</p> <p>O ponto fixo \u00e9 uma conven\u00e7\u00e3o interessante, mas pouco flex\u00edvel. Como toda estrutura de dados, a quantidade de bits limita os valores que podem ser armazenado, portanto uma configura\u00e7\u00e3o \\(Qm.f\\) que pode ser adequada para uma aplica\u00e7\u00e3o espec\u00edfica pode ser inadequada para outra. Por exemplo, considerando que \\(Q=8\\), uma representa\u00e7\u00e3o \\(Q0.7\\) \u00e9 mais interessante para lidar com o tamanho de componentes eletr\u00f4nicos que a \\(Q5.3\\). Desta forma, fica invi\u00e1vel determinar um padr\u00e3o para ponto fixo que seja suficiente para a maioria das aplica\u00e7\u00f5es.</p> Ponto Flutuante <p>Como alternativa mas flex\u00edvel, temos a representa\u00e7\u00e3o em ponto flutuante que se baseia na ideia da nota\u00e7\u00e3o cient\u00edfica onde qualquer n\u00famero pode ser representado no mesmo formato em duas componentes, separando valor num\u00e9rico de sua grandeza. Dada uma mantissa (\\(m\\)) composta por algarismos que determinam o valor do n\u00famero e um expoente (\\(e\\)) que determina sua grandeza, um n\u00famero qualquer na base \\(B\\) pode ser representado da seguinte forma:</p> \\[m\\cdot{B}^{e}\\] <p>Por exemplo:</p> \\[0,13125\\cdot10^2 = 13,125_{10} \\Longleftrightarrow 1101,001_2 = 0,1101001\\cdot2^4\\] <p>Esta representa\u00e7\u00e3o oferece maior flexibilidade e alcance de valores. O padr\u00e3o usado nos computadores modernos \u00e9 o IEEE 754, que define o valor armazenado considerando um conjunto de bits de tamanho fixo em tr\u00eas partes: um bit para determinar o sinal, seguido de \\(e\\) bits para o valor do expoente, seguido de \\(m\\) bits para a mantissa. Esta abordagem permite que se use quaisquer quantidades de bits mas usualmente temos a precis\u00e3o simples (32 bits em blocos de 1/8/23) e dupla (64 bits, em blocos de 1/11/52). O valor armazenado pode ser obtido pelo valor num\u00e9rico simples de cada bloco desta forma:</p> \\[(-1)^{s}\\cdot1,m\\cdot2^{e-offset}\\] <p>O offset depende da quantidade de bits de e, sendo calculado como \\(2^{e-1}-1\\). Para as precis\u00f5es simples e dupla, temos os valores 127 e 1023, respectivamente. Por exemplo, para precis\u00e3o simples temos que:</p> sinal expoente mantissa f\u00f3rmula valor 1 01111110 10000000000000000000000 \\((-1)^{1}\\cdot1,1\\cdot2^{-1}\\) \\(-0,75_{10}\\) 0 10000010 10100100000000000000000 \\((-1)^{0}\\cdot1,101001\\cdot2^3\\) \\(13,125_{10}\\) <p>O uso de ponto flutuante oferece diversas vantagens, principalmente a representa\u00e7\u00e3o de valores absolutos muito grandes ou pequenos2, mas h\u00e1 limita\u00e7\u00f5es. O conjunto de n\u00fameros reais \u00e9 infinitamente grande, e n\u00e3o pode ser completamente representado com a quantidade finita de bits dispon\u00edvel na mem\u00f3ria, portanto \u00e9 muito comum que valores em ponto flutuante sejam arredondados ao serem armazenados na quantidade fixa de bits dispon\u00edvel3.</p> <p>Por exemplo, considere a express\u00e3o \\(1 / 3 = 0,33333\\dots\\). O valor resultante \u00e9 uma d\u00edzima peri\u00f3dica, podemos mostrar matematicamente que \\(0,\\overline{3} + 0,\\overline{3} + 0,\\overline{3} = 1\\). Entretanto, \\(0,\\overline{3}\\) \u00e9 uma express\u00e3o matem\u00e1tica com mais informa\u00e7\u00e3o que \"apenas\" algarismos, ela determina um valor que n\u00e3o pode ser exatamente representado por uma quantidade fixa de algarismos (ou bits na mem\u00f3ria). O que se pode fazer \u00e9 usar toda a capacidade dispon\u00edvel para armazenar o valor mais pr\u00f3ximo poss\u00edvel. Considere que s\u00f3 podemos usar 3 algarismos, ent\u00e3o a express\u00e3o \\(0,\\overline{3} + 0,\\overline{3} + 0,\\overline{3}\\) se torna \\(0,33 + 0,33 + 0,33 = 0,99 \\neq 1\\).</p> <p>Esta imprecis\u00e3o tem implica\u00e7\u00f5es interessantes pois, para um programa de computador, a express\u00e3o \\(0,1 + 0,1 + 0,1\\) n\u00e3o resulta no valor \\(0,3\\)! O valor decimal \\(0,1\\) \u00e9 representado em bin\u00e1rio como \\(0,1\\overline{0011}\\) at\u00e9 o limite de bits reservados, que \u00e9 insuficiente para o valor exato. Abaixo, podemos ver as diferen\u00e7as escolhendo precis\u00f5es arbitr\u00e1rias para mostrar um mesmo valor armazenado de \\(0,1\\), bem como o efeito da propaga\u00e7\u00e3o desta diferen\u00e7a ao longo de diversas opera\u00e7\u00f5es:</p> ValorSomat\u00f3rio <p><p>1 casa de precis\u00e3o: 0.1</p> <p>5 casas de precis\u00e3o: 0.10000</p> <p>15 casas de precis\u00e3o: 0.100000000000000</p> <p>28 casas de precis\u00e3o: 0.1000000000000000055511151231</p> </p> <p><p>\\(\\sum\\limits_{i=1}^{1}0.1 = 0.1000000000000000055511151231\\)</p> <p>\\(\\sum\\limits_{i=1}^{3}0.1 = 0.3000000000000000444089209850\\)</p> <p>\\(\\sum\\limits_{i=1}^{10}0.1 = 1.0000000000000000000000000000\\)</p> <p>\\(\\sum\\limits_{i=1}^{100}0.1 = 10.0000000000000000000000000000\\)</p> </p> <p>Os efeitos da imprecis\u00e3o tendem a n\u00e3o ser considerados na maioria das aplica\u00e7\u00f5es (que n\u00e3o lidem com isso como as de engenharia/finan\u00e7as/computa\u00e7\u00e3o cient\u00edfica). Entretanto, deve-se ter aten\u00e7\u00e3o especial pois, apesar da diferen\u00e7a para o valor exato ser \"pequena\", ela existe e pode causar dificuldades se seu programa liga com algo simples como verificar se \\(0,1 + 0,2 = 0,3\\) (algo bem prov\u00e1vel de ocorrer em muitas aplica\u00e7\u00f5es). \u00c9 papel do programador entender a situa\u00e7\u00e3o e lidar com ela.</p> <p>Algumas abordagens para com isso s\u00e3o trabalhar com inteiros e evitar comparar diretamente vari\u00e1veis do tpo <code>float</code>. Se necess\u00e1rio, podemos realizar a compara\u00e7\u00e3o considerando uma toler\u00e2ncia razo\u00e1vel para a diferen\u00e7a entre os valores: ao inv\u00e9s de \\(a &lt; b\\), usamos \\(|a - b| &lt; \\epsilon\\). Tamb\u00e9m \u00e9 preciso atentar para ac\u00famulo de imprecis\u00f5es ao longo de m\u00faltiplas computa\u00e7\u00f5es, pois podem ser realmente significativos.</p>"},{"location":"programacao/tipos_de_dados/#simbolos","title":"S\u00edmbolos","text":"<p>S\u00edmbolos s\u00e3o uma forma extremamente vers\u00e1til de comunicar informa\u00e7\u00f5es; o alfabeto define um pequeno conjunto de s\u00edmbolos que, juntos, podem expressar quase tudo que se deseja. S\u00edmbolos, como toda informa\u00e7\u00e3o no computador, s\u00e3o representados por bits.</p> ASCII <p>O padr\u00e3o ASCII4 (American Standard Code for Information Interchange) foi desenvolvido nos anos 60, sendo composto por 95 s\u00edmbolos gr\u00e1ficos (letras do alfabeto latino, algarismos ar\u00e1bicos, sinais de pontua\u00e7\u00e3o e sinais matem\u00e1ticos) e 33 de controle.</p> <p> Controle bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo 0x00 NUL 0x08 BS 0x10 DLE 0x18 CAN 0x01 SOH 0x09 HT 0x11 DC1 0x19 EM 0x02 STX 0x0A LF 0x12 DC2 \u22ee \u22ee 0x03 ETX 0x0B VT 0x13 DC3 \u22ee \u22ee 0x04 EOT 0x0C FF 0x14 DC4 \u22ee \u22ee 0x05 ENQ 0x0D CR 0x15 NAK \u22ee \u22ee 0x06 ACK 0x0E SO 0x16 SYN \u22ee \u22ee 0x07 BEL 0x0F SI 0x17 ETB 0x7F DEL Gr\u00e1ficos (Parcial) bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo 0x20 espa\u00e7o 0x30 0 0x41 A 0x61 a 0x21 ! 0x31 1 0x42 B 0x62 b 0x22 \" 0x32 2 0x43 C 0x63 c 0x23 # 0x33 3 0x44 D 0x64 d 0x24 $ 0x34 4 0x45 E 0x65 e 0x25 % 0x35 5 \u22ee \u22ee \u22ee \u22ee 0x26 &amp; 0x36 6 0x57 W 0x77 w 0x27 ' 0x37 7 0x58 X 0x78 x 0x28 ( 0x38 8 0x59 Y 0x79 y 0x29 ) 0x39 9 0x5A Z 0x7A z \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee <p></p> <p>Cada um dos 128 s\u00edmbolos \u00e9 associado \u00e0 uma sequ\u00eancia arbitr\u00e1ria e \u00fanica de 7 de bits. \u00c9 bem comum associar esta sequ\u00eancia a um n\u00famero inteiro, por exemplo o n\u00famero 65 ao s\u00edmbolo 'A' (\"um mesmo conjunto de bits pode ser interpretado de diferentes formas\"). Al\u00e9m disso, o padr\u00e3o ASCII tem algumas caracter\u00edsticas interessantes. Os algarismos s\u00e3o listados em ordem de valor, e as letras s\u00e3o organizadas em ordem alfab\u00e9tica, o que facilita os processos de compara\u00e7\u00e3o entre eles. As letras min\u00fasculas est\u00e3o deslocadas em 32 posi\u00e7\u00f5es em rela\u00e7\u00e3o \u00e0s mai\u00fasculas, ent\u00e3o a diferen\u00e7a entre os bits que as representam \u00e9 apenas no sexto bit!</p> <p>Por conta de como as m\u00e1quinas eram constru\u00eddas, era muito comum usar um byte para armazenar cada s\u00edmbolo, o que viabilizou definir outros 128 s\u00edmbolos arbitr\u00e1rios. Entretanto, n\u00e3o houve maior consenso em quais seriam os s\u00edmbolos, afinal cada grupo tinha seus pr\u00f3prios interesses. No Brasil, o mais comum era o ISO/IEC 8859-1. Com o avan\u00e7o da internet, a necessidade de comunica\u00e7\u00e3o entre m\u00e1quinas e grupos distintos for\u00e7ou a incorpora\u00e7\u00e3o de um padr\u00e3o internacional. Entretanto, algumas dificuldades deveriam ser consideradas...</p> <p>Uma solu\u00e7\u00e3o \"simples\" seria usar mais bits e ampliar o tamanho da tabela, mas isso implicaria que toda informa\u00e7\u00e3o j\u00e1 representada num padr\u00e3o como ASCII ocuparia mais mem\u00f3ria que o necess\u00e1rio. Por exemplo, supondo que fossem usados 3 bytes (possibilitando mais de 16 milh\u00f5es de s\u00edmbolos), uma mensagem com 10 s\u00edmbolos ASCII passa a ocupar 30 bytes, 200% a mais do que necess\u00e1rio. Tamb\u00e9m seria necess\u00e1rio lidar com informa\u00e7\u00f5es armazenadas que usam o s\u00edmbolo <code>NUL</code> para indicar o t\u00e9rmino de uma sequ\u00eancia de s\u00edmbolos - uma sequ\u00eancia de 8 bits com valor 0 n\u00e3o seria rara considerando 3 bytes. Outro ponto relevante era lidar com os documentos existentes, gerar uma c\u00f3pia de todo arquivo existente com esta nova codifica\u00e7\u00e3o seria uma tarefa invi\u00e1vel. A solu\u00e7\u00e3o encontrada foi uma forma elegante de lidar com tudo isso, al\u00e9m de viabilizar a incorpora\u00e7\u00e3o de quaisquer novos s\u00edmbolos que possam ser criados.</p> Unicode <p>Uma vez estabelecido um padr\u00e3o de codifica\u00e7\u00e3o de caracteres (associa\u00e7\u00e3o [arbitr\u00e1ria] de bits a certos caracteres), pode-se armazenar estes s\u00edmbolos na mem\u00f3ria (e recuper\u00e1-los). H\u00e1 diversar formas de se codificar caracteres: EBCDIC, Unicode (veja isso), ente outros.</p> <p>Nesta disciplina, o foco \u00e9 a representa\u00e7\u00e3o em ASCII, uma forma extremamente compacta e a mais utilizada no padr\u00e3o ANSI. Neste contexto, um <code>char</code> \u00e9 um pequeno inteiro, de modo que pode ser livremente usado em express\u00f5es aritm\u00e9ticas1 (veja \\linkFile[../src/exemplos/05_EstruturasDeDados/02_Simbolos]{00-ascii.c} e \\linkFile[../src/exemplos/05_EstruturasDeDados/02_Simbolos]{01-ascii.c}).</p> <p>A vers\u00e3o 3 da \\lP~utiliza outra abordagem, cada caractere \u00e9 representado como Unicode, mas os valores num\u00e9ricos/simb\u00f3licos podem ser utilizados por interm\u00e9dio das fun\u00e7\u00f5es <code>ord</code> e <code>chr</code>, respectivamente (veja \\linkFile[../src/exemplos/05_EstruturasDeDados/02_Simbolos]{00-ascii.py} e \\linkFile[../src/exemplos/05_EstruturasDeDados/02_Simbolos]{01-ascii.py}). \\else% \\begin{frame}%     A codifica\u00e7\u00e3o de caracteres \u00e9 a associa\u00e7\u00e3o de bits a s\u00edmbolos.     \\begin{center}\\includegraphics[width=.5\\textwidth]{misc/LouisBraille}\\end{center}     \\vfill%     Por necessidade de di\u00e1logos entre os diferentes computadores, foram criados     diversos c\u00f3digos objetivando a padroniza\u00e7\u00e3o. \\end{frame}% <p>\\begin{frame}%     \\framesubtitle{Extended Binary Coded Decimal Interchange Code (EBCDIC)}%     \\begin{center}\\includegraphics[width=.75\\textwidth]{computing/programming/EBCDIC}\\end{center} \\end{frame}% <p>\\begin{frame}%     \\framesubtitle{American Standard Code for Information Interchange (ASCII)}%     \\begin{center}\\includegraphics[width=.95\\textwidth]{computing/programming/ascii}\\end{center} \\end{frame}% \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstC[linerange={9-21}]{exemplos/05_EstruturasDeDados/02_Simbolos}{00-ascii.c}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstPython[firstline=12]{exemplos/05_EstruturasDeDados/02_Simbolos}{00-ascii.py}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstC[linerange={9-21}]{exemplos/05_EstruturasDeDados/02_Simbolos}{01-ascii.c}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstPython[firstline=9]{exemplos/05_EstruturasDeDados/02_Simbolos}{01-ascii.py}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=8]{exercicios/05_EstruturasDeDados/02_Simbolos}{00-maior}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=8]{exercicios/05_EstruturasDeDados/02_Simbolos}{01-toupper}% \\end{frame}\\] <p>\\begin{frame}%     \\framesubtitle{Unicode}%     \\vspace{-4em}%     \\hfill\\includegraphics[width=.2\\textwidth]{computing/programming/unicode}%     \\\\vspace{-1em}%     \\begin{itemize}     \\item Padr\u00e3o universal de codifica\u00e7\u00e3o de caracteres     \\item Fornece um n\u00famero \u00fanico para cada caractere, n\u00e3o importando a plataforma (a m\u00e1quina e/ou sistema operacional em uso), o programa ou o idioma.     \\item Permite definir caracteres cuja representa\u00e7\u00e3o interna no computador utiliza mais de um byte (UTF-8), tais como:     16 bits (UTF-16) e 32 bits (UTF-32).     \\item Atualmente, o padr\u00e3o consiste de mais de 100 mil caracteres e pode ser usado em v\u00e1rios sistemas operacionais, programas e navegadores modernos.     \\end{itemize} \\end{frame}% \\fi%"},{"location":"programacao/tipos_de_dados/#objetos-em-python","title":"Objetos em Python","text":"<p>\\subsection{Ponteiros na \\LP}% \\ifIsArticle% A \\lP~n\u00e3o utiliza ponteiros diretamente e, por projeto, manipula objetos de forma diferente de C. Em ambas, os argumentos s\u00e3o passados por valor, mas dependendo do tipo de objeto (mut\u00e1vel/imut\u00e1vel), a manipula\u00e7\u00e3o dentro do escopo de uma fun\u00e7\u00e3o tem ou n\u00e3o efeito em um escopo externo.</p> <p>Primeiro, \u00e9 preciso lembrar alguns detalhes da pr\u00f3pria linguagem: os objetos (que ficam na mem\u00f3ria) t\u00eam os seguintes atributos: tipo, que define a informa\u00e7\u00e3o (e valores) que o objeto pode receber e as opera\u00e7\u00f5es que podem ser executadas nele; valor, que \u00e9 o endere\u00e7o de mem\u00f3ria ocupado pelo objeto; nome, que identifica o objeto diferenciando dos demais elementos na mem\u00f3ria; e tempo de vida, que \u00e9 o per\u00edodo de tempo de execu\u00e7\u00e3o do programa durante o qual o objeto existe. Na \\lP{ }lida-se com refer\u00eancias para objetos, as quais desempenham pap\u00e9is similares a ponteiros. \\fi%</p> <p>\\ifIsArticle% Os objetos s\u00e3o imut\u00e1veis (como \\texttt{int}, \\texttt{float}, \\texttt{str}, etc.) ou mut\u00e1veis (como \\texttt{lista}, \\texttt{dict}, etc.). Toda vari\u00e1vel \u00e9, na verdade, uma refer\u00eancia para algum objeto da mem\u00f3ria. Considerando objetos imut\u00e1veis, como ilustrado na figura abaixo, o valor de nome `z' n\u00e3o varia a n\u00e3o ser que voc\u00ea o mude explicitamente, e o operador \\texttt{=} n\u00e3o \u00e9 de atribui\u00e7\u00e3o de valor (como na \\lC), mas de refer\u00eancia, e o coletor de lixo lida com a informa\u00e7\u00e3o \\texttt{42} ao t\u00e9rmino de seu tempo de vida. \\else% \\begin{frame}[fragile]%     %https://pythonhelp.wordpress.com/2013/02/20/variaveis-valores-e-referencias/     Python n\u00e3o utiliza ponteiros como tipos de dados, mas lida com refer\u00eancias de forma ``diferente''...%     \\\\pause\\vfill%     Os objetos em \\texttt{Python} s\u00e3o:     \\begin{description}          \\item[imut\u00e1veis:] \\texttt{int}, \\texttt{float}, \\texttt{str}, \\(\\dots\\)          \\item[mut\u00e1veis:] \\texttt{lista}, \\(\\dots\\)      \\end{description} \\end{frame}</p> <p>\\begin{frame}%     Toda vari\u00e1vel em \\texttt{Python} \u00e9 uma refer\u00eancia para algum objeto da mem\u00f3ria.     \\\\pause\\vfill%     Nesta abordagem para lidar com a mem\u00f3ria, o valor de nome `a' n\u00e3o varia a n\u00e3o ser que voc\u00ea o mude explicitamente\\footnote&lt;2-&gt;{Expl\u00edcito \u00e9 melhor que impl\u00edcito.}. \\end{frame} \\fi%</p> <p>\\ifIsArticle% \\begin{figure}[H]     \\centering     \\begin{subfigure}[b]{0.3\\textwidth}         \\begin{tikzpicture}[start chain=going right, node distance=0pt, mem/.style={inMemory,text width=2em, minimum height=1.7em}]%             \\node[mem,label={[address,above]0xB1}] (M0) {};%             \\node[mem,label={[address,above]0xB5}] (M1) {42};%             \\node[mem,label={[address,above]0xB9}] (M2) {\\(\\pi\\)};%             \\node[mem,label={[address,above]0xBD}] (M3) {43};%</p> <pre><code>        \\node[ptr,below of=M0,yshift=-3em] (a) {\\textbf{x}};%\n        \\draw[ptr] (a) -| (M1.south);%\n        \\node[ptr,below of=a,yshift=-2em] (b) {\\textbf{y}};%\n        \\draw[ptr] (b) -| (M2.south);%\n        \\node[ptr,below of=b,yshift=-2em] (c) {\\textbf{z}};%\n        \\draw[ptr] (c) -| (M3.south);%\n    \\end{tikzpicture}%\n    \\caption{\\texttt{x, y, z = 42, $\\pi$, 43}}\n\\end{subfigure}\n\\hspace{4em}%\n\\begin{subfigure}[b]{0.3\\textwidth}\n    \\begin{tikzpicture}[start chain=going right, node distance=0pt, mem/.style={inMemory,text width=2em, minimum height=1.7em}]%\n        \\node[mem,label={[address,above]0xB1}] (M0) {};%\n        \\node[mem,label={[address,above]0xB5}] (M1) {};%\n        \\node[mem,label={[address,above]0xB9}] (M2) {$\\pi$};%\n        \\node[mem,label={[address,above]0xBD}] (M3) {43};%\n\n        \\node[ptr,below of=M0,yshift=-3em] (a) {\\textbf{x}};%\n        \\draw[ptr] (a) -| (M2.south);%\n        \\node[ptr,below of=a,yshift=-2em] (b) {\\textbf{y}};%\n        \\draw[ptr] (b) -| (M3.south);%\n        \\node[ptr,below of=b,yshift=-2em] (c) {\\textbf{z}};%\n        \\draw[ptr] (c) -| (M3.south);%\n    \\end{tikzpicture}%\n    \\caption{\\texttt{x, y = y, z}}\n\\end{subfigure}\n</code></pre> <p>\\end{figure} \\else% \\begin{frame}[fragile]%     %https://pythonhelp.wordpress.com/2013/02/20/variaveis-valores-e-referencias/     O operador \\texttt{=} n\u00e3o \u00e9 de atribui\u00e7\u00e3o, mas de refer\u00eancia.%     \\vfill%     \\begin{columns}         \\column{.7\\textwidth}%             \\begin{tikzpicture}[start chain=going right, node distance=0pt, mem/.style={inMemory,text width=2em, minimum height=1.7em}]%                 \\node[mem,label={[address,above]0xB1}] (M0) {};%                 \\node[mem,label={[address,above]0xB5}] (M1) {\\only&lt;2&gt;{42}};%                 \\node[mem,label={[address,above]0xB9}] (M2) {\\only&lt;5-&gt;{\\(\\pi\\)}};%                 \\node[mem,label={[address,above]0xBD}] (M3) {\\only&lt;3-&gt;{43}};%                 \\node[mem,label={[address,above]0xC0}] (M4) {};%</p> <pre><code>            \\node&lt;2-&gt;[ptr,below of=M0,yshift=-4em] (a) {\\textbf{a}};%\n            \\draw&lt;2&gt;[ptr] (a) -| (M1.south);%\n            \\draw&lt;3-4&gt;[ptr] (a) -| (M3.south);%\n            \\node&lt;4-&gt;[ptr,below of=a,yshift=-2em] (b) {\\textbf{b}};%\n            \\draw&lt;4-&gt;[ptr] (b) -| (M3.south);%\n            \\draw&lt;5-&gt;[ptr] (a) -| (M2.south);%\n        \\end{tikzpicture}%\n    \\column{.2\\textwidth}%\n        \\pause\n</code></pre> <p>\\begin{lstlisting}[style=CIC-Python] a = 42 \\end{lstlisting}% \\pause\\vspace{-1.1em}% \\begin{lstlisting}[style=CIC-Python,firstnumber=2] a += 1 \\end{lstlisting}% \\pause\\vspace% \\begin{lstlisting}[style=CIC-Python,firstnumber=3] b = a \\end{lstlisting}% \\pause\\vspace*{-1.1em}% \\begin{lstlisting}[style=CIC-Python,firstnumber=4] a = 3.14 \\end{lstlisting}%     \\end{columns}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% Na \\lP, o conte\u00fado de uma vari\u00e1vel \u00e9 acessado por seu nome, e n\u00e3o \u00e9 permitida a manipula\u00e7\u00e3o direta da mem\u00f3ria por um endere\u00e7o. Isso tem uma s\u00e9rie de vantagens (simplifica o uso e evita ) e desvantagens (desempenho). Internamente, o sistema acumula identificadores pr\u00f3prios para cada objeto enquanto durar o seu tempo de vida (veja \\linkFile[../src/exemplos/05_EstruturasDeDados/03_Ponteiros]{00-identificador.py} e \\linkFile[../src/exemplos/05_EstruturasDeDados/03_Ponteiros]{01-identificador.py}). \\else% \\begin{frame}[fragile]     \\lstPython[linerange={9-13,15-23}]{exemplos/05_EstruturasDeDados/03_Ponteiros}{00-identificador.py}% \\end{frame}</p> <p>\\begin{frame}[fragile]     \\lstPython[linerange={9-14,25-32}]{exemplos/05_EstruturasDeDados/03_Ponteiros}{01-identificador.py}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% A \\lP~tem tipo din\u00e2mico e forte, portanto ao declarar um objeto se sabe, em tempo de execu\u00e7\u00e3o, o tipo de dado referenciado e como ele \u00e9 representado na mem\u00f3ria. \\else% \\begin{frame}[fragile]%     Um tipo \u00e9 din\u00e2mico e forte (em tempo de execu\u00e7\u00e3o, sabe-se o tipo de dado referenciado e como ele \u00e9 representado na mem\u00f3ria).     \\\\vfill%     \\begin{columns}         \\column{.5\\textwidth}%             \\begin{tikzpicture}[start chain=going right, node distance=0pt, mem/.style={inMemory,text width=2.5em, minimum height=1.7em}]%                 \\node[mem,label={[address,above]0xB1}] (M0) {42};%                 \\node[mem,label={[address,above]0xB5},text width=5em] (M1) {\\only&lt;2-&gt;{Lovelace}};%                 \\node[ptr,below of=M0,xshift=-2em,yshift=-3em] (a) {\\textbf{x}};%                 \\draw&lt;1&gt;[ptr] (a) -| (M0.south);%                 \\draw&lt;2-&gt;[ptr] (a) -| (M1.south);%             \\end{tikzpicture}%         \\column{.5\\textwidth}%             \\begin{lstlisting}[style=CIC-Python] x = 42 \\end{lstlisting}%             \\vspace{-1.1em}\\pause%             \\begin{lstlisting}[style=CIC-Python,firstnumber=2] x = 'Lovelace' \\end{lstlisting}%     \\end{columns}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% No caso da passagem de informa\u00e7\u00f5es a fun\u00e7\u00f5es por argumentos, a \\lP~define a vari\u00e1vel local como refer\u00eancia ao valor passado (similar a passar a refer\u00eancia para o valor armazenado). A diferen\u00e7a ocorre na quest\u00e3o de qual \u00e9 o objeto dado, se \u00e9 mut\u00e1vel, a fun\u00e7\u00e3o recebe uma refer\u00eancia para ele e pode alter\u00e1-lo (desde que a refer\u00eancia local n\u00e3o seja variada); se \u00e9 imut\u00e1vel, a fun\u00e7\u00e3o n\u00e3o pode alter\u00e1-lo.</p> <p>A comunica\u00e7\u00e3o de dados entre [sub]algoritmos \u00e9 feita pela passagem de argumentos e pelo valor de retorno, e a \\lP possibilita o retorno de m\u00faltiplos valores.</p> <p>\\noindent% \\lstPython[linerange={9-9,18-24}]{exemplos/05_EstruturasDeDados/03_Ponteiros}{05-bhaskara.py}% \\else% \\begin{frame}[fragile]%      \u00c9 poss\u00edvel retornar de m\u00faltiplos valores.     \\\\vfill%     \\lstPython[linerange={9-9,18-24}]{exemplos/05_EstruturasDeDados/03_Ponteiros}{05-bhaskara.py}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% Na \\lP, fun\u00e7\u00f5es tamb\u00e9m s\u00e3o objetos, e podem ser fornecidas como argumentos para outras fun\u00e7\u00f5es de forma mais simplificada (comparada a \\lC). Um exemplo simples disso \u00e9:</p> <p>\\lstPython[linerange={9-19}]{exemplos/05_EstruturasDeDados/03_Ponteiros}{06-funcao.py}%</p> <p>Da mesma forma, pode-se abstrair o m\u00e9todo de aproxima\u00e7\u00e3o de ra\u00edzes e passar a fun\u00e7\u00e3o do polin\u00f4mio (\\linkFile[../src/exercicios/05_EstruturasDeDados/03_Ponteiros/01-Newton-Raphson]{Newton-Raphson.py}). \\else% \\subsection{Fun\u00e7\u00f5es como Argumentos de Fun\u00e7\u00f5es}% \\begin{frame}[fragile]% <pre><code>\\lstPython[firstline=9]{exemplos/05_EstruturasDeDados/03_Ponteiros}{06-funcao.py}%\n</code></pre> <p>\\end{frame}</p> <p>\\begin{frame}[fragile]%     \\vspace{-1em}%     \\lstPython[linerange={83-83,94-102},morekeywords={valor_inicial,aproxima,erro},escapechar=]{exercicios/05_EstruturasDeDados/03_Ponteiros/01-Newton-Raphson}{Newton-Raphson.py}% \\end{frame} \\fi% <p>% Os detalhes de ponteiros na \\lP{ }n\u00e3o ser\u00e3o aprofundados aqui, mas vale a pena aprender sobre isso.</p> <p>%     chamada por compartilhamento</p> <p>%     \u00edndice negativo %     https://docs.python.org/3/faq/programming.html#what-s-a-negative-index</p> <p>%     O comportamento de ``passagem por refer\u00eancia'' pode ser obtido de outras formas.</p> <p>% \\begin{frame}%</p> <p>% %%%%%%%%%%%%%%%%%%% % http://wiki.python.org.br/IntroPython</p> <p>% Tipos mut\u00e1veis e imut\u00e1veis</p> <p>% Alguns tipos no Python permitem que elementos que fazem parte de sua estrutura sejam modificados, como as listas e dicion\u00e1rios. Estes tipos s\u00e3o chamados mut\u00e1veis.</p> <p>% Exemplo:</p> <p>% Esconder n\u00famero das linhas</p> <p>%    1 &gt;&gt;&gt; l = ['Nirvana', 'Rush', 'Bauhaus'] %    2 &gt;&gt;&gt; l[1] = 'Who' %    3 &gt;&gt;&gt; l %    4 ['Nirvana', 'Who', 'Bauhaus'] %    5 &gt;&gt;&gt;</p> <p>% Outros tipos n\u00e3o permitem isso, como tuplas e strings. Estes s\u00e3o chamados imut\u00e1veis.</p> <p>% \\end{frame}%</p>"},{"location":"programacao/tipos_de_dados/#strings","title":"Strings","text":"<p>\\subsection{Strings}%</p> <p>\\ifIsArticle% Uma palavra/frase \u00e9 um conjunto finito e ordenado de s\u00edmbolos. Um *string* \u00e9 um vetor de caracteres, a ``melhor'' forma de comunica\u00e7\u00e3o com humanos.%</p> <p>\\lstset{morekeywords={mostra_indices,mostra_n_chars,mostra_ate_char}}% \\lstC[linerange={10-22}]{exemplos/05_EstruturasDeDados/04_Vetor}{04-string.c}%</p> <p>O c\u00f3digo acima funciona muito bem, mas tem um comportamento interessante quando se digita uma frase menor que os 50 caracteres definidos. Entretanto, for\u00e7ar a utiliza\u00e7\u00e3o de frases com tamanho fixo n\u00e3o \u00e9 uma op\u00e7\u00e3o vi\u00e1vel. A solu\u00e7\u00e3o de melhor custo/benef\u00edcio \u00e9 obter um vetor ``grande o suficiente'' para a tarefa em quest\u00e3o, de modo que haja um tamanho restringindo a aplica\u00e7\u00e3o (por exemplo, 140 caracteres), e utilizar uma marca\u00e7\u00e3o espec\u00edfica para indicar o t\u00e9rmino dos s\u00edmbolos de interesse.%</p> <p>\\noindent% \\begin{minipage}[t]{.56\\textwidth}% \\lstC[linerange={10-22}]{exemplos/05_EstruturasDeDados/04_Vetor}{05-string.c}% \\end{minipage}% \\hfill% \\begin{minipage}[t]{.44\\textwidth}% \\lstC[linerange={10-19}]{exemplos/05_EstruturasDeDados/04_Vetor}{06-string.c}% \\end{minipage}%</p> <p><code><code>.'&lt;/code&gt; n\u00e3o \u00e9 uma boa escolha de s\u00edmbolo terminador (afinal, sempre aparece algu\u00e9m dizendo ``*Hello World!*''), ent\u00e3o escolheu-se o s\u00edmbolo &lt;code&gt;</code>\\textbackslash0'</code> (o primeiro caractere da tabela ASCII) como terminador de um string para representa\u00e7\u00e3o interna1. Assumindo que todo string segue este padr\u00e3o, pode-se ignorar o tamanho do vetor e simplesmente percorr\u00ea-lo at\u00e9 encontrar o caractere de t\u00e9rmino.%</p> <p>Algumas ideias interessantes para lidar com strings s\u00e3o: contagem do tamanho de uma palavra, de palavras em um texto, compara\u00e7\u00e3o de strings, transforma\u00e7\u00e3o em letras mai\u00fasculas/min\u00fasculas, criptografia, etc..</p> <p>Considere o c\u00f3digo abaixo, e veja se percebe o que est\u00e1 errado: \\lstC[linerange={12-16}]{exemplos/05_EstruturasDeDados/04_Vetor}{08-memoria.c}%</p> <p><code>scanf</code>\\ armazena os caracteres digitados no endere\u00e7o indicado por \\var{buffer}. Como a vari\u00e1vel n\u00e3o foi inicializada, n\u00e3o \u00e9 poss\u00edvel dizer qual \u00e9 este endere\u00e7o. Se \\var{buffer} \u00e9 o caractere nulo (\\var{NULL}), ent\u00e3o <code>scanf</code>\\ tentar\u00e1 armazenar os caracteres em um local proibido e a execu\u00e7\u00e3o do programa ser\u00e1 interrompida. Sen\u00e3o, \\var{buffer}\\ tem um n\u00famero (que estava j\u00e1 armazenado na mem\u00f3ria por algum motivo) que \u00e9 interpretado como um endere\u00e7o de mem\u00f3ria onde <code>scanf</code>\\ tentar\u00e1 armazenar os caracteres. Embora sintaticamente correto, esta \u00e9 uma a\u00e7\u00e3o perigosa pois tal espa\u00e7o n\u00e3o foi alocado para seu uso, ent\u00e3o o programa estar\u00e1 trabalhando em um local que pode estar sendo usado por outro programa e, portanto, que poderia atrapalhar a execu\u00e7\u00e3o do seu ou, pior ainda, o seu atrapalhar a execu\u00e7\u00e3o dele (por exemplo, sobrescrevendo um peda\u00e7o do arquivo que cont\u00e9m a declara\u00e7\u00e3o do imposto de renda).</p> <p>Uma solu\u00e7\u00e3o \u00e9 definir \\var{buffer}\\ como um vetor (digamos, de tamanho 50). Mas esta solu\u00e7\u00e3o \u00e9 parcialmente correta, pois <code>scanf</code>\\ continuar\u00e1 escrevendo na mem\u00f3ria caso o usu\u00e1rio forne\u00e7a mais caracteres que o vetor pode armazenar. \u00c9 necess\u00e1rio, ent\u00e3o, limitar a quantidade de caracteres que pode ser considerada:%</p> <p>\\lstC[linerange={33-37}]{exemplos/05_EstruturasDeDados/04_Vetor}{08-memoria.c}%</p> <p>\u00c9 importante considerar este tipo de programa\u00e7\u00e3o defensiva, pois nunca se sabe o que o usu\u00e1rio vai fazer (nem como estas vulnerabilidades podem ser exploradas).</p> <p>% \\begin{lstlisting} % #include  <p>% void f(char *bar) { %   char c[12]; %   strncpy(c, bar, strlen(bar)); % }</p> <p>% int main(int argc, char **argv) { %   f(argv[1]); % } % \\end{lstlisting}% %  Potencialmente muito perigoso \\fi%</p>"},{"location":"programacao/tipos_de_dados/#vetores","title":"VetoresExerc\u00edcios","text":"<p>\\section{Vetores}</p> <p>\\ifIsArticle% \u00c9 f\u00e1cil manipular um dado para resolver um problema:% \\begin{lstlisting} z = min(x, y); \\end{lstlisting}%</p> <p>Mas e \\(n\\) problemas? \\begin{lstlisting} z = min(x1, min(x2, min (x3, min(x4, min(x5, / ... / min(xk, xn)/ ... /))))); \\end{lstlisting}% \\else% \\begin{frame}[fragile]% \u00c9 f\u00e1cil manipular um dado para resolver um problema:\\\\vfill% \\begin{lstlisting} z = min(x, y); \\end{lstlisting}% \\vfill\\pause Mas e \\strikeText{2} \\strikeText{3} \\(n\\) problemas?\\\\vfill% \\small% \\begin{lstlisting} z = min(x1, min(x2, min(x3, / ... / min(xk,xn)/ ... /))); \\end{lstlisting}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% N\u00e3o \u00e9 fact\u00edvel considerar escrever tanto c\u00f3digo, nem pensar nas dificuldades de eventuais altera\u00e7\u00f5es. Felizmente h\u00e1 uma solu\u00e7\u00e3o mais eficiente. Suponha que voc\u00ea tenha um ponteiro com o endere\u00e7o de um caractere na mem\u00f3ria, e que saiba que os \\(n\\) bytes imediatamente seguintes est\u00e3o alocados para voc\u00ea armazenar outros caracteres. Voc\u00ea poderia identific\u00e1-los como \\(\\{c_0, c_1, \\cdots, c_{n-1}\\}\\) e lidar com estes \\(n\\) elementos no c\u00f3digo, ou, dado que sabe o endere\u00e7o do primeiro, utilizar aritm\u00e9tica de ponteiros para acessar qualquer outro caractere em fun\u00e7\u00e3o do deslocamento em rela\u00e7\u00e3o a posi\u00e7\u00e3o inicial.</p> <p>\\begin{minipage}[t]{.52\\textwidth}% \\begin{lstlisting} printf(\"c0 = %c\\n\", c0); printf(\"c1 = %c\\n\", c1); / ... / \\end{lstlisting}% \\vspace{-1.1em}% \\begin{lstlisting}[firstnumber=1000] printf(\"c999 = %c\\n\", c999); / n==1000 / \\end{lstlisting}% \\end{minipage}% \\hfill% \\begin{minipage}[t]{.45\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i) printf(\"c%d = %c\\n\", i, (c+i)); \\end{lstlisting}% \\end{minipage}% \\vspace{1em}% \\else% \\begin{frame}[fragile]%     Mostrar 1000 caracteres n\u00e3o seria agrad\u00e1vel...     \\only&lt;2-&gt;{Mas suponha eles est\u00e3o magicamente armazenados sequencialmente, come\u00e7ando em um endere\u00e7o de mem\u00f3ria que voc\u00ea conhece...}     \\\\vfill \\hspace\\small% \\begin{minipage}[t]{.45\\textwidth}% \\begin{lstlisting} printf(\"c0=%c\\n\", c0); printf(\"c1=%c\\n\", c1); printf(\"c2=%c\\n\", c2); printf(\"c3=%c\\n\", c3); / ... / \\end{lstlisting}% \\begin{lstlisting}[firstnumber=997] / ... / printf(\"c997=%c\\n\", c997); printf(\"c998=%c\\n\", c998); printf(\"c999=%c\\n\", c999); \\end{lstlisting}% \\end{minipage}% \\pause\\pause% \\begin{minipage}[t]{.55\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i) printf(\"c%d=%c\\n\", i, *(c+i)); \\end{lstlisting}% \\end{minipage}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% Um vetor (\\texttt{array}) \u00e9 um conjunto finito e ordenado (em rela\u00e7\u00e3o a posi\u00e7\u00e3o) de elementos homog\u00eaneos (do mesmo tipo). \u00c9 um modo particular de organizar dados para facilitar o acesso e manipula\u00e7\u00e3o dos dados, caracterizado pelas opera\u00e7\u00f5es sobre os dados, e n\u00e3o pelo tipo do dado (j\u00e1 que se baseia na aritm\u00e9tica de ponteiros).</p> <p>Desta forma, \u00e9 poss\u00edvel ter um vetor de qualquer tipo de dado. Considerando \\(n\\) caracteres, o computador aloca um bloco de mem\u00f3ria de \\(n\\) bytes (supondo que um <code>char</code> seja armazenado em 1 byte). Analogamente, supondo \\(n\\) inteiros (de 4 bytes cada), ser\u00e3o alocados \\(4n\\) bytes de mem\u00f3ria (que equivalem a \\(n\\) unidades [de mem\u00f3ria] de inteiros).</p> <p>\\begin{center}%     \\tikzinput{memoria/vetor/array}% \\end{center}% \\else% \\begin{frame}%     \\begin{block}{Vetor (\\texttt{array})}%         \u00c9 um conjunto finito e ordenado\\footnote[frame]{Em rela\u00e7\u00e3o a posi\u00e7\u00e3o.} de elementos homog\u00eaneos.     \\end{block}%     \\vfill\\pause%     Quais elementos?%     \\vfill\\pause%     O vetor \u00e9 um modo particular de organizar dados \\pause para facilitar o acesso     e manipula\u00e7\u00e3o dos dados.     \\vfill%     \\begin{center}%         \\tikzinput{memoria/vetor/array}%     \\end{center}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% Portanto, para lidar com um vetor basta saber duas coisas: o endere\u00e7o do primeiro elemento e quantos s\u00e3o os elementos armazenados. Na \\lC, fica f\u00e1cil declarar um vetor:</p> <p>\\begin{lstlisting} int   inteiros[1000]; float reais[50]; char  caracteres[8]; \\end{lstlisting}%</p> <p>Considerando o vetor de caracteres, o que acontece na execu\u00e7\u00e3o \u00e9 que o computador armazena o ponteiro para caracteres (\\(c\\)) (em algum lugar da mem\u00f3ria) e um espa\u00e7o do tamanho desejado (<code>8*sizeof(char)</code>) em outro lugar. O acesso a cada elemento, dado o endere\u00e7o do primeiro, \u00e9 direto com aritm\u00e9tica de ponteiros ou com o operador <code>[\\ \\ ]</code>:</p> <p>\\noindent% \\begin{minipage}[t]{.52\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i)     printf(\"c%d = %c\\n\", i, *(c+i)); \\end{lstlisting}% \\end{minipage}% \\hfill% \\begin{minipage}[t]{.45\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i)     printf(\"c%d = %c\\n\", i, c[i]); \\end{lstlisting}% \\end{minipage}%</p> <p>\\begin{center}% \\tikzinput{memoria/vetor/lovelace}% \\end{center}% \\else% \\begin{frame}[fragile]%     Vetor em \\texttt{C}: endere\u00e7o do primeiro elemento e quantidade de elementos.     \\vfill% \\begin{lstlisting} int    inteiros[1000]; float     reais[50]; char caracteres[8]; \\end{lstlisting}% \\vfill\\pause% \\begin{center}%     \\scalebox{.8}{\\tikzinput{memoria/vetor/lovelace}}% \\end{center}% \\vfill\\pause% \\begin{minipage}[t]{.52\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i) printf(\"c%d=%c\\n\",i,*(c+i)); \\end{lstlisting}% \\end{minipage}% \\pause% \\begin{minipage}[t]{.48\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i) printf(\"c%d=%c\\n\",i,c[i]); \\end{lstlisting}% \\end{minipage}% \\vfill\\pause \\begin{center}% RAM + indexa\u00e7\u00e3o \\(\\Rightarrow\\) \\alert{velocidade}% \\end{center}% \\end{frame}</p> \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=8]{exercicios/05_EstruturasDeDados/04_Vetor}{00-salarios}% \\end{frame}\\] <p>\\titledImageFrame[height=17\\baselineskip]{}{comics/VidaDeProgramador/FOR}% \\fi% <p>\\ifIsArticle% A \\lP~tem uma abordagem diferente, no contexto desta disciplina, usaremos listas como vetores[@Downey2002]. Embora a implementa\u00e7\u00e3o seja distinta, o funcionamento \u00e9 bastante similar.</p> <p>\\begin{lstlisting}[style=CIC-Python] inteiros = [0, 1, 2, 3] reais = [0.0] * 10 caracteres = ['L', 'o', 'v', 'e', 'l', 'a', 'c', 'e'] \\end{lstlisting}% \\begin{minipage}[t]{.52\\textwidth}% \\begin{lstlisting}[style=CIC-Python] for i in range(len(inteiros)): print(inteiros[i]) \\end{lstlisting}% \\end{minipage}% \\pause\\hfill% \\begin{minipage}[t]{.4\\textwidth}% \\begin{lstlisting}[style=CIC-Python] for c in caracteres: print(c); \\end{lstlisting}% \\end{minipage}% \\else% \\begin{frame}[fragile]%     Em \\texttt{Python}, o termo que descreve um conjunto de elementos \u00e9 cole\u00e7\u00e3o, e a mais simples \u00e9 a lista. O funcionamento \u00e9 similar ao de um vetor em C, mas com uma s\u00e9rie de facilidades.     \\vfill% \\begin{lstlisting}[style=CIC-Python] inteiros = [0, 1, 2, 3] reais = [0.0] * 10 caracteres = ['L', 'o', 'v', 'e', 'l', 'a', 'c', 'e'] \\end{lstlisting}% \\vfill\\pause% \\begin{minipage}[t]{.52\\textwidth}% \\begin{lstlisting}[style=CIC-Python] for i in range(len(inteiros)): print(inteiros[i]) \\end{lstlisting}% \\end{minipage}% \\pause\\hfill% \\begin{minipage}[t]{.4\\textwidth}% \\begin{lstlisting}[style=CIC-Python] for c in caracteres: print(c); \\end{lstlisting}% \\end{minipage}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% O acesso aos elementos depende da posi\u00e7\u00e3o deles em rela\u00e7\u00e3o ao endere\u00e7o de in\u00edcio. Dependendo da linguagem, o primeiro elemento tem \u00edndice 0 (como em C, Java, Python, e Lisp) ou 1 (Fortran, COBOL, e Lua), mas por uma quest\u00e3o de simplicidade e facilidade de uso, a numera\u00e7\u00e3o deveria come\u00e7ar em zero[@Dijkstra1982].</p> <p>O acesso correto aos elementos depende tamb\u00e9m do tamanho do vetor. Na \\lC, os \\(n\\) elementos do vetor est\u00e3o localizados em um bloco cont\u00ednuo de bytes (com deslocamento em \\([0, n)\\), mas a aritm\u00e9tica de ponteiros permite que se acesse outras posi\u00e7\u00f5es [talvez inv\u00e1lidas] de mem\u00f3ria. Por exemplo, considerando a figura, a express\u00e3o <code>*(c-1)</code> (equivalente a  <code>c[-1]</code>) \u00e9 uma express\u00e3o sintaticamente correta, e resulta em endere\u00e7o de mem\u00f3ria v\u00e1lido (pois existe), mas \u00e9 semanticamente incorreta pois acessa um bloco de mem\u00f3ria que n\u00e3o foi alocado para o vetor em quest\u00e3o.</p> <p>\\lstC[linerange={10-24}]{exemplos/05_EstruturasDeDados/04_Vetor}{00-vetor.c}%</p> <p>Na \\lP, os \\(n\\) elementos sus podem ser acessados pelo \u00edndice correto: \\([0, n)\\), mas - obviamente - n\u00e3o h\u00e1 aritm\u00e9tica de ponteiros. Entretanto, h\u00e1 certas varia\u00e7\u00f5es que facilitam a vida. Por exemplo, o uso da fun\u00e7\u00e3o \\fn(len) e o uso de \u00edndices negativos para acessar os elementos em ordem inversa. No caso,</p> <p>\\begin{lstlisting}[style=CIC-Python] lista = [x for x in range(1, 10)]  # lista = [1, 2, 3, 4, 5, 6, 7, 8, 9]</p> <p>len(lista)        # 10 lsita.append(10)  # lista = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p> <p>lista[0]   # 1 lista[-0]  # 1 lista[-1]  # 10 lista[1:3] # [2, 3]\u2208</p> <p>for i in range(1, len(lista) + 1): print(lista[-i], end=' ')  # Ordem inversa: 10 9 8 7 6 5 4 3 2 1 \\end{lstlisting}% \\else% \\begin{frame}%   Considera\u00e7\u00f5es para vetores:   \\begin{itemize}%   \\item Muito cuidado com os \u00edndices utilizados, use somente \\(i\\in[0,n)\\).   \\item Pode n\u00e3o ser preciso ocupar todas as posi\u00e7\u00f5es do vetor, usar um vetor maior que o necess\u00e1rio muitas vezes facilita a vida...\\pause%   \\item Em \\lC: aloca\u00e7\u00e3o est\u00e1tica de mem\u00f3ria.   \\item Em \\lP: aloca\u00e7\u00e3o ``din\u00e2mica'' de mem\u00f3ria.   \\end{itemize}% \\end{frame}%</p> \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=6]{exercicios/05_EstruturasDeDados/04_Vetor}{01-medias}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=8]{exercicios/05_EstruturasDeDados/04_Vetor}{02-intercalados}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=6]{exercicios/05_EstruturasDeDados/04_Vetor}{03-funcoes}% \\end{frame}\\] <p>\\begin{frame}[fragile]%     \\lstREADME[lastline=6]{exercicios/05_EstruturasDeDados/04_Vetor}{04-mais_funcoes}% \\end{frame} \\fi% <p>\\ifIsArticle% Vetores n\u00e3o s\u00e3o ponteiros, mas na \\lC~eles s\u00e3o praticamente equivalentes, e a rela\u00e7\u00e3o \u00e9 t\u00e3o forte que eles devem ser discutidos juntos1. O vetor \u00e9 conjunto cont\u00edguo de elementos homog\u00eaneos pr\u00e9-alocados com posi\u00e7\u00e3o e tamanho fixos, j\u00e1 o ponteiro \u00e9 uma refer\u00eancia para um [tipo espec\u00edfico de] dado qualquer. Um ponteiro \u00e9 uma vari\u00e1vel, ent\u00e3o <code>a = p</code> e <code>p++</code> s\u00e3o opera\u00e7\u00f5es v\u00e1lidas; j\u00e1 um vetor n\u00e3o \u00e9 uma vari\u00e1vel, ent\u00e3o <code>a = v</code> e <code>v++</code> n\u00e3o s\u00e3o v\u00e1lidas[@VanDerLinden1994].</p> <p>\\lstC[linerange={10-24}]{exemplos/05_EstruturasDeDados/04_Vetor}{01-vetor.c}%</p> <p>\\begin{center}% \\tikzinput{memoria/vetor_ptr}% \\end{center}% \\else% \\begin{frame}%     \\framesubtitle{\\LC}%     Vetores n\u00e3o s\u00e3o ponteiros.     \\\\vfill     \\begin{center}%     \\tikzinput{memoria/vetor_ptr}%     \\end{center}% \\end{frame}</p> <p>\\begin{frame}[fragile]%     \\lstC[linerange={10-24}]{exemplos/05_EstruturasDeDados/04_Vetor}{01-vetor.c}% \\end{frame} \\fi% <p>\\ifIsArticle% Na \\lP, listas s\u00e3o objetos mut\u00e1veis, portanto uma fun\u00e7\u00e3o pode alterar os elementos de uma lista dada como argumento: \\begin{lstlisting}[style=CIC-Python] def troca_primeiros(lista): lista[0], lista[1] = lista[1], lista[0]</p> <p>lista = [x for x in range(1, 10)] troca_primeiros(lista) lista  # [2, 1, 3, 4, 5, 6, 7, 8, 9] \\end{lstlisting}%</p> <p>Na \\lC, muito cuidado ao utiliz\u00e1-los como argumento de fun\u00e7\u00f5es - a situa\u00e7\u00e3o de ``equival\u00eancia'' pode gerar uma s\u00e9rie de problemas.</p> <p>\\noindent% \\begin{minipage}[t]{.5\\textwidth}% \\lstC[linerange={14-21}]{exemplos/05_EstruturasDeDados/04_Vetor}{apc_vetor.h}% \\end{minipage}% \\hfill% \\begin{minipage}[t]{.5\\textwidth}% \\lstC[linerange={11-21}]{exemplos/05_EstruturasDeDados/04_Vetor}{02-vetor.c}% \\end{minipage}%</p> <p>Certas aplica\u00e7\u00f5es interessantes de vetores exigem que seus elementos estejam ordenados (em rela\u00e7\u00e3o ao conte\u00fado). Existem diversas formas de se fazer isso (consegue elaborar um algoritmo de ordena\u00e7\u00e3o?), cada uma com certas caracter\u00edsticas. Por exemplo, para ordenar em ordem crescente, pode-se considerar o primeiro elemento e compar\u00e1-lo com todos os demais, sempre que o primeiro for menor que o comparado, troca-se os conte\u00fados de posi\u00e7\u00e3o. Desta forma, ao final de todas as compara\u00e7\u00f5es, o elemento na primeira posi\u00e7\u00e3o ser\u00e1 o menor de todos. Ent\u00e3o basta repetir este procedimento para cada posi\u00e7\u00e3o subsequente e, ao final da execu\u00e7\u00e3o, tem-se o vetor ordenado.%</p> <p>\\begin{lstlisting}[style=CIC-Python] for i in range(len(vetor) - 1): for j in range(i + 1, len(vetor)):     if(vetor[i] &gt; vetor[j])         vetor[i], vetor[j] = vetor[j], vetor[i] \\end{lstlisting}%</p> <p>Este simples algoritmo pode ser facilmente adaptado para ordenar o vetor em ordem decrescente. Na verdade, \u00e9 poss\u00edvel abstrair ainda mais este procedimento com uma fun\u00e7\u00e3o de compara\u00e7\u00e3o, que indica uma ordem entre dois elementos. Ent\u00e3o, supondo uma fun\u00e7\u00e3o <code>em_ordem</code>\\ que indica se os elementos est\u00e3o ordenados, o algoritmo pode ser redefinido como:%</p> <p>\\lstC[linerange={16-25}]{exemplos/05_EstruturasDeDados/04_Vetor}{03-vetor.c}%</p> <p>Assim o algoritmo abstrai a fun\u00e7\u00e3o de compara\u00e7\u00e3o, e pode ser usado para realizar ordena\u00e7\u00f5es diferentes:</p> <p>\\lstC[linerange={13-14,26-27,33-33,37-37    ,40-42},morekeywords={ordena}]{exemplos/05_EstruturasDeDados/04_Vetor}{03-vetor.c}%</p> <p>Por fim, a \\lC~tem ``declara\u00e7\u00f5es complicadas'' (se\u00e7\u00e3o 5.12 de \\cite{Kernighan1989}), \u00e9 melhor entender o funcionamento que [tentar] adivinhar o tipo. Por exemplo:</p> <p>\\begin{lstlisting}[style=CIC-C] char argv / argv: ponteiro para ponteiro para char /</p> <p>int ( tabdia)[13] / tabdia: ponteiro para vetor[13] de int */</p> <p>int * tabdia[13] / tabdia: vetor[13] de ponteiro para int /</p> <p>void comp() / comp: fun\u00e7\u00e3o retornando ponteiro para void */</p> <p>void ( comp)() / comp: ponteiro para fun\u00e7\u00e3o retornando void */</p> <p>char ((x())[])() / x: fun\u00e7\u00e3o retornando ponteiro para vetor[] de ponteiro para fun\u00e7\u00e3o retornando char /</p> <p>char ((x[3]))[5] / x: vetor[3] de ponteiro para fun\u00e7\u00e3o retornando ponteiro para vetor[5] de char / \\end{lstlisting}% \\fi%</p> Considerando 4 bits para armazenar um n\u00famero real como ponto fixo, determine qual a representa\u00e7\u00e3o do valor \\(1,25_{10}\\) como \\(Q1.3\\), \\(Q2.2\\) e \\(Q3.1\\).  <ul> <li>\\(Q1.3 \\Rightarrow 1,25_{10} = 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} + 0\\cdot2^{-3} = 1010_2\\)</li> <li>\\(Q2.2 \\Rightarrow 1,25_{10} = 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} = 0101_2\\)</li> <li>\\(Q3.1\\) n\u00e3o \u00e9 adequado para este valor. Tem-se duas possibilidades:<ul> <li>\\(1,25_{10} \\approx 0\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} = 0001_2 (=1,5_{10})\\)</li> <li>\\(1,25_{10} \\approx 0\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 0\\cdot2^{-2} = 0010_2 (=1,0_{10})\\)</li> </ul> </li> </ul>"},{"location":"programacao/tipos_de_dados/#booleanos","title":"BooleanosExerc\u00edcios","text":"Dado um n\u00famero n\u00e3o negativo qualquer na base hexadecimal, descreva o algoritmos para transform\u00e1-lo em um n\u00famero bin\u00e1rio. <p>Como a base 16 \u00e9 m\u00faltipla de 2, o processo manual \u00e9 bem simples. Cada algarismo hexadecimal pode ser diretamente mapeado para seu valor bin\u00e1rio de 4 bits, na mesma ordem. Por exemplo, para \\(2A_{16}\\) temos que \\(2_{16} \\rightarrow 0010_2\\) e \\(A_{16} \\rightarrow 1010_2\\), portanto \\(2A_{16}\\rightarrow 00101010_2\\).</p> Dado um n\u00famero n\u00e3o negativo qualquer na base hexadecimal, descreva o algoritmos para transform\u00e1-lo em um n\u00famero bin\u00e1rio. <p>Como a base 16 \u00e9 m\u00faltipla de 2, o processo manual \u00e9 bem simples. Cada algarismo hexadecimal pode ser diretamente mapeado para seu valor bin\u00e1rio de 4 bits, na mesma ordem. Por exemplo, para \\(2A_{16}\\) temos que \\(2_{16} \\rightarrow 0010_2\\) e \\(A_{16} \\rightarrow 1010_2\\), portanto \\(2A_{16}\\rightarrow 00101010_2\\).</p> Dado um n\u00famero n\u00e3o negativo qualquer na base decimal, descreva o algoritmos para transform\u00e1-lo em um n\u00famero bin\u00e1rio. <p>Como a base 10 n\u00e3o \u00e9 m\u00faltipla de 2, o processo manual \u00e9 mais complicado que com as bases hexadecimal ou octal. Uma das abordagens \u00e9 a de divis\u00f5es sucessivas, onde se divide o n\u00famero por 2, anotando o valor do resto (necessariamente um algarismo bin\u00e1rio). Esse processo \u00e9 repetido para o resultado inteiro da divis\u00e3o, at\u00e9 que haja um resultado da divis\u00e3o que seja zero. Neste ponto, juntam-se os valores dos restos anotados e inverte-se a ordem deles - o resultado ser\u00e1 representa\u00e7\u00e3o do n\u00famero decimal na base bin\u00e1ria. Por exemplo: \\(13_{10} / 2 = 6\\) (resto 1); \\(6_{10} / 2 = 3\\) (resto 0); \\(3_{10} / 2 = 1\\) (resto 1); \\(1_{10} / 2 = 0\\) (resto 1). A sequ\u00eancia de restos \u00e9 \\(1011\\), invertida se torna \\(1101_2 = 1\u00b72\\)^3\\(+ 1\u00b72\\)^2\\(+ 1\u00b72\\)^0\\(= 8 + 4 + 1\\).</p> Dados os bits <code>11</code>, qual o valor inteiro armazenado considerando apenas o sistema posicional, sinal e magnitude, complemento de 1 e complemento de 2? <ul> <li>Sistema posicional: \\(11_2 = 1\u00b72\\)^1\\(+ 1\u00b72\\)^0\\(= 2 + 1 = 3_{10}\\)</li> <li>Sinal e magnitude:  \\(11_2 = -1_2 = -1\u00b72\\)^0\\(= -1_{10}\\)</li> <li>Complemento de um:  \\(11_2 = -1_2 \\overset{inv}{\\rightarrow} -0_2 = -0\u00b72\\)^0\\(= -0_{10}\\)</li> <li>Complemento de dois:  \\(11_2 = -1_2 \\overset{inv}{\\rightarrow} -0_2 \\overset{+1}{\\rightarrow} -1_2 = -1\u00b72\\)^0\\(= -1_{10}\\)</li> </ul> Quais os 4 pontos principais definidos quando consideramos 8 bits para armazenar uma estrutura de dados do tipo <code>inteiro</code>? <ol> <li>O significado \u00e9 de um valor num\u00e9rico inteiro, que pode ser negativo.</li> <li>O valor \u00e9 armazenado como Complemento de 2 nos 8 bits.</li> <li>Os poss\u00edveis valores armazenados est\u00e3o no intervalo \\([-2^7, 2^7) \\equiv [-128, 128)\\).</li> <li>As opera\u00e7\u00f5es aritm\u00e9ticas b\u00e1sicas (\\(+, -, \\times e \\div\\)) est\u00e3o definidas na linguagem de programa\u00e7\u00e3o - e possivelmente outras.</li> </ol> Considerando 4 bits para armazenar um valor inteiro como complemento de 2, o que acontece computar a opera\u00e7\u00e3o \\(5 + 4\\)? <p>Supondo 4 bits, os valores poss\u00edveis de serem armazenados s\u00e3o [-8, 7). Ao somar 4 (<code>0101</code>) e 4 (<code>0100</code>), o resultado seria 9 (<code>1001</code>). Entretanto, como a representa\u00e7\u00e3o \u00e9 de complemento de 2, <code>1001</code> \u00e9 interpretado como -7, um resultado incorreto. O valor calculado ultrapassa a capacidade da representa\u00e7\u00e3o (overflow), e o resultado n\u00e3o \u00e9 o esperado.</p> Considerando 4 bits para armazenar um n\u00famero real como ponto fixo, determine qual a representa\u00e7\u00e3o do valor \\(1,25_{10}\\) como \\(Q1.3\\), \\(Q2.2\\) e \\(Q3.1\\).  <ul> <li>\\(Q1.3 \\Rightarrow 1,25_{10} = 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} + 0\\cdot2^{-3} = 1010_2\\)</li> <li>\\(Q2.2 \\Rightarrow 1,25_{10} = 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} = 0101_2\\)</li> <li>\\(Q3.1\\) n\u00e3o \u00e9 adequado para este valor. Tem-se duas possibilidades:<ul> <li>\\(1,25_{10} \\approx 0\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} = 0001_2 (=1,5_{10})\\)</li> <li>\\(1,25_{10} \\approx 0\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 0\\cdot2^{-2} = 0010_2 (=1,0_{10})\\)</li> </ul> </li> </ul> Se todo n\u00famero inteiro tamb\u00e9m \u00e9 um n\u00famero real, por que as linguagens de programa\u00e7\u00e3o oferecem o tipo de dado <code>int</code> quando existe o tipo de dado <code>float</code>? <p>A manipula\u00e7\u00e3o de um <code>float</code> \u00e9 mais complexa que a de um <code>int</code>, e nos computadores antigos essa complexidade implicava em uma grande diferen\u00e7a de desempenho nas opera\u00e7\u00f5es, principalmente aritm\u00e9ticas - era bem mais eficiente usar <code>int</code>. Nos computadores modernos, a situa\u00e7\u00e3o \u00e9 bem mais difusa e muito dependente dos detalhes de uso tanto do algoritmo quanto da linguagem de programa\u00e7\u00e3o quanto do hardware.</p> Se todo n\u00famero inteiro tamb\u00e9m \u00e9 um n\u00famero real, por que as linguagens de programa\u00e7\u00e3o oferecem o tipo de dado <code>int</code> quando existe o tipo de dado <code>float</code>? <p>A manipula\u00e7\u00e3o de um <code>float</code></p> <ol> <li> <p>Brian W. Kernighan and Dennis M. Ritchie. C: a linguagem de programa\u00e7\u00e3o padr\u00e3o ANSI. Campus, Rio de Janeiro, 1989. ISBN 8570015860 9788570015860.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Aaron M Tenenbaum, Yedidyah Langsam, and Moshe Augenstein. Estruturas de dados usando C. Pearson Makron Books, S\u00e3o Paulo (SP), 1995. ISBN 8534603480 : 9788534603485.\u00a0\u21a9</p> </li> <li> <p>David Goldberg. What every computer scientist should know about floating-point arithmetic. ACM Comput. Surv., 23(1):5\u201348, mar 1991. URL: https://doi.org/10.1145/103162.103163, doi:10.1145/103162.103163.\u00a0\u21a9</p> </li> <li> <p>American National Standards Institute. American National Standard for Information Systems \u2014 Coded Character Sets \u2014 7-Bit American National Standard Code for Information Interchange (7-Bit ASCII), ANSI X3.4-1986. Technical Report, American National Standards Institute, 1896. URL: http://sliderule.mraiow.com/w/images/7/73/ASCII.pdf.\u00a0\u21a9</p> </li> </ol>"},{"location":"programacao/fluxo_de_controle/condicional/","title":"Condicional","text":"<p>exemplo do imc (implica\u00e7\u00f5es matem\u00e1ticas de se n\u00e3o \u00e9 &lt; x, necessariamente \u00e9 &gt;= x)</p> \u00cdndice de Massa Corporal<pre><code>def avalia_imc(m, h):\nimc = calcula_imc(m, h)\nif imc &lt; 18.5:\nprint('Situa\u00e7\u00e3o de magreza!')\nelif imc &lt; 25:\nprint('Situa\u00e7\u00e3o normal.')\nelif imc &lt; 30:\nprint('Situa\u00e7\u00e3o de sobrepeso.')\nelif imc &lt; 40:\nprint('Situa\u00e7\u00e3o de obesidade!')\nelse:\nprint('Situa\u00e7\u00e3o de obesidade grave!!')\n</code></pre> <p>https://realpython.com/python-conditional-statements/#introduction-to-the-if-statement</p> <p>https://realpython.com/python-boolean/</p> <p>Working With Boolean Logic in Python Back in 1854, George Boole authored The Laws of Thought, which contains what\u2019s known as Boolean algebra. This algebra relies on two values: true and false. It also defines a set of Boolean operations, also known as logical operations, denoted by the generic operators AND, OR, and NOT.</p> <p>These Boolean values and operators are pretty helpful in programming. For example, you can construct arbitrarily complex Boolean expressions with the operators and determine their resulting truth value as true or false. You can use the truth value of Boolean expressions to decide the course of action of your programs.</p> <p>In Python, the Boolean type bool is a subclass of int and can take the values True or False:</p> <p>Using Python\u2019s and Operator in Boolean Contexts Like all of Python\u2019s Boolean operators, the and operator is especially useful in Boolean contexts. Boolean contexts are where you\u2019ll find most of the real-world use cases of Boolean operators.</p> <p>Two main structures define Boolean contexts in Python:</p> <p>if statements let you perform conditional execution and take different courses of action based on the result of some initial conditions. while loops let you perform conditional iteration and run repetitive tasks while a given condition is true. These two structures are part of what you\u2019d call control flow statements. They help you decide your programs\u2019 execution path.</p> <p>You can use Python\u2019s and operator to construct compound Boolean expressions in both if statements and while loops.</p> <p>if Statements Boolean expressions are commonly known as conditions because they typically imply the need for meeting a given requirement. They\u2019re pretty useful in the context of conditional statements. In Python, this type of statement starts with the if keyword and continues with a condition. A conditional statement can additionally include elif and else clauses.</p> <p>Python conditional statements follow the logic of conditionals in English grammar. If the condition is true, then the if code block executes. Otherwise, the execution jumps to a different code block:</p> <p>a = -8</p> <p>if a &lt; 0: ...     print(\"a is negative\") ... elif a &gt; 0: ...     print(\"a is positive\") ... else: ...     print(\"a is equal to 0\") ... a is negative Since a holds a negative number, the condition a &lt; 0 is true. The if code block runs, and you get the message a is negative printed on your screen. If you change the value of a to a positive number, however, then the elif block runs and Python prints a is positive. Finally, if you set a to zero, then the else code block executes. Go ahead and play with a to see what happens!</p> <p>Now say you want to make sure that two conditions are met\u2014meaning that they\u2019re both true\u2014before running a certain piece of code. To try this out, suppose you need to get the age of a user running your script, process that information, and display to the user their current life stage.</p> <p>Fire up your favorite code editor or IDE and create the following script:</p>"},{"location":"programacao/fluxo_de_controle/condicional/#agepy","title":"age.py","text":"<p>age = int(input(\"Enter your age: \"))</p> <p>if age &gt;= 0 and age &lt;= 9:     print(\"You are a child!\") elif age &gt; 9 and age &lt;= 18:     print(\"You are an adolescent!\") elif age &gt; 18 and age &lt;= 65:     print(\"You are an adult!\") elif age &gt; 65:     print(\"Golden ages!\") Here, you get the user\u2019s age using input() and then convert it to an integer number with int(). The if clause checks if age is greater than or equal to 0. In the same clause, it checks if age is less than or equal to 9. To do this, you build an and compound Boolean expression.</p> <p>The three elif clauses check other intervals to determine the life stage associated with the user\u2019s age.</p> <p>If you run this script from your command line, then you get something like this:</p> <p>$ python age.py Enter your age: 25 You are an adult! Depending on the age you enter at the command line, the script takes one course of action or another. In this specific example, you provide an age of 25 years and get the message You are an adult! printed to your screen.</p> <p>sing Python\u2019s and Operator in Non-Boolean Contexts The fact that and can return objects besides just True and False is an interesting feature. For example, this feature allows you to use the and operator for conditional execution. Say you need to update a flag variable if the first item in a given list is equal to a certain expected value. For this situation, you can use a conditional statement:</p> <p>a_list = [\"expected value\", \"other value\"] flag = False</p> <p>if len(a_list) &gt; 0 and a_list[0] == \"expected value\": ...     flag = True ...</p> <p>flag True Here, the conditional checks if the list has at least one item. If so, it checks if the first item in the list is equal to the \"expected value\" string. If both checks pass, then flag changes to True. You can simplify this code by taking advantage of the and operator:</p> <p>a_list = [\"expected value\", \"other value\"] flag = False</p> <p>flag = len(a_list) &gt; 0 and a_list[0] == \"expected value\"</p> <p>flag True In this example, the highlighted line does all the work. It checks both conditions and makes the corresponding assignment in one go. This expression takes the and operator out of the if statement you used in the previous example, which means that you\u2019re not working in a Boolean context any longer.</p> <p>The code in the example above is more concise than the equivalent conditional statement you saw before, but it\u2019s less readable. To properly understand this expression, you\u2019d need to be aware of how the and operator works internally.</p> <p>Putting Python\u2019s and Operator Into Action So far, you\u2019ve learned how to use Python\u2019s and operator for creating compound Boolean expressions and non-Boolean expressions. You\u2019ve also learned how to use this logical operator in Boolean contexts like if statements and while loops.</p> <p>In this section, you\u2019ll build a few practical examples that\u2019ll help you decide when to use the and operator. With these examples, you\u2019ll learn how to take advantage of and for writing better and more Pythonic code.</p> <p>Flattening Nested if Statements One principle from the Zen of Python states that \u201cFlat is better than nested.\u201d For example, while code that has two levels of nested if statements is normal and totally okay, your code really starts to look messy and complicated when you have more than two levels of nesting.</p> <p>Say you need to test if a given number is positive. Then, once you confirm that it\u2019s positive, you need to check if the number is lower than a given positive value. If it is, you can proceed with a specific calculation using the number at hand:</p> <p>number = 7</p> <p>if number &gt; 0: ...     if number &lt; 10: ...         # Do some calculation with number... ...         print(\"Calculation done!\") ... Calculation done! Cool! These two nested if statements solve your problem. You first check if the number is positive and then check if it\u2019s lower than 10. In this small example, the call to print() is a placeholder for your specific calculation, which runs only if both conditions are true.</p> <p>Even though the code works, it\u2019d be nice to make it more Pythonic by removing the nested if. How can you do that? Well, you can use the and operator to combine both conditions in a single compound condition:</p> <p>number = 7</p> <p>if number &gt; 0 and number &lt; 10: ...     # Do some calculation with number... ...     print(\"Calculation done!\") ... Calculation done! Logical operators like the and operator often provide an effective way to improve your code by removing nested conditional statements. Take advantage of them whenever possible.</p> <p>In this specific example, you use and to create a compound expression that checks if a number is in a given range or interval. Python provides an even better way to perform this check by chaining expressions. For example, you can write the condition above as 0 &lt; number &lt; 10. That\u2019s a topic for the following section.</p> <p>Checking Numeric Ranges With a close look at the example in the section below, you can conclude that Python\u2019s and operator is a convenient tool for checking if a specific numeric value is inside a given interval or range. For example, the following expressions check if a number x is between 0 and 10, both inclusive:</p> <p>x = 5 x &gt;= 0 and x &lt;= 10 True</p> <p>x = 20 x &gt;= 0 and x &lt;= 10 False In the first expression, the and operator first checks if x is greater than or equal to 0. Since the condition is true, the and operator checks if x is lower than or equal to 10. The final result is true because the second condition is also true. This means that the number is within the desired interval.</p> <p>In the second example, the first condition is true, but the second is false. The general result is false, which means the number isn\u2019t in the target interval.</p> <p>You can enclose this logic in a function and make it reusable:</p> <p>def is_between(number, start=0, end=10): ...     return number &gt;= start and number &lt;= end ...</p> <p>is_between(5) True is_between(20) False</p> <p>is_between(20, 10, 40) True In this example, is_between() takes number as an argument. It also takes start and end, which define the target interval. Note that these arguments have default argument values, which means they\u2019re optional arguments.</p> <p>Your is_between() function returns the result of evaluating an and expression that checks if number is between start and end, both inclusive.</p> <p>Note: Unintentionally writing and expressions that always return False is a common mistake. Suppose you want to write an expression that excludes values between 0 and 10 from a given computation.</p> <p>To achieve this result, you start with two Boolean expressions:</p> <p>number &lt; 0 number &gt; 10 With these two expressions as a starting point, you think of using and to combine them in a single compound expression. However, no number is lower than 0 and greater than 10 at the same time, so you end up with an always-false condition:</p> <p>for number in range(-100, 100): ...     included = number &lt; 0 and number &gt; 10 ...     print(f\"Is {number} included?\", included) ... Is -100 included? False Is -99 included? False</p> <p>...</p> <p>Is 0 included? False Is 1 included? False</p> <p>...</p> <p>Is 98 included? False Is 99 included? False In this case, and is the wrong logical operator to approach the problem at hand. You should use the or operator instead. Go ahead and give it a try!</p> <p>Even though using the and operator allows you to check gracefully if a number is within a given interval, there\u2019s a more Pythonic technique to approach the same problem. In mathematics, you can write 0 &lt; x &lt; 10 to denote that x is between 0 and 10.</p> <p>In most programming languages, this expression doesn\u2019t make sense. In Python, however, the expression works like a charm:</p> <p>x = 5 0 &lt; x &lt; 10 True</p> <p>x = 20 0 &lt; x &lt; 10 False In a different programming language, this expression would start by evaluating 0 &lt; x, which is true. The next step would be to compare the true Boolean with 10, which doesn\u2019t make much sense, so the expression fails. In Python, something different happens.</p> <p>Python internally rewrites this type of expression to an equivalent and expression, such as x &gt; 0 and x &lt; 10. It then performs the actual evaluation. That\u2019s why you get the correct result in the example above.</p> <p>Just like you can chain several subexpressions with multiple and operators, you can also chain them without explicitly using any and operators:</p> <p>x = 5 y = 15</p> <p>0 &lt; x &lt; 10 &lt; y &lt; 20 True</p> <p>Python\u2019s and operator allows you to construct compound Boolean expressions that you can use to decide the course of action of your programs. You can use the and operator to solve several problems both in Boolean or non-Boolean contexts. Learning about how to use the and operator properly can help you write more Pythonic code.</p> <p>In this tutorial, you learned how to:</p> <p>Work with Python\u2019s and operator Build Boolean and non-Boolean expressions with Python\u2019s and operator Decide the course of action of your programs using the and operator in Boolean contexts Make your code more concise using the and operator in non-Boolean contexts Going through the practical examples in this tutorial can help you get a general idea of how to use the and operator to make decisions in your Python code.</p> <p>O uso de condicionais \u00e9 baseado no valores booleanos \\(verdadeiro\\) e \\(falso\\). Estes s\u00e3o os valores verdade da l\u00f3gica matem\u00e1tica, e indicam o grau de verdade de uma proposi\u00e7\u00e3o. Por exemplo, considerando os n\u00fameros inteiros 42 e 100, podemos a propor que \\(42 &lt; 100\\) e verificar que isto \u00e9 verdadeiro. As linguagens de programa\u00e7\u00e3o podem oferecer um tipo de dado espec\u00edfico para estes valores ou interpretar outros tipos de dados como um dos dois resultados poss\u00edveis. Por exemplo, a linguagem C n\u00e3o tem um tipo primitivo e interpreta o valor num\u00e9rico zero como o valor booleano \\(falso\\), e qualquer valor diferente disso como \\(verdadeiro\\). J\u00e1 Python tem o tipo bool, mas tamb\u00e9m interpreta uma s\u00e9rie de outros tipos de dados.</p> <p><code>&lt;expr&gt;</code> \u00e9 uma express\u00e3o cujo valor resultante tem um significado booleano, ou seja, \u00e9 verdadeiro ou falso.</p> <p>https://realpython.com/python-boolean/  Logical Operators in the Operators and Expressions in Python tutorial.  is a valid Python statement, which must be indented. (You will see why very soon.) If  is true (evaluates to a value that is \u201ctruthy\u201d), then  is executed. If  is false, then  is skipped over and not executed. <p>Note that the colon (:) following  is required. Some programming languages require  to be enclosed in parentheses, but Python does not. <p>Here are several examples of this type of if statement:</p> PythonC Estrutura condicional<pre><code>if &lt;expr&gt;:\n&lt;instr&gt;\n</code></pre> Estrutura condicional<pre><code>if (&lt;expr&gt;) {\n&lt;instr&gt;;\n}\n</code></pre> Exerc\u00edcios <p>https://realpython.com/quizzes/python-conditional-statements/viewer/</p> <p>In a Python program, a control structure:</p> <p>Defines program-specific data structures Manages the input and output of control characters Dictates what happens before the program starts and after it terminates * Directs the order of execution of the statements in the program</p> <p>Control structures determine which statements in the program will be executed and in what order, allowing for statements to be skipped over or executed repeatedly.</p> <p>if, if/else, and if/elif/else statements are all examples of control structures that allow for statements to be skipped over or executed conditionally:</p> <p>if :      <p>if :      else:      <p>if :      elif :      elif :          ... else:      The order of execution of statements in a program is called control flow."},{"location":"programacao/fluxo_de_controle/condicional/#equivalent-and-expression","title":"Equivalent and expression","text":"<p>0 &lt; x and x &lt; 10 and 10 &lt; y and y &lt; 20 True You can also use this Python trick to check if several values are equal:</p> <p>x = 10 y = 10 z = 10</p> <p>x == y == z True</p>"},{"location":"programacao/fluxo_de_controle/condicional/#equivalent-and-expression_1","title":"Equivalent and expression","text":"<p>x == y and y == z True Chained comparison expressions are a nice feature, and you can write them in various ways. However, you should be careful. In some cases, the final expression can be challenging to read and understand, especially for programmers coming from languages in which this feature isn\u2019t available.</p>"},{"location":"programacao/fluxo_de_controle/funcoes/","title":"Fun\u00e7\u00f5es","text":"<p>Joe Sondow</p> <p>Um computador \u00e9 como um g\u00eanio travesso. Te d\u00e1 exatamente o que voc\u00ea pede dele, mas nem sempre o que voc\u00ea quer.</p> <p>Programas de computadores geralmente usam procedimentos que especificam como fazer algo1. Nas linguagens de programa\u00e7\u00e3o, estes s\u00e3o chamados de fun\u00e7\u00f5es (ou m\u00e9todos), e s\u00e3o chamados para serem executados. Ao chamar um procedimento, pode-se fornecer informa\u00e7\u00f5es necess\u00e1rias para a computa\u00e7\u00e3o ao definir par\u00e2metros, e receber (ou n\u00e3o) resultados como um valor de retorno.</p> Exerc\u00edcios Descreva os componentes f\u00edsicos de um computador e suas funcionalidades. <p>A unidade central de processamento \u00e9 o dispositivo que interpreta e executa e instru\u00e7\u00f5es, l\u00ea e escreve a mem\u00f3ria, tendo como parte integrante os registradores que armazenam os dados sendo processados no momento. Mem\u00f3ria permite armazenar dados em um conjunto ordenado de bits.</p> <p>Os dispositivos de entrada e sa\u00edda de dados permitem que humanos e outras m\u00e1quinas se comunica\u00e7\u00e3o com o computador. Exemplos de dispositivos de entrada s\u00e3o: teclado, mouse, microfone, scanner, leitor de c\u00f3digo de barras, c\u00e2mera, joystick, etc. Exemplos de sa\u00edda s\u00e3o: monitor, caixas de som, impressora, etc. H\u00e1 dispositivos que fazem ambas: disco r\u00edgido, monitor sens\u00edvel a toques, pendrive, etc.</p> <p>O barramento \u00e9 o sistema de comunica\u00e7\u00e3o que transfere dados entre os componentes do computador (a taxa de transfer\u00eancia do barramento \u00e9 o que define o desempenho da m\u00e1quina). A fonte de alimenta\u00e7\u00e3o regula a distribui\u00e7\u00e3o de energia para os componentes. A placa m\u00e3e conecta os componentes do computador ao barramento e \u00e0 fonte.</p> <ol> <li> <p>Thomas H. Cormen. Algorithms Unlocked. The MIT Press, 2013. ISBN 9780262518802. URL: https://mitpress.mit.edu/9780262518802/algorithms-unlocked/.\u00a0\u21a9</p> </li> </ol>"},{"location":"programacao/fluxo_de_controle/repeticao/","title":"Repeti\u00e7\u00e3o","text":"Exerc\u00edcios Implemente o c\u00f3digo que leia a quantidade m\u00e1xima N de elefantes e apresente a letra da m\u00fasica at\u00e9 que N (\u22651) elefantes incomodem muita gente. Por exemplo, para N = 4: 1 elefante incomoda muita gente... 2 elefantes incomodam, incomodam muito mais! 2 elefantes incomodam muita gente... 3 elefantes incomodam, incomodam, incomodam muito mais! 3 elefantes incomodam muita gente... 4 elefantes incomodam, incomodam, incomodam, incomodam muito mais! <p>Uma poss\u00edvel solu\u00e7\u00e3o \u00e9: Elefantes<pre><code>n = int(input('Digite a quantidade de elefantes: '))\nprint('1 elefante incomoda muita gente...')\nprint('2 elefantes incomodam, incomodam muito mais!')\nfor e in range(2, n):\nprint(f'{e} elefantes incomodam muita gente...')\nincomodam = ', incomodam' * e\nprint(f'{e + 1} elefantes incomodam{incomodam} muito mais!')\n</code></pre></p> Considerando um comprimento L, implemente o c\u00f3digo que desenha um quadrado de lado L. <p>Uma poss\u00edvel solu\u00e7\u00e3o \u00e9: Quadrado<pre><code>from tartaruga import *\nfor _ in range(4):\nfrente(L)\ndireita(90)\n</code></pre></p> <p>https://blockly.games/turtle?lang=pt-br</p> <p>while Loops The while loop is the second construct that can use and expressions to control a program\u2019s execution flow. By using the and operator in the while statement header, you can test several conditions and repeat the loop\u2019s code block for as long as all conditions are met.</p> <p>Say you\u2019re prototyping a control system for a manufacturer. The system has a critical mechanism that should work with a pressure of 500 psi or lower. If the pressure goes over 500 psi while staying under 700 psi, then the system has to run a given series of standard safety actions. For pressures greater than 700 psi, there are a whole new set of safety actions that the system must run.</p> <p>To approach this problem, you can use a while loop with an and expression. Here\u2019s a script that simulates a possible solution:</p> <p>1# pressure.py  2  3from time import sleep  4from random import randint  5  6def control_pressure():  7    pressure = measure_pressure()  8    while True:  9        if pressure &lt;= 500: 10            break 11 12        while pressure &gt; 500 and pressure &lt;= 700: 13            run_standard_safeties() 14            pressure = measure_pressure() 15 16        while pressure &gt; 700: 17            run_critical_safeties() 18            pressure = measure_pressure() 19 20    print(\"Wow! The system is safe...\") 21 22def measure_pressure(): 23    pressure = randint(490, 800) 24    print(f\"psi={pressure}\", end=\"; \") 25    return pressure 26 27def run_standard_safeties(): 28    print(\"Running standard safeties...\") 29    sleep(0.2) 30 31def run_critical_safeties(): 32    print(\"Running critical safeties...\") 33    sleep(0.7) 34 35if name == \"main\": 36    control_pressure() Inside control_pressure(), you create an infinite while loop on line 8. If the system is stable and the pressure is below 500 psi, the conditional statement breaks out of the loop and the program finishes.</p> <p>On line 12, the first nested while loop runs the standard safety actions while the system pressure stays between 500 psi and 700 psi. In each iteration, the loop gets a new pressure measurement to test the condition again in the next iteration. If the pressure grows beyond 700 psi, then the second loop on line 16 runs the critical safety actions.</p> <p>Note: The implementation of control_pressure() in the example above is intended to show how the and operator can work in the context of a while loop.</p> <p>However, this isn\u2019t the most efficient implementation you can write. You can refactor control_pressure() to use a single loop without using and:</p> <p>def control_pressure():     while True:         pressure = measure_pressure()         if pressure &gt; 700:             run_critical_safeties()         elif 500 &lt; pressure &lt;= 700:             run_standard_safeties()         elif pressure &lt;= 500:             break     print(\"Wow! The system is safe...\") In this alternative implementation, instead of using and, you use the chained expression 500 &lt; pressure &lt;= 700, which does the same as pressure &gt; 500 and pressure &lt;= 700 but is cleaner and more Pythonic. Another advantage is that you call measure_pressure() only once, which ends up being more efficient.</p>"},{"location":"programacao/fluxo_de_controle/sequencial/","title":"Sequencial","text":""},{"location":"programacao/tipos_de_dados/booleanos/","title":"Booleanos","text":""},{"location":"programacao/tipos_de_dados/booleanos/#booleanos","title":"Booleanos","text":""},{"location":"programacao/tipos_de_dados/exercicios/","title":"Exercicios","text":"Exerc\u00edcios Dado um n\u00famero n\u00e3o negativo qualquer na base hexadecimal, descreva o algoritmos para transform\u00e1-lo em um n\u00famero bin\u00e1rio. <p>Como a base 16 \u00e9 m\u00faltipla de 2, o processo manual \u00e9 bem simples. Cada algarismo hexadecimal pode ser diretamente mapeado para seu valor bin\u00e1rio de 4 bits, na mesma ordem. Por exemplo, para \\(2A_{16}\\) temos que \\(2_{16} \\rightarrow 0010_2\\) e \\(A_{16} \\rightarrow 1010_2\\), portanto \\(2A_{16}\\rightarrow 00101010_2\\).</p> Dado um n\u00famero n\u00e3o negativo qualquer na base hexadecimal, descreva o algoritmos para transform\u00e1-lo em um n\u00famero bin\u00e1rio. <p>Como a base 16 \u00e9 m\u00faltipla de 2, o processo manual \u00e9 bem simples. Cada algarismo hexadecimal pode ser diretamente mapeado para seu valor bin\u00e1rio de 4 bits, na mesma ordem. Por exemplo, para \\(2A_{16}\\) temos que \\(2_{16} \\rightarrow 0010_2\\) e \\(A_{16} \\rightarrow 1010_2\\), portanto \\(2A_{16}\\rightarrow 00101010_2\\).</p> Dado um n\u00famero n\u00e3o negativo qualquer na base decimal, descreva o algoritmos para transform\u00e1-lo em um n\u00famero bin\u00e1rio. <p>Como a base 10 n\u00e3o \u00e9 m\u00faltipla de 2, o processo manual \u00e9 mais complicado que com as bases hexadecimal ou octal. Uma das abordagens \u00e9 a de divis\u00f5es sucessivas, onde se divide o n\u00famero por 2, anotando o valor do resto (necessariamente um algarismo bin\u00e1rio). Esse processo \u00e9 repetido para o resultado inteiro da divis\u00e3o, at\u00e9 que haja um resultado da divis\u00e3o que seja zero. Neste ponto, juntam-se os valores dos restos anotados e inverte-se a ordem deles - o resultado ser\u00e1 representa\u00e7\u00e3o do n\u00famero decimal na base bin\u00e1ria. Por exemplo: \\(13_{10} / 2 = 6\\) (resto 1); \\(6_{10} / 2 = 3\\) (resto 0); \\(3_{10} / 2 = 1\\) (resto 1); \\(1_{10} / 2 = 0\\) (resto 1). A sequ\u00eancia de restos \u00e9 \\(1011\\), invertida se torna \\(1101_2 = 1\u00b72\\)^3\\(+ 1\u00b72\\)^2\\(+ 1\u00b72\\)^0\\(= 8 + 4 + 1\\).</p> Dados os bits <code>11</code>, qual o valor inteiro armazenado considerando apenas o sistema posicional, sinal e magnitude, complemento de 1 e complemento de 2? <ul> <li>Sistema posicional: \\(11_2 = 1\u00b72\\)^1\\(+ 1\u00b72\\)^0\\(= 2 + 1 = 3_{10}\\)</li> <li>Sinal e magnitude:  \\(11_2 = -1_2 = -1\u00b72\\)^0\\(= -1_{10}\\)</li> <li>Complemento de um:  \\(11_2 = -1_2 \\overset{inv}{\\rightarrow} -0_2 = -0\u00b72\\)^0\\(= -0_{10}\\)</li> <li>Complemento de dois:  \\(11_2 = -1_2 \\overset{inv}{\\rightarrow} -0_2 \\overset{+1}{\\rightarrow} -1_2 = -1\u00b72\\)^0\\(= -1_{10}\\)</li> </ul> Quais os 4 pontos principais definidos quando consideramos 8 bits para armazenar uma estrutura de dados do tipo <code>inteiro</code>? <ol> <li>O significado \u00e9 de um valor num\u00e9rico inteiro, que pode ser negativo.</li> <li>O valor \u00e9 armazenado como Complemento de 2 nos 8 bits.</li> <li>Os poss\u00edveis valores armazenados est\u00e3o no intervalo \\([-2^7, 2^7) \\equiv [-128, 128)\\).</li> <li>As opera\u00e7\u00f5es aritm\u00e9ticas b\u00e1sicas (\\(+, -, \\times e \\div\\)) est\u00e3o definidas na linguagem de programa\u00e7\u00e3o - e possivelmente outras.</li> </ol> Considerando 4 bits para armazenar um valor inteiro como complemento de 2, o que acontece computar a opera\u00e7\u00e3o \\(5 + 4\\)? <p>Supondo 4 bits, os valores poss\u00edveis de serem armazenados s\u00e3o [-8, 7). Ao somar 4 (<code>0101</code>) e 4 (<code>0100</code>), o resultado seria 9 (<code>1001</code>). Entretanto, como a representa\u00e7\u00e3o \u00e9 de complemento de 2, <code>1001</code> \u00e9 interpretado como -7, um resultado incorreto. O valor calculado ultrapassa a capacidade da representa\u00e7\u00e3o (overflow), e o resultado n\u00e3o \u00e9 o esperado.</p> Considerando 4 bits para armazenar um n\u00famero real como ponto fixo, determine qual a representa\u00e7\u00e3o do valor \\(1,25_{10}\\) como \\(Q1.3\\), \\(Q2.2\\) e \\(Q3.1\\).  <ul> <li>\\(Q1.3 \\Rightarrow 1,25_{10} = 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} + 0\\cdot2^{-3} = 1010_2\\)</li> <li>\\(Q2.2 \\Rightarrow 1,25_{10} = 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} = 0101_2\\)</li> <li>\\(Q3.1\\) n\u00e3o \u00e9 adequado para este valor. Tem-se duas possibilidades:<ul> <li>\\(1,25_{10} \\approx 0\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} = 0001_2 (=1,5_{10})\\)</li> <li>\\(1,25_{10} \\approx 0\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 0\\cdot2^{-2} = 0010_2 (=1,0_{10})\\)</li> </ul> </li> </ul> Se todo n\u00famero inteiro tamb\u00e9m \u00e9 um n\u00famero real, por que as linguagens de programa\u00e7\u00e3o oferecem o tipo de dado <code>int</code> quando existe o tipo de dado <code>float</code>? <p>A manipula\u00e7\u00e3o de um <code>float</code> \u00e9 mais complexa que a de um <code>int</code>, e nos computadores antigos essa complexidade implicava em uma grande diferen\u00e7a de desempenho nas opera\u00e7\u00f5es, principalmente aritm\u00e9ticas - era bem mais eficiente usar <code>int</code>. Nos computadores modernos, a situa\u00e7\u00e3o \u00e9 bem mais difusa e muito dependente dos detalhes de uso tanto do algoritmo quanto da linguagem de programa\u00e7\u00e3o quanto do hardware.</p> Se todo n\u00famero inteiro tamb\u00e9m \u00e9 um n\u00famero real, por que as linguagens de programa\u00e7\u00e3o oferecem o tipo de dado <code>int</code> quando existe o tipo de dado <code>float</code>? <p>A manipula\u00e7\u00e3o de um <code>float</code></p>"},{"location":"programacao/tipos_de_dados/inteiros/","title":"Inteiros","text":""},{"location":"programacao/tipos_de_dados/inteiros/#numeros-inteiros","title":"N\u00fameros Inteiros","text":"<p>J\u00e1 vimos a representa\u00e7\u00e3o dos n\u00fameros naturais em bin\u00e1rio. Entretanto, muitas problemas lidam com os n\u00fameros inteiros, que podem ter valores negativos. Felizmente, um n\u00famero s\u00f3 pode ser negativo ou n\u00e3o, ou seja, a informa\u00e7\u00e3o do sinal \u00e9 facilmente representada em um bit. A conven\u00e7\u00e3o \u00e9 que o bit mais a esquerda armazena a informa\u00e7\u00e3o se o n\u00famero \u00e9 negativo (ligado/1) ou se \u00e9 positivo (desligado/0), e os demais bits armazenam a informa\u00e7\u00e3o do valor do n\u00famero. H\u00e1 formas distintas de se interpretar este \u00faltimo conjunto de bits, como listadas a seguir.</p> <p>Sinal e Magnitude, onde o bit mais significativo indica o sinal e os demais bits determinam o valor diretamente pela nota\u00e7\u00e3o posicional (como um n\u00famero natural). Esta abordagem \u00e9 intuitivamente simples para entendermos.</p> <p> bits sinal nota\u00e7\u00e3o posicional decimal 000 +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 \\(-(0\u00b72^1+ 0\u00b72^0)\\) -0 101 -01 \\(-(0\u00b72^1+ 1\u00b72^0)\\) -1 110 -10 \\(-(1\u00b72^1+ 0\u00b72^0)\\) -2 111 -11 \\(-(1\u00b72^1+ 1\u00b72^0)\\) -3 <p></p> <p>Complemento de um tamb\u00e9m considera o bit mais a esquerda como indicador de sinal e os demais para o valor, conforme o sinal. Se positivo, os bits restantes indicam o valor pela nota\u00e7\u00e3o posicional (como na abordagem de sinal e magnitude); se negativo, \u00e9 preciso inverter todos os bits antes de considerar a nota\u00e7\u00e3o posicional. Esta varia\u00e7\u00e3o \u00e9 um pouco mais complexa para entendermos, mas tem vantagens quanto \u00e0 anterior para algumas opera\u00e7\u00f5es. Uma delas \u00e9 que precisa-se de menos esfor\u00e7o para para inverter o sinal de um valor, uma opera\u00e7\u00e3o muito frequente em problemas computacionais. Usando complemento de um, basta inverter todos os bits.</p> <p> bits sinal inverte? nota\u00e7\u00e3o posicional decimal 000 +00 n\u00e3o +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 n\u00e3o +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 n\u00e3o +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 n\u00e3o +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 sim -11 \\(-(1\u00b72^1+ 1\u00b72^0)\\) -3 101 -01 sim -10 \\(-(1\u00b72^1+ 0\u00b72^0)\\) -2 110 -10 sim -01 \\(-(0\u00b72^1+ 1\u00b72^0)\\) -1 111 -11 sim -00 \\(-(0\u00b72^1+ 0\u00b72^0)\\) -0 <p></p> <p>Por fim, a forma mais utilizada \u00e9 complemento de dois. Nela, tamb\u00e9m o bit mais a esquerda define o sinal e os demais determinam o valor conforme o sinal. Se positivo, os bits restantes indicam o valor pela nota\u00e7\u00e3o posicional; se negativo, \u00e9 preciso inverter todos os bits e incrementar em 1 o resultado antes de considerar a nota\u00e7\u00e3o posicional. Embora mais complicada para n\u00f3s, esta abordagem tem vantagens sobre as demais, como quantidade de valores distintos que se pode armazenar e facilidade na computa\u00e7\u00e3o de opera\u00e7\u00f5es aritm\u00e9ticas.</p> <p> bits sinal inverte? +1 nota\u00e7\u00e3o posicional decimal 000 +00 n\u00e3o +00 n\u00e3o +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 n\u00e3o +01 n\u00e3o +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 n\u00e3o +10 n\u00e3o +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 n\u00e3o +11 n\u00e3o +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 sim -11 sim -100 \\(-(1\u00b72^2+ 0\u00b72^1+ 0\u00b72^0)\\) -4 101 -01 sim -10 sim -011 \\(-(0\u00b72^2+ 1\u00b72^1+ 1\u00b72^0)\\) -3 110 -10 sim -01 sim -010 \\(-(0\u00b72^2+ 1\u00b72^1+ 0\u00b72^0)\\) -2 111 -11 sim -00 sim -001 \\(-(0\u00b72^2+ 0\u00b72^1+ 1\u00b72^0)\\) -1 <p></p> <p>Geralmente, valores inteiros s\u00e3o armazenados em um tipo de dado <code>inteiro</code> de 32 ou 64 bits. Considerando o primeiro caso, a estrutura de dados para complemento de dois determina:</p> <ol> <li>O significado \u00e9 de um valor num\u00e9rico inteiro, que pode ser negativo.</li> <li>O valor \u00e9 armazenado como Complemento de 2 nos 32 bits.</li> <li>Os poss\u00edveis valores armazenados est\u00e3o no intervalo \\([-2^{31}, 2^{31})\\).</li> <li>As opera\u00e7\u00f5es aritm\u00e9ticas b\u00e1sicas (\\(+, -, \\times\\ e\\ \\div\\)) est\u00e3o definidas na linguagem de programa\u00e7\u00e3o - e possivelmente outras.</li> </ol>"},{"location":"programacao/tipos_de_dados/numericos/","title":"Numericos","text":"N\u00fameros <p>Um n\u00famero \u00e9 um objeto matem\u00e1tico usado para descrever uma quantidade, e uma base num\u00e9rica \u00e9 um conjunto de algarismos utilizados para representar um n\u00famero. Quais s\u00e3o os s\u00edmbolos e as regras de como utiliz\u00e1-los s\u00e3o definidos pelos sistema de numera\u00e7\u00e3o usado. O valor de um n\u00famero \u00e9 \u00fanico, mas sua representa\u00e7\u00e3o pode variar conforme o sistema utilizado - \u00e9 f\u00e1cil ilustrar isso comparando o abordagem usamos normalmente, com algarismos ar\u00e1bicos e a nota\u00e7\u00e3o posicional, \u00e0 abordagem que os antigos romanos usavam. Para o valor quarenta e nove, temos as representa\u00e7\u00f5es \\(49\\) e \\(XLIX\\), respectivamente.</p> <p>Na nota\u00e7\u00e3o posicional, o valor representado por um algarismo depende da posi\u00e7\u00e3o em que ele se encontra no conjunto de s\u00edmbolos que representa o n\u00famero, sendo valores a esquerda mais influentes que os a direita. O valor deste n\u00famero \u00e9 determinado pela soma dos valores relativos de cada algarismo. Por exemplo: 123 = 100 + 20 + 3, o algarismo mais a esquerda (1) tem uma influ\u00eancia maior que os demais no valor, e \u00e9 considerado o mais significativo. O algarismo seguinte (2) tem uma influ\u00eancia menor que o anterior, mas maior que o seguinte. Isso se sucede at\u00e9 o \u00faltimo algarismo, o mais a direita, que \u00e9 chamado de menos significativo. Podemos reescrever a informa\u00e7\u00e3o da seguinte forma:</p> \\[123 = 100 + 20 + 3 = 1\u00b710^2+ 2\u00b710^1+ 3\u00b710^0\\] <p>Nesta representa\u00e7\u00e3o, duas coisas se destacam. A primeira \u00e9 que a influ\u00eancia de cada algarismo \u00e9 determinada por uma pot\u00eancia de 10, que \u00e9 a base num\u00e9rica. A segunda, \u00e9 que esta pot\u00eancia \u00e9 uma sequ\u00eancia crescente da posi\u00e7\u00e3o menos significativa para a mais significativa, iniciando-se por 0. De forma mais gen\u00e9rica, um algarismo \\(A\\) tem uma influ\u00eancia proporcional a sua posi\u00e7\u00e3o \\(i\\) para uma base num\u00e9rica \\(B\\).</p> \\[A\u00b7{B^i}\\] <p>No valor 123, na base decimal, entendemos seu valor pela soma de seus componentes. O algarismo 3 est\u00e1 na posi\u00e7\u00e3o mais a direita, considerada como posi\u00e7\u00e3o \\(i = 0\\), portanto seu peso no valor resultante \u00e9 de 3\u00b710\\(^0\\). A posi\u00e7\u00e3o seguinte (a esquerda) \u00e9 i = 1 com o algarismo 2, acrescentando 2\u00b710\\(^1\\) ao resultado. O \u00faltimo algarismo (mais a esquerda) \u00e9 1 e est\u00e1 na posi\u00e7\u00e3o 2, acrescentando 1\u00b710\\(^2\\). De forma gen\u00e9rica, o valor de um n\u00famero em uma base num\u00e9rica \\(B\\) qualquer, representado com \\(n\\) algarismos \\(A_i : A \\in [0, B), i \\in [0, n)\\), \u00e9 calculado com a seguinte f\u00f3rmula:</p> \\[A_{n-1}A_{n-2}\u2026{A_2}A_1A_0 = \\sum\\limits_{i=0}^{n - 1}{A_i\u00b7{B^i}}\\] <p>Para representar a informa\u00e7\u00e3o num\u00e9rica na mem\u00f3ria do computador, ela necessariamente deve ser representada como um conjunto de bits. Isto \u00e9 relativamente simples, o bit tem dois estados, 0/1 que s\u00e3o os algarismos da base num\u00e9rica bin\u00e1ria. Portanto, podemos usar esta base na nota\u00e7\u00e3o posicional para basta representar um valor num\u00e9rico qualquer como bits na mem\u00f3ria. Como tamb\u00e9m usaremos algarismos ar\u00e1bicos, para diferenciar as bases num\u00e9ricas acrescentamos um sufixo ao n\u00famero.</p> \\[1101_2 = 1\u00b72^3+ 1\u00b72^2+ 0\u00b72^1+ 1\u00b72^0 = 8 + 4 + 0 + 1 = 13_{10}\\] <p>Por ser uma base de valor baixo, s\u00e3o poucos os algarismos e, portanto, as representa\u00e7\u00f5es dos n\u00fameros se tornam extensas. Outras bases de valor mais elevado permitem compactar isso, e as mais \u00fateis s\u00e3o as m\u00faltiplas de 2 j\u00e1 que a convers\u00e3o delas para a bin\u00e1ria \u00e9 simplificada. A tabela abaixo mostra alguns valores nas bases mais comuns na computa\u00e7\u00e3o: bin\u00e1ria, octal, decimal e hexadecimal. Note que, como a nota\u00e7\u00e3o posicional utiliza apenas um s\u00edmbolo por posi\u00e7\u00e3o, a base hexadecimal define os valores superiores a 9 (o maior algarismo ar\u00e1bico) para letras do alfabeto latino.</p> <p> bin\u00e1ria octal decimal hexadecimal 0 0 0 0 1 1 1 1 10 2 2 2 11 3 3 3 100 4 4 4 101 5 5 5 110 6 6 6 111 7 7 7 1000 10 8 8 1001 11 9 9 1010 12 10 A 1011 13 11 B 1100 14 12 C 1101 15 13 D 1110 16 14 E 1111 17 15 F 101010 52 42 2A 1111011 173 123 7B <p></p>"},{"location":"programacao/tipos_de_dados/numericos/#numeros-inteiros","title":"N\u00fameros Inteiros","text":"<p>J\u00e1 vimos a representa\u00e7\u00e3o dos n\u00fameros naturais em bin\u00e1rio. Entretanto, muitas problemas lidam com os n\u00fameros inteiros, que podem ter valores negativos. Felizmente, um n\u00famero s\u00f3 pode ser negativo ou n\u00e3o, ou seja, a informa\u00e7\u00e3o do sinal \u00e9 facilmente representada em um bit. A conven\u00e7\u00e3o \u00e9 que o bit mais a esquerda armazena a informa\u00e7\u00e3o se o n\u00famero \u00e9 negativo (ligado/1) ou se \u00e9 positivo (desligado/0), e os demais bits armazenam a informa\u00e7\u00e3o do valor do n\u00famero. H\u00e1 formas distintas de se interpretar este \u00faltimo conjunto de bits, como listadas a seguir.</p> <p>Sinal e Magnitude, onde o bit mais significativo indica o sinal e os demais bits determinam o valor diretamente pela nota\u00e7\u00e3o posicional (como um n\u00famero natural). Esta abordagem \u00e9 intuitivamente simples para entendermos.</p> <p> bits sinal nota\u00e7\u00e3o posicional decimal 000 +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 \\(-(0\u00b72^1+ 0\u00b72^0)\\) -0 101 -01 \\(-(0\u00b72^1+ 1\u00b72^0)\\) -1 110 -10 \\(-(1\u00b72^1+ 0\u00b72^0)\\) -2 111 -11 \\(-(1\u00b72^1+ 1\u00b72^0)\\) -3 <p></p> <p>Complemento de um tamb\u00e9m considera o bit mais a esquerda como indicador de sinal e os demais para o valor, conforme o sinal. Se positivo, os bits restantes indicam o valor pela nota\u00e7\u00e3o posicional (como na abordagem de sinal e magnitude); se negativo, \u00e9 preciso inverter todos os bits antes de considerar a nota\u00e7\u00e3o posicional. Esta varia\u00e7\u00e3o \u00e9 um pouco mais complexa para entendermos, mas tem vantagens quanto \u00e0 anterior para algumas opera\u00e7\u00f5es. Uma delas \u00e9 que precisa-se de menos esfor\u00e7o para para inverter o sinal de um valor, uma opera\u00e7\u00e3o muito frequente em problemas computacionais. Usando complemento de um, basta inverter todos os bits.</p> <p> bits sinal inverte? nota\u00e7\u00e3o posicional decimal 000 +00 n\u00e3o +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 n\u00e3o +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 n\u00e3o +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 n\u00e3o +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 sim -11 \\(-(1\u00b72^1+ 1\u00b72^0)\\) -3 101 -01 sim -10 \\(-(1\u00b72^1+ 0\u00b72^0)\\) -2 110 -10 sim -01 \\(-(0\u00b72^1+ 1\u00b72^0)\\) -1 111 -11 sim -00 \\(-(0\u00b72^1+ 0\u00b72^0)\\) -0 <p></p> <p>Por fim, a forma mais utilizada \u00e9 complemento de dois. Nela, tamb\u00e9m o bit mais a esquerda define o sinal e os demais determinam o valor conforme o sinal. Se positivo, os bits restantes indicam o valor pela nota\u00e7\u00e3o posicional; se negativo, \u00e9 preciso inverter todos os bits e incrementar em 1 o resultado antes de considerar a nota\u00e7\u00e3o posicional. Embora mais complicada para n\u00f3s, esta abordagem tem vantagens sobre as demais, como quantidade de valores distintos que se pode armazenar e facilidade na computa\u00e7\u00e3o de opera\u00e7\u00f5es aritm\u00e9ticas.</p> <p> bits sinal inverte? +1 nota\u00e7\u00e3o posicional decimal 000 +00 n\u00e3o +00 n\u00e3o +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 n\u00e3o +01 n\u00e3o +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 n\u00e3o +10 n\u00e3o +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 n\u00e3o +11 n\u00e3o +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 sim -11 sim -100 \\(-(1\u00b72^2+ 0\u00b72^1+ 0\u00b72^0)\\) -4 101 -01 sim -10 sim -011 \\(-(0\u00b72^2+ 1\u00b72^1+ 1\u00b72^0)\\) -3 110 -10 sim -01 sim -010 \\(-(0\u00b72^2+ 1\u00b72^1+ 0\u00b72^0)\\) -2 111 -11 sim -00 sim -001 \\(-(0\u00b72^2+ 0\u00b72^1+ 1\u00b72^0)\\) -1 <p></p> <p>Geralmente, valores inteiros s\u00e3o armazenados em um tipo de dado <code>inteiro</code> de 32 ou 64 bits. Considerando o primeiro caso, a estrutura de dados para complemento de dois determina:</p> <ol> <li>O significado \u00e9 de um valor num\u00e9rico inteiro, que pode ser negativo.</li> <li>O valor \u00e9 armazenado como Complemento de 2 nos 32 bits.</li> <li>Os poss\u00edveis valores armazenados est\u00e3o no intervalo \\([-2^{31}, 2^{31})\\).</li> <li>As opera\u00e7\u00f5es aritm\u00e9ticas b\u00e1sicas (\\(+, -, \\times\\ e\\ \\div\\)) est\u00e3o definidas na linguagem de programa\u00e7\u00e3o - e possivelmente outras.</li> </ol> <p>{! programacao/tipos_de_dados/reais.md !}</p>"},{"location":"programacao/tipos_de_dados/reais/","title":"Reais","text":""},{"location":"programacao/tipos_de_dados/reais/#numeros-reais","title":"N\u00fameros Reais","text":"<p>Os n\u00fameros reais tamb\u00e9m podem ser representados como bin\u00e1rios pelo sistema posicional, basta estender a l\u00f3gica da nota\u00e7\u00e3o posicional. Por exemplo, considere o seguinte n\u00famero decimal:</p> \\[13,125 = 1\\cdot{10^1} + 3\\cdot{10^0} + 1\\cdot{10^{-1}} + 2\\cdot{10^{-2}} + 5\\cdot{10^{-3}}\\] <p>Este valor pode ser representado com a mesma l\u00f3gica em 7 bits:</p> \\[1\\cdot2^3 + 1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 0\\cdot2^{-2} + 1\\cdot2^{-3} = 1101,001_2\\] <p>Neste caso usamos 4 bits para o valor inteiro e 3 para o valor fracion\u00e1rio.</p> Ponto Fixo <p>A representa\u00e7\u00e3o com ponto fixo define que, dada uma quantidade \\(Q\\) de bits para representar o n\u00famero, h\u00e1 uma quantidade fixa \\(m\\) de bits que armazenam a parte inteira e outra quantidade \\(f\\) que armazena a parte fracion\u00e1ria do n\u00famero (tais que \\(Q = m + f\\)). Por exemplo, supondo \\(Qm.f = Q5.3\\), o n\u00famero 13,125 seria representado pelos bits <code>01101001</code> cujo valor \u00e9 interpretado como <code>01101,001</code>. Supondo \\(Q4.4\\), este mesmo valor \u00e9 representado por <code>11010010</code>.</p> <p>O ponto fixo \u00e9 uma conven\u00e7\u00e3o interessante, mas pouco flex\u00edvel. Como toda estrutura de dados, a quantidade de bits limita os valores que podem ser armazenado, portanto uma configura\u00e7\u00e3o \\(Qm.f\\) que pode ser adequada para uma aplica\u00e7\u00e3o espec\u00edfica pode ser inadequada para outra. Por exemplo, considerando que \\(Q=8\\), uma representa\u00e7\u00e3o \\(Q0.7\\) \u00e9 mais interessante para lidar com o tamanho de componentes eletr\u00f4nicos que a \\(Q5.3\\). Desta forma, fica invi\u00e1vel determinar um padr\u00e3o para ponto fixo que seja suficiente para a maioria das aplica\u00e7\u00f5es.</p> Ponto Flutuante <p>Como alternativa mas flex\u00edvel, temos a representa\u00e7\u00e3o em ponto flutuante que se baseia na ideia da nota\u00e7\u00e3o cient\u00edfica onde qualquer n\u00famero pode ser representado no mesmo formato em duas componentes, separando valor num\u00e9rico de sua grandeza. Dada uma mantissa (\\(m\\)) composta por algarismos que determinam o valor do n\u00famero e um expoente (\\(e\\)) que determina sua grandeza, um n\u00famero qualquer na base \\(B\\) pode ser representado da seguinte forma:</p> \\[m\\cdot{B}^{e}\\] <p>Por exemplo:</p> \\[0,13125\\cdot10^2 = 13,125_{10} \\Longleftrightarrow 1101,001_2 = 0,1101001\\cdot2^4\\] <p>Esta representa\u00e7\u00e3o oferece maior flexibilidade e alcance de valores. O padr\u00e3o usado nos computadores modernos \u00e9 o IEEE 754, que define o valor armazenado considerando um conjunto de bits de tamanho fixo em tr\u00eas partes: um bit para determinar o sinal, seguido de \\(e\\) bits para o valor do expoente, seguido de \\(m\\) bits para a mantissa. Esta abordagem permite que se use quaisquer quantidades de bits mas usualmente temos a precis\u00e3o simples (32 bits em blocos de 1/8/23) e dupla (64 bits, em blocos de 1/11/52). O valor armazenado pode ser obtido pelo valor num\u00e9rico simples de cada bloco desta forma:</p> \\[(-1)^{s}\\cdot1,m\\cdot2^{e-offset}\\] <p>O offset depende da quantidade de bits de e, sendo calculado como \\(2^{e-1}-1\\). Para as precis\u00f5es simples e dupla, temos os valores 127 e 1023, respectivamente. Por exemplo, para precis\u00e3o simples temos que:</p> sinal expoente mantissa f\u00f3rmula valor 1 01111110 10000000000000000000000 \\((-1)^{1}\\cdot1,1\\cdot2^{-1}\\) \\(-0,75_{10}\\) 0 10000010 10100100000000000000000 \\((-1)^{0}\\cdot1,101001\\cdot2^3\\) \\(13,125_{10}\\) <p>O uso de ponto flutuante oferece diversas vantagens, principalmente a representa\u00e7\u00e3o de valores absolutos muito grandes ou pequenos1, mas h\u00e1 limita\u00e7\u00f5es. O conjunto de n\u00fameros reais \u00e9 infinitamente grande, e n\u00e3o pode ser completamente representado com a quantidade finita de bits dispon\u00edvel na mem\u00f3ria, portanto \u00e9 muito comum que valores em ponto flutuante sejam arredondados ao serem armazenados na quantidade fixa de bits dispon\u00edvel2.</p> <p>Por exemplo, considere a express\u00e3o \\(1 / 3 = 0,33333\\dots\\). O valor resultante \u00e9 uma d\u00edzima peri\u00f3dica, podemos mostrar matematicamente que \\(0,\\overline{3} + 0,\\overline{3} + 0,\\overline{3} = 1\\). Entretanto, \\(0,\\overline{3}\\) \u00e9 uma express\u00e3o matem\u00e1tica com mais informa\u00e7\u00e3o que \"apenas\" algarismos, ela determina um valor que n\u00e3o pode ser exatamente representado por uma quantidade fixa de algarismos (ou bits na mem\u00f3ria). O que se pode fazer \u00e9 usar toda a capacidade dispon\u00edvel para armazenar o valor mais pr\u00f3ximo poss\u00edvel. Considere que s\u00f3 podemos usar 3 algarismos, ent\u00e3o a express\u00e3o \\(0,\\overline{3} + 0,\\overline{3} + 0,\\overline{3}\\) se torna \\(0,33 + 0,33 + 0,33 = 0,99 \\neq 1\\).</p> <p>Esta imprecis\u00e3o tem implica\u00e7\u00f5es interessantes pois, para um programa de computador, a express\u00e3o \\(0,1 + 0,1 + 0,1\\) n\u00e3o resulta no valor \\(0,3\\)! O valor decimal \\(0,1\\) \u00e9 representado em bin\u00e1rio como \\(0,1\\overline{0011}\\) at\u00e9 o limite de bits reservados, que \u00e9 insuficiente para o valor exato. Abaixo, podemos ver as diferen\u00e7as escolhendo precis\u00f5es arbitr\u00e1rias para mostrar um mesmo valor armazenado de \\(0,1\\), bem como o efeito da propaga\u00e7\u00e3o desta diferen\u00e7a ao longo de diversas opera\u00e7\u00f5es:</p> ValorSomat\u00f3rio <p><p>1 casa de precis\u00e3o: 0.1</p> <p>5 casas de precis\u00e3o: 0.10000</p> <p>15 casas de precis\u00e3o: 0.100000000000000</p> <p>28 casas de precis\u00e3o: 0.1000000000000000055511151231</p> </p> <p><p>\\(\\sum\\limits_{i=1}^{1}0.1 = 0.1000000000000000055511151231\\)</p> <p>\\(\\sum\\limits_{i=1}^{3}0.1 = 0.3000000000000000444089209850\\)</p> <p>\\(\\sum\\limits_{i=1}^{10}0.1 = 1.0000000000000000000000000000\\)</p> <p>\\(\\sum\\limits_{i=1}^{100}0.1 = 10.0000000000000000000000000000\\)</p> </p> <p>Os efeitos da imprecis\u00e3o tendem a n\u00e3o ser considerados na maioria das aplica\u00e7\u00f5es (que n\u00e3o lidem com isso como as de engenharia/finan\u00e7as/computa\u00e7\u00e3o cient\u00edfica). Entretanto, deve-se ter aten\u00e7\u00e3o especial pois, apesar da diferen\u00e7a para o valor exato ser \"pequena\", ela existe e pode causar dificuldades se seu programa liga com algo simples como verificar se \\(0,1 + 0,2 = 0,3\\) (algo bem prov\u00e1vel de ocorrer em muitas aplica\u00e7\u00f5es). \u00c9 papel do programador entender a situa\u00e7\u00e3o e lidar com ela.</p> <p>Algumas abordagens para com isso s\u00e3o trabalhar com inteiros e evitar comparar diretamente vari\u00e1veis do tpo <code>float</code>. Se necess\u00e1rio, podemos realizar a compara\u00e7\u00e3o considerando uma toler\u00e2ncia razo\u00e1vel para a diferen\u00e7a entre os valores: ao inv\u00e9s de \\(a &lt; b\\), usamos \\(|a - b| &lt; \\epsilon\\). Tamb\u00e9m \u00e9 preciso atentar para ac\u00famulo de imprecis\u00f5es ao longo de m\u00faltiplas computa\u00e7\u00f5es, pois podem ser realmente significativos.</p> <ol> <li> <p>Aaron M Tenenbaum, Yedidyah Langsam, and Moshe Augenstein. Estruturas de dados usando C. Pearson Makron Books, S\u00e3o Paulo (SP), 1995. ISBN 8534603480 : 9788534603485.\u00a0\u21a9</p> </li> <li> <p>David Goldberg. What every computer scientist should know about floating-point arithmetic. ACM Comput. Surv., 23(1):5\u201348, mar 1991. URL: https://doi.org/10.1145/103162.103163, doi:10.1145/103162.103163.\u00a0\u21a9</p> </li> </ol>"},{"location":"programacao/tipos_de_dados/simbolicos/","title":"Simbolicos","text":""},{"location":"programacao/tipos_de_dados/simbolicos/#simbolos","title":"S\u00edmbolos","text":"<p>S\u00edmbolos s\u00e3o uma forma extremamente vers\u00e1til de comunicar informa\u00e7\u00f5es; o alfabeto define um pequeno conjunto de s\u00edmbolos que, juntos, podem expressar quase tudo que se deseja. S\u00edmbolos, como toda informa\u00e7\u00e3o no computador, s\u00e3o representados por bits.</p> ASCII <p>O padr\u00e3o ASCII1 (American Standard Code for Information Interchange) foi desenvolvido nos anos 60, sendo composto por 95 s\u00edmbolos gr\u00e1ficos (letras do alfabeto latino, algarismos ar\u00e1bicos, sinais de pontua\u00e7\u00e3o e sinais matem\u00e1ticos) e 33 de controle.</p> <p> Controle bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo 0x00 NUL 0x08 BS 0x10 DLE 0x18 CAN 0x01 SOH 0x09 HT 0x11 DC1 0x19 EM 0x02 STX 0x0A LF 0x12 DC2 \u22ee \u22ee 0x03 ETX 0x0B VT 0x13 DC3 \u22ee \u22ee 0x04 EOT 0x0C FF 0x14 DC4 \u22ee \u22ee 0x05 ENQ 0x0D CR 0x15 NAK \u22ee \u22ee 0x06 ACK 0x0E SO 0x16 SYN \u22ee \u22ee 0x07 BEL 0x0F SI 0x17 ETB 0x7F DEL Gr\u00e1ficos (Parcial) bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo 0x20 espa\u00e7o 0x30 0 0x41 A 0x61 a 0x21 ! 0x31 1 0x42 B 0x62 b 0x22 \" 0x32 2 0x43 C 0x63 c 0x23 # 0x33 3 0x44 D 0x64 d 0x24 $ 0x34 4 0x45 E 0x65 e 0x25 % 0x35 5 \u22ee \u22ee \u22ee \u22ee 0x26 &amp; 0x36 6 0x57 W 0x77 w 0x27 ' 0x37 7 0x58 X 0x78 x 0x28 ( 0x38 8 0x59 Y 0x79 y 0x29 ) 0x39 9 0x5A Z 0x7A z \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee <p></p> <p>Cada um dos 128 s\u00edmbolos \u00e9 associado \u00e0 uma sequ\u00eancia arbitr\u00e1ria e \u00fanica de 7 de bits. \u00c9 bem comum associar esta sequ\u00eancia a um n\u00famero inteiro, por exemplo o n\u00famero 65 ao s\u00edmbolo 'A' (\"um mesmo conjunto de bits pode ser interpretado de diferentes formas\"). Al\u00e9m disso, o padr\u00e3o ASCII tem algumas caracter\u00edsticas interessantes. Os algarismos s\u00e3o listados em ordem de valor, e as letras s\u00e3o organizadas em ordem alfab\u00e9tica, o que facilita os processos de compara\u00e7\u00e3o entre eles. As letras min\u00fasculas est\u00e3o deslocadas em 32 posi\u00e7\u00f5es em rela\u00e7\u00e3o \u00e0s mai\u00fasculas, ent\u00e3o a diferen\u00e7a entre os bits que as representam \u00e9 apenas no sexto bit!</p> <p>Por conta de como as m\u00e1quinas eram constru\u00eddas, era muito comum usar um byte para armazenar cada s\u00edmbolo, o que viabilizou definir outros 128 s\u00edmbolos arbitr\u00e1rios. Entretanto, n\u00e3o houve maior consenso em quais seriam os s\u00edmbolos, afinal cada grupo tinha seus pr\u00f3prios interesses. No Brasil, o mais comum era o ISO/IEC 8859-1. Com o avan\u00e7o da internet, a necessidade de comunica\u00e7\u00e3o entre m\u00e1quinas e grupos distintos for\u00e7ou a incorpora\u00e7\u00e3o de um padr\u00e3o internacional. Entretanto, algumas dificuldades deveriam ser consideradas...</p> <p>Uma solu\u00e7\u00e3o \"simples\" seria usar mais bits e ampliar o tamanho da tabela, mas isso implicaria que toda informa\u00e7\u00e3o j\u00e1 representada num padr\u00e3o como ASCII ocuparia mais mem\u00f3ria que o necess\u00e1rio. Por exemplo, supondo que fossem usados 3 bytes (possibilitando mais de 16 milh\u00f5es de s\u00edmbolos), uma mensagem com 10 s\u00edmbolos ASCII passa a ocupar 30 bytes, 200% a mais do que necess\u00e1rio. Tamb\u00e9m seria necess\u00e1rio lidar com informa\u00e7\u00f5es armazenadas que usam o s\u00edmbolo <code>NUL</code> para indicar o t\u00e9rmino de uma sequ\u00eancia de s\u00edmbolos - uma sequ\u00eancia de 8 bits com valor 0 n\u00e3o seria rara considerando 3 bytes. Outro ponto relevante era lidar com os documentos existentes, gerar uma c\u00f3pia de todo arquivo existente com esta nova codifica\u00e7\u00e3o seria uma tarefa invi\u00e1vel. A solu\u00e7\u00e3o encontrada foi uma forma elegante de lidar com tudo isso, al\u00e9m de viabilizar a incorpora\u00e7\u00e3o de quaisquer novos s\u00edmbolos que possam ser criados.</p> Unicode <p>Uma vez estabelecido um padr\u00e3o de codifica\u00e7\u00e3o de caracteres (associa\u00e7\u00e3o [arbitr\u00e1ria] de bits a certos caracteres), pode-se armazenar estes s\u00edmbolos na mem\u00f3ria (e recuper\u00e1-los). H\u00e1 diversar formas de se codificar caracteres: EBCDIC, Unicode (veja isso), ente outros.</p> <p>Nesta disciplina, o foco \u00e9 a representa\u00e7\u00e3o em ASCII, uma forma extremamente compacta e a mais utilizada no padr\u00e3o ANSI. Neste contexto, um <code>char</code> \u00e9 um pequeno inteiro, de modo que pode ser livremente usado em express\u00f5es aritm\u00e9ticas2 (veja \\linkFile[../src/exemplos/05_EstruturasDeDados/02_Simbolos]{00-ascii.c} e \\linkFile[../src/exemplos/05_EstruturasDeDados/02_Simbolos]{01-ascii.c}).</p> <p>A vers\u00e3o 3 da \\lP~utiliza outra abordagem, cada caractere \u00e9 representado como Unicode, mas os valores num\u00e9ricos/simb\u00f3licos podem ser utilizados por interm\u00e9dio das fun\u00e7\u00f5es <code>ord</code> e <code>chr</code>, respectivamente (veja \\linkFile[../src/exemplos/05_EstruturasDeDados/02_Simbolos]{00-ascii.py} e \\linkFile[../src/exemplos/05_EstruturasDeDados/02_Simbolos]{01-ascii.py}). \\else% \\begin{frame}%     A codifica\u00e7\u00e3o de caracteres \u00e9 a associa\u00e7\u00e3o de bits a s\u00edmbolos.     \\begin{center}\\includegraphics[width=.5\\textwidth]{misc/LouisBraille}\\end{center}     \\vfill%     Por necessidade de di\u00e1logos entre os diferentes computadores, foram criados     diversos c\u00f3digos objetivando a padroniza\u00e7\u00e3o. \\end{frame}% <p>\\begin{frame}%     \\framesubtitle{Extended Binary Coded Decimal Interchange Code (EBCDIC)}%     \\begin{center}\\includegraphics[width=.75\\textwidth]{computing/programming/EBCDIC}\\end{center} \\end{frame}% <p>\\begin{frame}%     \\framesubtitle{American Standard Code for Information Interchange (ASCII)}%     \\begin{center}\\includegraphics[width=.95\\textwidth]{computing/programming/ascii}\\end{center} \\end{frame}% \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstC[linerange={9-21}]{exemplos/05_EstruturasDeDados/02_Simbolos}{00-ascii.c}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstPython[firstline=12]{exemplos/05_EstruturasDeDados/02_Simbolos}{00-ascii.py}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstC[linerange={9-21}]{exemplos/05_EstruturasDeDados/02_Simbolos}{01-ascii.c}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstPython[firstline=9]{exemplos/05_EstruturasDeDados/02_Simbolos}{01-ascii.py}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=8]{exercicios/05_EstruturasDeDados/02_Simbolos}{00-maior}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=8]{exercicios/05_EstruturasDeDados/02_Simbolos}{01-toupper}% \\end{frame}\\] <p>\\begin{frame}%     \\framesubtitle{Unicode}%     \\vspace{-4em}%     \\hfill\\includegraphics[width=.2\\textwidth]{computing/programming/unicode}%     \\\\vspace{-1em}%     \\begin{itemize}     \\item Padr\u00e3o universal de codifica\u00e7\u00e3o de caracteres     \\item Fornece um n\u00famero \u00fanico para cada caractere, n\u00e3o importando a plataforma (a m\u00e1quina e/ou sistema operacional em uso), o programa ou o idioma.     \\item Permite definir caracteres cuja representa\u00e7\u00e3o interna no computador utiliza mais de um byte (UTF-8), tais como:     16 bits (UTF-16) e 32 bits (UTF-32).     \\item Atualmente, o padr\u00e3o consiste de mais de 100 mil caracteres e pode ser usado em v\u00e1rios sistemas operacionais, programas e navegadores modernos.     \\end{itemize} \\end{frame}% \\fi%"},{"location":"programacao/tipos_de_dados/simbolicos/#objetos-em-python","title":"Objetos em Python","text":"<p>\\subsection{Ponteiros na \\LP}% \\ifIsArticle% A \\lP~n\u00e3o utiliza ponteiros diretamente e, por projeto, manipula objetos de forma diferente de C. Em ambas, os argumentos s\u00e3o passados por valor, mas dependendo do tipo de objeto (mut\u00e1vel/imut\u00e1vel), a manipula\u00e7\u00e3o dentro do escopo de uma fun\u00e7\u00e3o tem ou n\u00e3o efeito em um escopo externo.</p> <p>Primeiro, \u00e9 preciso lembrar alguns detalhes da pr\u00f3pria linguagem: os objetos (que ficam na mem\u00f3ria) t\u00eam os seguintes atributos: tipo, que define a informa\u00e7\u00e3o (e valores) que o objeto pode receber e as opera\u00e7\u00f5es que podem ser executadas nele; valor, que \u00e9 o endere\u00e7o de mem\u00f3ria ocupado pelo objeto; nome, que identifica o objeto diferenciando dos demais elementos na mem\u00f3ria; e tempo de vida, que \u00e9 o per\u00edodo de tempo de execu\u00e7\u00e3o do programa durante o qual o objeto existe. Na \\lP{ }lida-se com refer\u00eancias para objetos, as quais desempenham pap\u00e9is similares a ponteiros. \\fi%</p> <p>\\ifIsArticle% Os objetos s\u00e3o imut\u00e1veis (como \\texttt{int}, \\texttt{float}, \\texttt{str}, etc.) ou mut\u00e1veis (como \\texttt{lista}, \\texttt{dict}, etc.). Toda vari\u00e1vel \u00e9, na verdade, uma refer\u00eancia para algum objeto da mem\u00f3ria. Considerando objetos imut\u00e1veis, como ilustrado na figura abaixo, o valor de nome `z' n\u00e3o varia a n\u00e3o ser que voc\u00ea o mude explicitamente, e o operador \\texttt{=} n\u00e3o \u00e9 de atribui\u00e7\u00e3o de valor (como na \\lC), mas de refer\u00eancia, e o coletor de lixo lida com a informa\u00e7\u00e3o \\texttt{42} ao t\u00e9rmino de seu tempo de vida. \\else% \\begin{frame}[fragile]%     %https://pythonhelp.wordpress.com/2013/02/20/variaveis-valores-e-referencias/     Python n\u00e3o utiliza ponteiros como tipos de dados, mas lida com refer\u00eancias de forma ``diferente''...%     \\\\pause\\vfill%     Os objetos em \\texttt{Python} s\u00e3o:     \\begin{description}          \\item[imut\u00e1veis:] \\texttt{int}, \\texttt{float}, \\texttt{str}, \\(\\dots\\)          \\item[mut\u00e1veis:] \\texttt{lista}, \\(\\dots\\)      \\end{description} \\end{frame}</p> <p>\\begin{frame}%     Toda vari\u00e1vel em \\texttt{Python} \u00e9 uma refer\u00eancia para algum objeto da mem\u00f3ria.     \\\\pause\\vfill%     Nesta abordagem para lidar com a mem\u00f3ria, o valor de nome `a' n\u00e3o varia a n\u00e3o ser que voc\u00ea o mude explicitamente\\footnote&lt;2-&gt;{Expl\u00edcito \u00e9 melhor que impl\u00edcito.}. \\end{frame} \\fi%</p> <p>\\ifIsArticle% \\begin{figure}[H]     \\centering     \\begin{subfigure}[b]{0.3\\textwidth}         \\begin{tikzpicture}[start chain=going right, node distance=0pt, mem/.style={inMemory,text width=2em, minimum height=1.7em}]%             \\node[mem,label={[address,above]0xB1}] (M0) {};%             \\node[mem,label={[address,above]0xB5}] (M1) {42};%             \\node[mem,label={[address,above]0xB9}] (M2) {\\(\\pi\\)};%             \\node[mem,label={[address,above]0xBD}] (M3) {43};%</p> <pre><code>        \\node[ptr,below of=M0,yshift=-3em] (a) {\\textbf{x}};%\n        \\draw[ptr] (a) -| (M1.south);%\n        \\node[ptr,below of=a,yshift=-2em] (b) {\\textbf{y}};%\n        \\draw[ptr] (b) -| (M2.south);%\n        \\node[ptr,below of=b,yshift=-2em] (c) {\\textbf{z}};%\n        \\draw[ptr] (c) -| (M3.south);%\n    \\end{tikzpicture}%\n    \\caption{\\texttt{x, y, z = 42, $\\pi$, 43}}\n\\end{subfigure}\n\\hspace{4em}%\n\\begin{subfigure}[b]{0.3\\textwidth}\n    \\begin{tikzpicture}[start chain=going right, node distance=0pt, mem/.style={inMemory,text width=2em, minimum height=1.7em}]%\n        \\node[mem,label={[address,above]0xB1}] (M0) {};%\n        \\node[mem,label={[address,above]0xB5}] (M1) {};%\n        \\node[mem,label={[address,above]0xB9}] (M2) {$\\pi$};%\n        \\node[mem,label={[address,above]0xBD}] (M3) {43};%\n\n        \\node[ptr,below of=M0,yshift=-3em] (a) {\\textbf{x}};%\n        \\draw[ptr] (a) -| (M2.south);%\n        \\node[ptr,below of=a,yshift=-2em] (b) {\\textbf{y}};%\n        \\draw[ptr] (b) -| (M3.south);%\n        \\node[ptr,below of=b,yshift=-2em] (c) {\\textbf{z}};%\n        \\draw[ptr] (c) -| (M3.south);%\n    \\end{tikzpicture}%\n    \\caption{\\texttt{x, y = y, z}}\n\\end{subfigure}\n</code></pre> <p>\\end{figure} \\else% \\begin{frame}[fragile]%     %https://pythonhelp.wordpress.com/2013/02/20/variaveis-valores-e-referencias/     O operador \\texttt{=} n\u00e3o \u00e9 de atribui\u00e7\u00e3o, mas de refer\u00eancia.%     \\vfill%     \\begin{columns}         \\column{.7\\textwidth}%             \\begin{tikzpicture}[start chain=going right, node distance=0pt, mem/.style={inMemory,text width=2em, minimum height=1.7em}]%                 \\node[mem,label={[address,above]0xB1}] (M0) {};%                 \\node[mem,label={[address,above]0xB5}] (M1) {\\only&lt;2&gt;{42}};%                 \\node[mem,label={[address,above]0xB9}] (M2) {\\only&lt;5-&gt;{\\(\\pi\\)}};%                 \\node[mem,label={[address,above]0xBD}] (M3) {\\only&lt;3-&gt;{43}};%                 \\node[mem,label={[address,above]0xC0}] (M4) {};%</p> <pre><code>            \\node&lt;2-&gt;[ptr,below of=M0,yshift=-4em] (a) {\\textbf{a}};%\n            \\draw&lt;2&gt;[ptr] (a) -| (M1.south);%\n            \\draw&lt;3-4&gt;[ptr] (a) -| (M3.south);%\n            \\node&lt;4-&gt;[ptr,below of=a,yshift=-2em] (b) {\\textbf{b}};%\n            \\draw&lt;4-&gt;[ptr] (b) -| (M3.south);%\n            \\draw&lt;5-&gt;[ptr] (a) -| (M2.south);%\n        \\end{tikzpicture}%\n    \\column{.2\\textwidth}%\n        \\pause\n</code></pre> <p>\\begin{lstlisting}[style=CIC-Python] a = 42 \\end{lstlisting}% \\pause\\vspace{-1.1em}% \\begin{lstlisting}[style=CIC-Python,firstnumber=2] a += 1 \\end{lstlisting}% \\pause\\vspace% \\begin{lstlisting}[style=CIC-Python,firstnumber=3] b = a \\end{lstlisting}% \\pause\\vspace*{-1.1em}% \\begin{lstlisting}[style=CIC-Python,firstnumber=4] a = 3.14 \\end{lstlisting}%     \\end{columns}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% Na \\lP, o conte\u00fado de uma vari\u00e1vel \u00e9 acessado por seu nome, e n\u00e3o \u00e9 permitida a manipula\u00e7\u00e3o direta da mem\u00f3ria por um endere\u00e7o. Isso tem uma s\u00e9rie de vantagens (simplifica o uso e evita ) e desvantagens (desempenho). Internamente, o sistema acumula identificadores pr\u00f3prios para cada objeto enquanto durar o seu tempo de vida (veja \\linkFile[../src/exemplos/05_EstruturasDeDados/03_Ponteiros]{00-identificador.py} e \\linkFile[../src/exemplos/05_EstruturasDeDados/03_Ponteiros]{01-identificador.py}). \\else% \\begin{frame}[fragile]     \\lstPython[linerange={9-13,15-23}]{exemplos/05_EstruturasDeDados/03_Ponteiros}{00-identificador.py}% \\end{frame}</p> <p>\\begin{frame}[fragile]     \\lstPython[linerange={9-14,25-32}]{exemplos/05_EstruturasDeDados/03_Ponteiros}{01-identificador.py}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% A \\lP~tem tipo din\u00e2mico e forte, portanto ao declarar um objeto se sabe, em tempo de execu\u00e7\u00e3o, o tipo de dado referenciado e como ele \u00e9 representado na mem\u00f3ria. \\else% \\begin{frame}[fragile]%     Um tipo \u00e9 din\u00e2mico e forte (em tempo de execu\u00e7\u00e3o, sabe-se o tipo de dado referenciado e como ele \u00e9 representado na mem\u00f3ria).     \\\\vfill%     \\begin{columns}         \\column{.5\\textwidth}%             \\begin{tikzpicture}[start chain=going right, node distance=0pt, mem/.style={inMemory,text width=2.5em, minimum height=1.7em}]%                 \\node[mem,label={[address,above]0xB1}] (M0) {42};%                 \\node[mem,label={[address,above]0xB5},text width=5em] (M1) {\\only&lt;2-&gt;{Lovelace}};%                 \\node[ptr,below of=M0,xshift=-2em,yshift=-3em] (a) {\\textbf{x}};%                 \\draw&lt;1&gt;[ptr] (a) -| (M0.south);%                 \\draw&lt;2-&gt;[ptr] (a) -| (M1.south);%             \\end{tikzpicture}%         \\column{.5\\textwidth}%             \\begin{lstlisting}[style=CIC-Python] x = 42 \\end{lstlisting}%             \\vspace{-1.1em}\\pause%             \\begin{lstlisting}[style=CIC-Python,firstnumber=2] x = 'Lovelace' \\end{lstlisting}%     \\end{columns}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% No caso da passagem de informa\u00e7\u00f5es a fun\u00e7\u00f5es por argumentos, a \\lP~define a vari\u00e1vel local como refer\u00eancia ao valor passado (similar a passar a refer\u00eancia para o valor armazenado). A diferen\u00e7a ocorre na quest\u00e3o de qual \u00e9 o objeto dado, se \u00e9 mut\u00e1vel, a fun\u00e7\u00e3o recebe uma refer\u00eancia para ele e pode alter\u00e1-lo (desde que a refer\u00eancia local n\u00e3o seja variada); se \u00e9 imut\u00e1vel, a fun\u00e7\u00e3o n\u00e3o pode alter\u00e1-lo.</p> <p>A comunica\u00e7\u00e3o de dados entre [sub]algoritmos \u00e9 feita pela passagem de argumentos e pelo valor de retorno, e a \\lP possibilita o retorno de m\u00faltiplos valores.</p> <p>\\noindent% \\lstPython[linerange={9-9,18-24}]{exemplos/05_EstruturasDeDados/03_Ponteiros}{05-bhaskara.py}% \\else% \\begin{frame}[fragile]%      \u00c9 poss\u00edvel retornar de m\u00faltiplos valores.     \\\\vfill%     \\lstPython[linerange={9-9,18-24}]{exemplos/05_EstruturasDeDados/03_Ponteiros}{05-bhaskara.py}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% Na \\lP, fun\u00e7\u00f5es tamb\u00e9m s\u00e3o objetos, e podem ser fornecidas como argumentos para outras fun\u00e7\u00f5es de forma mais simplificada (comparada a \\lC). Um exemplo simples disso \u00e9:</p> <p>\\lstPython[linerange={9-19}]{exemplos/05_EstruturasDeDados/03_Ponteiros}{06-funcao.py}%</p> <p>Da mesma forma, pode-se abstrair o m\u00e9todo de aproxima\u00e7\u00e3o de ra\u00edzes e passar a fun\u00e7\u00e3o do polin\u00f4mio (\\linkFile[../src/exercicios/05_EstruturasDeDados/03_Ponteiros/01-Newton-Raphson]{Newton-Raphson.py}). \\else% \\subsection{Fun\u00e7\u00f5es como Argumentos de Fun\u00e7\u00f5es}% \\begin{frame}[fragile]% <pre><code>\\lstPython[firstline=9]{exemplos/05_EstruturasDeDados/03_Ponteiros}{06-funcao.py}%\n</code></pre> <p>\\end{frame}</p> <p>\\begin{frame}[fragile]%     \\vspace{-1em}%     \\lstPython[linerange={83-83,94-102},morekeywords={valor_inicial,aproxima,erro},escapechar=]{exercicios/05_EstruturasDeDados/03_Ponteiros/01-Newton-Raphson}{Newton-Raphson.py}% \\end{frame} \\fi% <p>% Os detalhes de ponteiros na \\lP{ }n\u00e3o ser\u00e3o aprofundados aqui, mas vale a pena aprender sobre isso.</p> <p>%     chamada por compartilhamento</p> <p>%     \u00edndice negativo %     https://docs.python.org/3/faq/programming.html#what-s-a-negative-index</p> <p>%     O comportamento de ``passagem por refer\u00eancia'' pode ser obtido de outras formas.</p> <p>% \\begin{frame}%</p> <p>% %%%%%%%%%%%%%%%%%%% % http://wiki.python.org.br/IntroPython</p> <p>% Tipos mut\u00e1veis e imut\u00e1veis</p> <p>% Alguns tipos no Python permitem que elementos que fazem parte de sua estrutura sejam modificados, como as listas e dicion\u00e1rios. Estes tipos s\u00e3o chamados mut\u00e1veis.</p> <p>% Exemplo:</p> <p>% Esconder n\u00famero das linhas</p> <p>%    1 &gt;&gt;&gt; l = ['Nirvana', 'Rush', 'Bauhaus'] %    2 &gt;&gt;&gt; l[1] = 'Who' %    3 &gt;&gt;&gt; l %    4 ['Nirvana', 'Who', 'Bauhaus'] %    5 &gt;&gt;&gt;</p> <p>% Outros tipos n\u00e3o permitem isso, como tuplas e strings. Estes s\u00e3o chamados imut\u00e1veis.</p> <p>% \\end{frame}%</p>"},{"location":"programacao/tipos_de_dados/simbolicos/#strings","title":"Strings","text":"<p>\\subsection{Strings}%</p> <p>\\ifIsArticle% Uma palavra/frase \u00e9 um conjunto finito e ordenado de s\u00edmbolos. Um *string* \u00e9 um vetor de caracteres, a ``melhor'' forma de comunica\u00e7\u00e3o com humanos.%</p> <p>\\lstset{morekeywords={mostra_indices,mostra_n_chars,mostra_ate_char}}% \\lstC[linerange={10-22}]{exemplos/05_EstruturasDeDados/04_Vetor}{04-string.c}%</p> <p>O c\u00f3digo acima funciona muito bem, mas tem um comportamento interessante quando se digita uma frase menor que os 50 caracteres definidos. Entretanto, for\u00e7ar a utiliza\u00e7\u00e3o de frases com tamanho fixo n\u00e3o \u00e9 uma op\u00e7\u00e3o vi\u00e1vel. A solu\u00e7\u00e3o de melhor custo/benef\u00edcio \u00e9 obter um vetor ``grande o suficiente'' para a tarefa em quest\u00e3o, de modo que haja um tamanho restringindo a aplica\u00e7\u00e3o (por exemplo, 140 caracteres), e utilizar uma marca\u00e7\u00e3o espec\u00edfica para indicar o t\u00e9rmino dos s\u00edmbolos de interesse.%</p> <p>\\noindent% \\begin{minipage}[t]{.56\\textwidth}% \\lstC[linerange={10-22}]{exemplos/05_EstruturasDeDados/04_Vetor}{05-string.c}% \\end{minipage}% \\hfill% \\begin{minipage}[t]{.44\\textwidth}% \\lstC[linerange={10-19}]{exemplos/05_EstruturasDeDados/04_Vetor}{06-string.c}% \\end{minipage}%</p> <p><code><code>.'&lt;/code&gt; n\u00e3o \u00e9 uma boa escolha de s\u00edmbolo terminador (afinal, sempre aparece algu\u00e9m dizendo ``*Hello World!*''), ent\u00e3o escolheu-se o s\u00edmbolo &lt;code&gt;</code>\\textbackslash0'</code> (o primeiro caractere da tabela ASCII) como terminador de um string para representa\u00e7\u00e3o interna2. Assumindo que todo string segue este padr\u00e3o, pode-se ignorar o tamanho do vetor e simplesmente percorr\u00ea-lo at\u00e9 encontrar o caractere de t\u00e9rmino.%</p> <p>Algumas ideias interessantes para lidar com strings s\u00e3o: contagem do tamanho de uma palavra, de palavras em um texto, compara\u00e7\u00e3o de strings, transforma\u00e7\u00e3o em letras mai\u00fasculas/min\u00fasculas, criptografia, etc..</p> <p>Considere o c\u00f3digo abaixo, e veja se percebe o que est\u00e1 errado: \\lstC[linerange={12-16}]{exemplos/05_EstruturasDeDados/04_Vetor}{08-memoria.c}%</p> <p><code>scanf</code>\\ armazena os caracteres digitados no endere\u00e7o indicado por \\var{buffer}. Como a vari\u00e1vel n\u00e3o foi inicializada, n\u00e3o \u00e9 poss\u00edvel dizer qual \u00e9 este endere\u00e7o. Se \\var{buffer} \u00e9 o caractere nulo (\\var{NULL}), ent\u00e3o <code>scanf</code>\\ tentar\u00e1 armazenar os caracteres em um local proibido e a execu\u00e7\u00e3o do programa ser\u00e1 interrompida. Sen\u00e3o, \\var{buffer}\\ tem um n\u00famero (que estava j\u00e1 armazenado na mem\u00f3ria por algum motivo) que \u00e9 interpretado como um endere\u00e7o de mem\u00f3ria onde <code>scanf</code>\\ tentar\u00e1 armazenar os caracteres. Embora sintaticamente correto, esta \u00e9 uma a\u00e7\u00e3o perigosa pois tal espa\u00e7o n\u00e3o foi alocado para seu uso, ent\u00e3o o programa estar\u00e1 trabalhando em um local que pode estar sendo usado por outro programa e, portanto, que poderia atrapalhar a execu\u00e7\u00e3o do seu ou, pior ainda, o seu atrapalhar a execu\u00e7\u00e3o dele (por exemplo, sobrescrevendo um peda\u00e7o do arquivo que cont\u00e9m a declara\u00e7\u00e3o do imposto de renda).</p> <p>Uma solu\u00e7\u00e3o \u00e9 definir \\var{buffer}\\ como um vetor (digamos, de tamanho 50). Mas esta solu\u00e7\u00e3o \u00e9 parcialmente correta, pois <code>scanf</code>\\ continuar\u00e1 escrevendo na mem\u00f3ria caso o usu\u00e1rio forne\u00e7a mais caracteres que o vetor pode armazenar. \u00c9 necess\u00e1rio, ent\u00e3o, limitar a quantidade de caracteres que pode ser considerada:%</p> <p>\\lstC[linerange={33-37}]{exemplos/05_EstruturasDeDados/04_Vetor}{08-memoria.c}%</p> <p>\u00c9 importante considerar este tipo de programa\u00e7\u00e3o defensiva, pois nunca se sabe o que o usu\u00e1rio vai fazer (nem como estas vulnerabilidades podem ser exploradas).</p> <p>% \\begin{lstlisting} % #include  <p>% void f(char *bar) { %   char c[12]; %   strncpy(c, bar, strlen(bar)); % }</p> <p>% int main(int argc, char **argv) { %   f(argv[1]); % } % \\end{lstlisting}% %  Potencialmente muito perigoso \\fi%</p>"},{"location":"programacao/tipos_de_dados/simbolicos/#vetores","title":"VetoresExerc\u00edcios","text":"<p>\\section{Vetores}</p> <p>\\ifIsArticle% \u00c9 f\u00e1cil manipular um dado para resolver um problema:% \\begin{lstlisting} z = min(x, y); \\end{lstlisting}%</p> <p>Mas e \\(n\\) problemas? \\begin{lstlisting} z = min(x1, min(x2, min (x3, min(x4, min(x5, / ... / min(xk, xn)/ ... /))))); \\end{lstlisting}% \\else% \\begin{frame}[fragile]% \u00c9 f\u00e1cil manipular um dado para resolver um problema:\\\\vfill% \\begin{lstlisting} z = min(x, y); \\end{lstlisting}% \\vfill\\pause Mas e \\strikeText{2} \\strikeText{3} \\(n\\) problemas?\\\\vfill% \\small% \\begin{lstlisting} z = min(x1, min(x2, min(x3, / ... / min(xk,xn)/ ... /))); \\end{lstlisting}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% N\u00e3o \u00e9 fact\u00edvel considerar escrever tanto c\u00f3digo, nem pensar nas dificuldades de eventuais altera\u00e7\u00f5es. Felizmente h\u00e1 uma solu\u00e7\u00e3o mais eficiente. Suponha que voc\u00ea tenha um ponteiro com o endere\u00e7o de um caractere na mem\u00f3ria, e que saiba que os \\(n\\) bytes imediatamente seguintes est\u00e3o alocados para voc\u00ea armazenar outros caracteres. Voc\u00ea poderia identific\u00e1-los como \\(\\{c_0, c_1, \\cdots, c_{n-1}\\}\\) e lidar com estes \\(n\\) elementos no c\u00f3digo, ou, dado que sabe o endere\u00e7o do primeiro, utilizar aritm\u00e9tica de ponteiros para acessar qualquer outro caractere em fun\u00e7\u00e3o do deslocamento em rela\u00e7\u00e3o a posi\u00e7\u00e3o inicial.</p> <p>\\begin{minipage}[t]{.52\\textwidth}% \\begin{lstlisting} printf(\"c0 = %c\\n\", c0); printf(\"c1 = %c\\n\", c1); / ... / \\end{lstlisting}% \\vspace{-1.1em}% \\begin{lstlisting}[firstnumber=1000] printf(\"c999 = %c\\n\", c999); / n==1000 / \\end{lstlisting}% \\end{minipage}% \\hfill% \\begin{minipage}[t]{.45\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i) printf(\"c%d = %c\\n\", i, (c+i)); \\end{lstlisting}% \\end{minipage}% \\vspace{1em}% \\else% \\begin{frame}[fragile]%     Mostrar 1000 caracteres n\u00e3o seria agrad\u00e1vel...     \\only&lt;2-&gt;{Mas suponha eles est\u00e3o magicamente armazenados sequencialmente, come\u00e7ando em um endere\u00e7o de mem\u00f3ria que voc\u00ea conhece...}     \\\\vfill \\hspace\\small% \\begin{minipage}[t]{.45\\textwidth}% \\begin{lstlisting} printf(\"c0=%c\\n\", c0); printf(\"c1=%c\\n\", c1); printf(\"c2=%c\\n\", c2); printf(\"c3=%c\\n\", c3); / ... / \\end{lstlisting}% \\begin{lstlisting}[firstnumber=997] / ... / printf(\"c997=%c\\n\", c997); printf(\"c998=%c\\n\", c998); printf(\"c999=%c\\n\", c999); \\end{lstlisting}% \\end{minipage}% \\pause\\pause% \\begin{minipage}[t]{.55\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i) printf(\"c%d=%c\\n\", i, *(c+i)); \\end{lstlisting}% \\end{minipage}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% Um vetor (\\texttt{array}) \u00e9 um conjunto finito e ordenado (em rela\u00e7\u00e3o a posi\u00e7\u00e3o) de elementos homog\u00eaneos (do mesmo tipo). \u00c9 um modo particular de organizar dados para facilitar o acesso e manipula\u00e7\u00e3o dos dados, caracterizado pelas opera\u00e7\u00f5es sobre os dados, e n\u00e3o pelo tipo do dado (j\u00e1 que se baseia na aritm\u00e9tica de ponteiros).</p> <p>Desta forma, \u00e9 poss\u00edvel ter um vetor de qualquer tipo de dado. Considerando \\(n\\) caracteres, o computador aloca um bloco de mem\u00f3ria de \\(n\\) bytes (supondo que um <code>char</code> seja armazenado em 1 byte). Analogamente, supondo \\(n\\) inteiros (de 4 bytes cada), ser\u00e3o alocados \\(4n\\) bytes de mem\u00f3ria (que equivalem a \\(n\\) unidades [de mem\u00f3ria] de inteiros).</p> <p>\\begin{center}%     \\tikzinput{memoria/vetor/array}% \\end{center}% \\else% \\begin{frame}%     \\begin{block}{Vetor (\\texttt{array})}%         \u00c9 um conjunto finito e ordenado\\footnote[frame]{Em rela\u00e7\u00e3o a posi\u00e7\u00e3o.} de elementos homog\u00eaneos.     \\end{block}%     \\vfill\\pause%     Quais elementos?%     \\vfill\\pause%     O vetor \u00e9 um modo particular de organizar dados \\pause para facilitar o acesso     e manipula\u00e7\u00e3o dos dados.     \\vfill%     \\begin{center}%         \\tikzinput{memoria/vetor/array}%     \\end{center}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% Portanto, para lidar com um vetor basta saber duas coisas: o endere\u00e7o do primeiro elemento e quantos s\u00e3o os elementos armazenados. Na \\lC, fica f\u00e1cil declarar um vetor:</p> <p>\\begin{lstlisting} int   inteiros[1000]; float reais[50]; char  caracteres[8]; \\end{lstlisting}%</p> <p>Considerando o vetor de caracteres, o que acontece na execu\u00e7\u00e3o \u00e9 que o computador armazena o ponteiro para caracteres (\\(c\\)) (em algum lugar da mem\u00f3ria) e um espa\u00e7o do tamanho desejado (<code>8*sizeof(char)</code>) em outro lugar. O acesso a cada elemento, dado o endere\u00e7o do primeiro, \u00e9 direto com aritm\u00e9tica de ponteiros ou com o operador <code>[\\ \\ ]</code>:</p> <p>\\noindent% \\begin{minipage}[t]{.52\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i)     printf(\"c%d = %c\\n\", i, *(c+i)); \\end{lstlisting}% \\end{minipage}% \\hfill% \\begin{minipage}[t]{.45\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i)     printf(\"c%d = %c\\n\", i, c[i]); \\end{lstlisting}% \\end{minipage}%</p> <p>\\begin{center}% \\tikzinput{memoria/vetor/lovelace}% \\end{center}% \\else% \\begin{frame}[fragile]%     Vetor em \\texttt{C}: endere\u00e7o do primeiro elemento e quantidade de elementos.     \\vfill% \\begin{lstlisting} int    inteiros[1000]; float     reais[50]; char caracteres[8]; \\end{lstlisting}% \\vfill\\pause% \\begin{center}%     \\scalebox{.8}{\\tikzinput{memoria/vetor/lovelace}}% \\end{center}% \\vfill\\pause% \\begin{minipage}[t]{.52\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i) printf(\"c%d=%c\\n\",i,*(c+i)); \\end{lstlisting}% \\end{minipage}% \\pause% \\begin{minipage}[t]{.48\\textwidth}% \\begin{lstlisting} for(i = 0; i &lt; n; ++i) printf(\"c%d=%c\\n\",i,c[i]); \\end{lstlisting}% \\end{minipage}% \\vfill\\pause \\begin{center}% RAM + indexa\u00e7\u00e3o \\(\\Rightarrow\\) \\alert{velocidade}% \\end{center}% \\end{frame}</p> \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=8]{exercicios/05_EstruturasDeDados/04_Vetor}{00-salarios}% \\end{frame}\\] <p>\\titledImageFrame[height=17\\baselineskip]{}{comics/VidaDeProgramador/FOR}% \\fi% <p>\\ifIsArticle% A \\lP~tem uma abordagem diferente, no contexto desta disciplina, usaremos listas como vetores[@Downey2002]. Embora a implementa\u00e7\u00e3o seja distinta, o funcionamento \u00e9 bastante similar.</p> <p>\\begin{lstlisting}[style=CIC-Python] inteiros = [0, 1, 2, 3] reais = [0.0] * 10 caracteres = ['L', 'o', 'v', 'e', 'l', 'a', 'c', 'e'] \\end{lstlisting}% \\begin{minipage}[t]{.52\\textwidth}% \\begin{lstlisting}[style=CIC-Python] for i in range(len(inteiros)): print(inteiros[i]) \\end{lstlisting}% \\end{minipage}% \\pause\\hfill% \\begin{minipage}[t]{.4\\textwidth}% \\begin{lstlisting}[style=CIC-Python] for c in caracteres: print(c); \\end{lstlisting}% \\end{minipage}% \\else% \\begin{frame}[fragile]%     Em \\texttt{Python}, o termo que descreve um conjunto de elementos \u00e9 cole\u00e7\u00e3o, e a mais simples \u00e9 a lista. O funcionamento \u00e9 similar ao de um vetor em C, mas com uma s\u00e9rie de facilidades.     \\vfill% \\begin{lstlisting}[style=CIC-Python] inteiros = [0, 1, 2, 3] reais = [0.0] * 10 caracteres = ['L', 'o', 'v', 'e', 'l', 'a', 'c', 'e'] \\end{lstlisting}% \\vfill\\pause% \\begin{minipage}[t]{.52\\textwidth}% \\begin{lstlisting}[style=CIC-Python] for i in range(len(inteiros)): print(inteiros[i]) \\end{lstlisting}% \\end{minipage}% \\pause\\hfill% \\begin{minipage}[t]{.4\\textwidth}% \\begin{lstlisting}[style=CIC-Python] for c in caracteres: print(c); \\end{lstlisting}% \\end{minipage}% \\end{frame} \\fi%</p> <p>\\ifIsArticle% O acesso aos elementos depende da posi\u00e7\u00e3o deles em rela\u00e7\u00e3o ao endere\u00e7o de in\u00edcio. Dependendo da linguagem, o primeiro elemento tem \u00edndice 0 (como em C, Java, Python, e Lisp) ou 1 (Fortran, COBOL, e Lua), mas por uma quest\u00e3o de simplicidade e facilidade de uso, a numera\u00e7\u00e3o deveria come\u00e7ar em zero[@Dijkstra1982].</p> <p>O acesso correto aos elementos depende tamb\u00e9m do tamanho do vetor. Na \\lC, os \\(n\\) elementos do vetor est\u00e3o localizados em um bloco cont\u00ednuo de bytes (com deslocamento em \\([0, n)\\), mas a aritm\u00e9tica de ponteiros permite que se acesse outras posi\u00e7\u00f5es [talvez inv\u00e1lidas] de mem\u00f3ria. Por exemplo, considerando a figura, a express\u00e3o <code>*(c-1)</code> (equivalente a  <code>c[-1]</code>) \u00e9 uma express\u00e3o sintaticamente correta, e resulta em endere\u00e7o de mem\u00f3ria v\u00e1lido (pois existe), mas \u00e9 semanticamente incorreta pois acessa um bloco de mem\u00f3ria que n\u00e3o foi alocado para o vetor em quest\u00e3o.</p> <p>\\lstC[linerange={10-24}]{exemplos/05_EstruturasDeDados/04_Vetor}{00-vetor.c}%</p> <p>Na \\lP, os \\(n\\) elementos sus podem ser acessados pelo \u00edndice correto: \\([0, n)\\), mas - obviamente - n\u00e3o h\u00e1 aritm\u00e9tica de ponteiros. Entretanto, h\u00e1 certas varia\u00e7\u00f5es que facilitam a vida. Por exemplo, o uso da fun\u00e7\u00e3o \\fn(len) e o uso de \u00edndices negativos para acessar os elementos em ordem inversa. No caso,</p> <p>\\begin{lstlisting}[style=CIC-Python] lista = [x for x in range(1, 10)]  # lista = [1, 2, 3, 4, 5, 6, 7, 8, 9]</p> <p>len(lista)        # 10 lsita.append(10)  # lista = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p> <p>lista[0]   # 1 lista[-0]  # 1 lista[-1]  # 10 lista[1:3] # [2, 3]\u2208</p> <p>for i in range(1, len(lista) + 1): print(lista[-i], end=' ')  # Ordem inversa: 10 9 8 7 6 5 4 3 2 1 \\end{lstlisting}% \\else% \\begin{frame}%   Considera\u00e7\u00f5es para vetores:   \\begin{itemize}%   \\item Muito cuidado com os \u00edndices utilizados, use somente \\(i\\in[0,n)\\).   \\item Pode n\u00e3o ser preciso ocupar todas as posi\u00e7\u00f5es do vetor, usar um vetor maior que o necess\u00e1rio muitas vezes facilita a vida...\\pause%   \\item Em \\lC: aloca\u00e7\u00e3o est\u00e1tica de mem\u00f3ria.   \\item Em \\lP: aloca\u00e7\u00e3o ``din\u00e2mica'' de mem\u00f3ria.   \\end{itemize}% \\end{frame}%</p> \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=6]{exercicios/05_EstruturasDeDados/04_Vetor}{01-medias}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=8]{exercicios/05_EstruturasDeDados/04_Vetor}{02-intercalados}% \\end{frame}\\] \\[\\begin{frame}&lt;handout:0&gt;[fragile]%     \\lstREADME[lastline=6]{exercicios/05_EstruturasDeDados/04_Vetor}{03-funcoes}% \\end{frame}\\] <p>\\begin{frame}[fragile]%     \\lstREADME[lastline=6]{exercicios/05_EstruturasDeDados/04_Vetor}{04-mais_funcoes}% \\end{frame} \\fi% <p>\\ifIsArticle% Vetores n\u00e3o s\u00e3o ponteiros, mas na \\lC~eles s\u00e3o praticamente equivalentes, e a rela\u00e7\u00e3o \u00e9 t\u00e3o forte que eles devem ser discutidos juntos2. O vetor \u00e9 conjunto cont\u00edguo de elementos homog\u00eaneos pr\u00e9-alocados com posi\u00e7\u00e3o e tamanho fixos, j\u00e1 o ponteiro \u00e9 uma refer\u00eancia para um [tipo espec\u00edfico de] dado qualquer. Um ponteiro \u00e9 uma vari\u00e1vel, ent\u00e3o <code>a = p</code> e <code>p++</code> s\u00e3o opera\u00e7\u00f5es v\u00e1lidas; j\u00e1 um vetor n\u00e3o \u00e9 uma vari\u00e1vel, ent\u00e3o <code>a = v</code> e <code>v++</code> n\u00e3o s\u00e3o v\u00e1lidas[@VanDerLinden1994].</p> <p>\\lstC[linerange={10-24}]{exemplos/05_EstruturasDeDados/04_Vetor}{01-vetor.c}%</p> <p>\\begin{center}% \\tikzinput{memoria/vetor_ptr}% \\end{center}% \\else% \\begin{frame}%     \\framesubtitle{\\LC}%     Vetores n\u00e3o s\u00e3o ponteiros.     \\\\vfill     \\begin{center}%     \\tikzinput{memoria/vetor_ptr}%     \\end{center}% \\end{frame}</p> <p>\\begin{frame}[fragile]%     \\lstC[linerange={10-24}]{exemplos/05_EstruturasDeDados/04_Vetor}{01-vetor.c}% \\end{frame} \\fi% <p>\\ifIsArticle% Na \\lP, listas s\u00e3o objetos mut\u00e1veis, portanto uma fun\u00e7\u00e3o pode alterar os elementos de uma lista dada como argumento: \\begin{lstlisting}[style=CIC-Python] def troca_primeiros(lista): lista[0], lista[1] = lista[1], lista[0]</p> <p>lista = [x for x in range(1, 10)] troca_primeiros(lista) lista  # [2, 1, 3, 4, 5, 6, 7, 8, 9] \\end{lstlisting}%</p> <p>Na \\lC, muito cuidado ao utiliz\u00e1-los como argumento de fun\u00e7\u00f5es - a situa\u00e7\u00e3o de ``equival\u00eancia'' pode gerar uma s\u00e9rie de problemas.</p> <p>\\noindent% \\begin{minipage}[t]{.5\\textwidth}% \\lstC[linerange={14-21}]{exemplos/05_EstruturasDeDados/04_Vetor}{apc_vetor.h}% \\end{minipage}% \\hfill% \\begin{minipage}[t]{.5\\textwidth}% \\lstC[linerange={11-21}]{exemplos/05_EstruturasDeDados/04_Vetor}{02-vetor.c}% \\end{minipage}%</p> <p>Certas aplica\u00e7\u00f5es interessantes de vetores exigem que seus elementos estejam ordenados (em rela\u00e7\u00e3o ao conte\u00fado). Existem diversas formas de se fazer isso (consegue elaborar um algoritmo de ordena\u00e7\u00e3o?), cada uma com certas caracter\u00edsticas. Por exemplo, para ordenar em ordem crescente, pode-se considerar o primeiro elemento e compar\u00e1-lo com todos os demais, sempre que o primeiro for menor que o comparado, troca-se os conte\u00fados de posi\u00e7\u00e3o. Desta forma, ao final de todas as compara\u00e7\u00f5es, o elemento na primeira posi\u00e7\u00e3o ser\u00e1 o menor de todos. Ent\u00e3o basta repetir este procedimento para cada posi\u00e7\u00e3o subsequente e, ao final da execu\u00e7\u00e3o, tem-se o vetor ordenado.%</p> <p>\\begin{lstlisting}[style=CIC-Python] for i in range(len(vetor) - 1): for j in range(i + 1, len(vetor)):     if(vetor[i] &gt; vetor[j])         vetor[i], vetor[j] = vetor[j], vetor[i] \\end{lstlisting}%</p> <p>Este simples algoritmo pode ser facilmente adaptado para ordenar o vetor em ordem decrescente. Na verdade, \u00e9 poss\u00edvel abstrair ainda mais este procedimento com uma fun\u00e7\u00e3o de compara\u00e7\u00e3o, que indica uma ordem entre dois elementos. Ent\u00e3o, supondo uma fun\u00e7\u00e3o <code>em_ordem</code>\\ que indica se os elementos est\u00e3o ordenados, o algoritmo pode ser redefinido como:%</p> <p>\\lstC[linerange={16-25}]{exemplos/05_EstruturasDeDados/04_Vetor}{03-vetor.c}%</p> <p>Assim o algoritmo abstrai a fun\u00e7\u00e3o de compara\u00e7\u00e3o, e pode ser usado para realizar ordena\u00e7\u00f5es diferentes:</p> <p>\\lstC[linerange={13-14,26-27,33-33,37-37    ,40-42},morekeywords={ordena}]{exemplos/05_EstruturasDeDados/04_Vetor}{03-vetor.c}%</p> <p>Por fim, a \\lC~tem ``declara\u00e7\u00f5es complicadas'' (se\u00e7\u00e3o 5.12 de \\cite{Kernighan1989}), \u00e9 melhor entender o funcionamento que [tentar] adivinhar o tipo. Por exemplo:</p> <p>\\begin{lstlisting}[style=CIC-C] char argv / argv: ponteiro para ponteiro para char /</p> <p>int ( tabdia)[13] / tabdia: ponteiro para vetor[13] de int */</p> <p>int * tabdia[13] / tabdia: vetor[13] de ponteiro para int /</p> <p>void comp() / comp: fun\u00e7\u00e3o retornando ponteiro para void */</p> <p>void ( comp)() / comp: ponteiro para fun\u00e7\u00e3o retornando void */</p> <p>char ((x())[])() / x: fun\u00e7\u00e3o retornando ponteiro para vetor[] de ponteiro para fun\u00e7\u00e3o retornando char /</p> <p>char ((x[3]))[5] / x: vetor[3] de ponteiro para fun\u00e7\u00e3o retornando ponteiro para vetor[5] de char / \\end{lstlisting}% \\fi%</p> Considerando 4 bits para armazenar um n\u00famero real como ponto fixo, determine qual a representa\u00e7\u00e3o do valor \\(1,25_{10}\\) como \\(Q1.3\\), \\(Q2.2\\) e \\(Q3.1\\).  <ul> <li>\\(Q1.3 \\Rightarrow 1,25_{10} = 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} + 0\\cdot2^{-3} = 1010_2\\)</li> <li>\\(Q2.2 \\Rightarrow 1,25_{10} = 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} = 0101_2\\)</li> <li>\\(Q3.1\\) n\u00e3o \u00e9 adequado para este valor. Tem-se duas possibilidades:<ul> <li>\\(1,25_{10} \\approx 0\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2} = 0001_2 (=1,5_{10})\\)</li> <li>\\(1,25_{10} \\approx 0\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 0\\cdot2^{-2} = 0010_2 (=1,0_{10})\\)</li> </ul> </li> </ul> <ol> <li> <p>American National Standards Institute. American National Standard for Information Systems \u2014 Coded Character Sets \u2014 7-Bit American National Standard Code for Information Interchange (7-Bit ASCII), ANSI X3.4-1986. Technical Report, American National Standards Institute, 1896. URL: http://sliderule.mraiow.com/w/images/7/73/ASCII.pdf.\u00a0\u21a9</p> </li> <li> <p>Brian W. Kernighan and Dennis M. Ritchie. C: a linguagem de programa\u00e7\u00e3o padr\u00e3o ANSI. Campus, Rio de Janeiro, 1989. ISBN 8570015860 9788570015860.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"}]}